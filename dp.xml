<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!--[
<!ENTITY % fithesis SYSTEM "http://www.fi.muni.cz/~xpavlov/fithesis.mod">
%fithesis;
]>
-->
<book lang="en">
  <bookinfo>
    <title>isReal-time Communication \\* in Web Browser</title>

    <subtitle>Master's thesis</subtitle>

    <author>
      <firstname>Pavel</firstname>

      <surname>Smolka</surname>

      <fi:woman
      xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">false</fi:woman>

      <fi:faculty
      xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">fi</fi:faculty>

      <fi:advisor xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">doc.
      RNDr. Tomáš Pitner, Ph.D.</fi:advisor>
    </author>

    <fi:thanks xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">
      <para>Above all, I would like to thank my colleagues from Celebrio, with
      whom I have been working for a long time and who inspired me to create
      this thesis; especially Petr Kunc, always challenging my ideas but
      always being helpful. Of course, I would also like to thank my advisor,
      doc. Tomáš Pitner, for not only providing me with valuable advice and
      help during the work on my thesis, but also for guiding me through the
      studies at the faculty.</para>

      <para>I am very thankful to my parents for bringing me up to this point
      in the best way parents can, and still splendidly supporting and
      encouraging me to do my best. Also, I thank my nearest for having
      patience with me working and studying and hardly finding any time for
      them.</para>

      <para>I must not forget my Lasaris laboratory fellow students, revealing
      the world of web development to me. I would also like to thank my
      English teacher, Petra Wachsmuthová, for helping me with the language
      part. And of course my classmates, colleagues and friends, not only for
      reviewing the text part of this thesis but also for discussing the
      technologies and the programming part as well.</para>

      <para>After all, I am grateful to the Internet community, StackOverflow
      members, various IRC attendants, people contributing and commenting at
      GitHub, Twitter and other media sources that helped me and inspired me
      all the time. Thank you, world!</para>
    </fi:thanks>

    <pubdate>2013</pubdate>

    <abstract>
      <para>The thesis comprehends the topic of real-time communication in a
      web browser. Most of the available solutions for building real-time web
      applications are described and compared, with regards to security,
      browser support and usage difficulty. According to the theoretical
      results, a real-time application Talker is designed and developed,
      serving as text and video instant messaging client for Celebrio --
      simple web-based application environment for the elderly. XMPP protocol,
      used in Talker in order to be interconnectible with other instant
      messaging clients, is also mentioned within the thesis, especially with
      regards to running the XMPP client in web browser.</para>
    </abstract>

    <keywordset>
      <keyword>XMPP</keyword>

      <keyword>real-time communication</keyword>

      <keyword>RTC</keyword>

      <keyword>Celebrio</keyword>

      <keyword>web browser</keyword>

      <keyword>HTTP</keyword>

      <keyword>Comet</keyword>

      <keyword>JavaScript</keyword>

      <keyword>WebSockets</keyword>

      <keyword>BOSH</keyword>

      <keyword>Ember</keyword>

      <keyword>Strophe</keyword>

      <keyword>OpenTok</keyword>

      <keyword>Talker</keyword>

      <keyword>server push</keyword>
    </keywordset>
  </bookinfo>

  <toc></toc>

  <chapter id="uvod">
    <title>Introduction</title>

    <para>Millions, billions, trillions. So many and even more messages are
    exchanged every day between various people in the world. The Internet
    created a brand new way to communicate and collaborate, even if you are
    located on the opposite parts of the world. Since the times of Alexander
    Graham Bell, the accessibility to the communication devices and their
    simplicity have been incredibly enhanced. Nowadays, almost 2.5 billion
    people in the world have access to the Internet and, therefore, they are
    able to use almost limitless communication possibilities it provides.
    <citation>internet-usage</citation></para>

    <para>However, the manner of Internet usage essentially changed during the
    first decade of 21<superscript>st</superscript> century. Using the
    Internet and using the web browser became almost synonymous. People use
    the web browser as the primary platform to do every single task on the
    Internet. Sometimes it is not even possible to use the other Internet
    services without visiting certain web page in the web browser and
    performing the authentication there.<footnote>
        <para>Two examples of such behavior. Wi-fi network in the Student
        Agency coaches forces the user to visit the entry page in the web
        browser. The second example, very well known to the students of the
        Faculty of Informatics at Masaryk University, is the faculty wireless
        network called wlan_fi. Every user has to open the web browser and log
        in with her credentials. It is not possible just to open the terminal
        or e-mail client and start working online.</para>
      </footnote> Considering the mentioned fact, web browsers have become
    also the basic platform for the communication tools. Even though the
    purpose of the world wide web and HTTP protocol was completely different
    at first (displaying single documents connected via hypertext links), it
    appeared that there was a need for common rich applications running within
    a web browser -- a rich Internet application (RIA) sprang up.
    <citation>ria</citation> Such popular social networks are built on top of
    the web browser platform and they are used by more than a billion people
    in the world. <citation>facebook-usage</citation> And the main reason why
    the social networks are so popular is the real-time stream of news and
    messages from other people. At the beginning of 2013, I would say that
    static web is dead -- users prefer interactivity.</para>

    <para>As mentioned above, the web browser has become one of the most
    popular platforms. Celebrio, a simple software for the elderly, simulating
    the operating system interface, is a typical example of a rich Internet
    application.<footnote>
        <para><ulink
        url="http://www.celebriosoftware.com/celebrio-system">http://www.celebriosoftware.com/celebrio-system</ulink></para>
      </footnote> All the topics mentioned in the previous paragraph appeared
    to be very important in the system. When interviewing the elderly people
    in the Czech Republic, it appeared that almost 90 % of the elderly
    computer users use the real-time communication (RTC) applications, mostly
    Skype. <citation>elderly-questionnaires</citation> Interaction with their
    loved ones is the most desired benefit they expect from the computer.
    Therefore, creating a real-time application, a text messenger supporting
    video calling, has become not only a programming challenge but also a
    business goal.</para>

    <para>With regard to the <quote>real-time tendency</quote>, this thesis
    embraces the topic of real-time applications in web browsers, especially
    the text communication tools and the technologies being used to develop
    them. Among the available solutions, XMPP protocol and OpenTok library
    (built on WebRTC) have been chosen and a real-time communication
    application has been designed and developed as a part of this thesis. Both
    text and multimedia streams are covered, as well as multimedia content
    transfer (audio and video).</para>

    <para>Considering the fact that people prefer real-time communication (not
    only direct messaging but also real-time cooperation, simultaneous
    document editing or playing multiplayer games) while using a web browser
    brings us to the question what the currently available solutions are.
    There are <quote>big players</quote> providing their own services as
    closed-source, without the possibility to being used by third party
    developers. To name the most important ones, it is Google Talk web browser
    client and Facebook chat, using XMPP<indexterm>
        <primary>XMPP</primary>
      </indexterm> protocol.
    <citation>gtalk</citation><citation>fb-chat</citation> Even though
    Facebook<indexterm>
        <primary>Facebook</primary>
      </indexterm> chat service is not a pure XMPP server implementation (the
    message and presence engine is a proprietary system of Facebook,
    implemented mostly in C++ and Erlang), they provide the possibility to
    connect to the <quote>world of Facebook Chat</quote> via XMPP as proxy.
    <citation>fb-erlang</citation> The combination of the facts that XMPP is
    an open technology with an open-sourced client and server implementations
    <citation>xmpp-history</citation> and the big Internet companies also use
    it persuaded us to use it in our communication application, too. XMPP
    itself and its usage in web applications is described in <xref
    linkend="chap-xmpp" />.</para>

    <para>Nevertheless, there are also other RTC solutions not directly based
    in a web browser. Very popular communication platforms, XMPP (Jabber), ICQ
    or Windows Live Messenger have to be mentioned, all intended to run in
    dedicated client applications (Pidgin, ICQ, ...). All of them have been
    ported to a web browser in some way, in the form of applications such as
    Meebo (supporting ICQ and XMPP, however closed lately) or Google Talk
    (XMPP). There are also several voice over IP (VoIP) tools providing a
    video call platform, such as Skype<indexterm>
        <primary>Skype</primary>
      </indexterm>. To make this list comprehensive, Unix <quote>talk</quote>
    chat program for sending text messages has to be mentioned. However, it
    was superseded by previously mentioned modern systems.</para>

    <para>Since the web browser was designed to perform simple
    request/response interaction, it is not a typical platform for building
    real-time applications. Thus, there is a need for an extra layer enhancing
    or even completely replacing the common way HTTP communicates. Within the
    scope of this thesis, primarily the WebSockets and HTTP long polling
    approaches are used. The two of them and basic information about several
    others are covered in <xref linkend="chap-rtc" />.</para>

    <para>There are many existing real-time chat-based applications on the
    Internet that could have been used. However, none of them suited our needs
    perfectly. Celebrio has a very specific graphical user interface (GUI) and
    there is a need to integrate both text-based chat and video calling. Just
    to mention, there is the commercial chat module Cometchat<footnote>
        <para>http://www.cometchat.com/</para>
      </footnote> or even the open project Jappix.<footnote>
        <para>https://project.jappix.com/</para>
      </footnote> Video calling web browser applications are provided for
    example by TokBox Inc.<footnote>
        <para>http://www.tokbox.com/</para>
      </footnote> Nevertheless, following the rule that <quote>If you have to
    customize 1/5 of a reusable component, its likely better to write it from
    scratch</quote>, <citation>brian-stats-tweet</citation> just very generic
    existing libraries (Strophe.js) and APIs (OpenTok) were used for
    implementing a brand new application called <emphasis>Celebrio
    Talker</emphasis>. The general approaches when building web browser based
    chat application are mentioned in <xref
    linkend="chap-xmpp-in-javascript" />. Within the programming part of the
    thesis, the real-time text chat application and the video calling
    application for Celebrio have been implemented. Celebrio Talker
    application itself, its architecture and the specific procedures used to
    create it are described in <xref linkend="chap-talker" />.</para>

    <para>It has been said that Skype<indexterm>
        <primary>Skype</primary>
      </indexterm><footnote>
        <para>http://www.skype.com/</para>
      </footnote> is the most favorite communication tool among the target
    audience. If it were implemented, the existing customer base could be used
    and converted to our messaging application. However, there is one big
    pitfall in this approach. The Skype license strictly prohibits
    incorporating their software into mobile devices in third party
    applications. <citation>skype-license</citation> They support only
    prompting the official Skype client to be opened via Skype URI, which is
    insufficient for Celebrio since the messaging client has to be built in
    the system, with the corresponding user interface.
    <citation>skype-uri</citation></para>
  </chapter>

  <chapter id="chap-rtc">
    <title>Bidirectional communication between a web browser and a
    server</title>

    <para>The very essence of every instant messaging is the bidirectional
    stream where both sides can immediately <emphasis>push</emphasis> new data
    and the other side (or more other sides) is promptly notified without the
    need to perform any manual <emphasis>pull</emphasis> (update)
    action<indexterm>
        <primary>pull &amp; push communication</primary>
      </indexterm>.<footnote>
        <para>In this thesis, this behaviour is commonly referred as RTC. The
        <quote>real-time part</quote> relates mostly to the server part since
        the application running in the web browser can perform the AJAX
        request on background anytime and the server receives the request
        instantly.</para>
      </footnote> Such use case requires an appropriate transport layer on top
    of which the application can send messages via another protocol. When
    using HTTP, there is a TCP connection opened by the client (web browser)
    through which the data is sent. However, according to the HTTP
    protocol<indexterm>
        <primary>HTTP</primary>
      </indexterm>, the communication is strictly initiated by the client --
    HTTP is a request/response protocol. <citation>rfc-http</citation> When
    the client continuously needs up-to-date information, it must poll the
    server as frequently as possible. Such approach takes a considerable
    amount of bandwidth and generates purposeless overhead on the server. So,
    when one wants to avoid those drawbacks and still make the web browser
    application communicate in both directions, HTTP protocol must be hacked
    somehow or another communication channel used. This chapter covers both --
    reshaping HTTP in <xref linkend="chap-http-requests" /> and a brand new
    approach in <xref linkend="chap-ws" />, bypassing HTTP completely.
    Unfortunately, every approach brings also some disadvantages. Ultimately,
    an overview of several higher-level solutions is to be found in <xref
    linkend="chap-high-level-rtc" />, most of which are based on HTTP requests
    or WebSockets.</para>

    <sect1 id="chap-http-requests">
      <title>Using HTTP requests</title>

      <para>Hypertext Transfer Protocol represents the most widely used
      protocol in web applications. It is a typical example of an application
      layer protocol (7th level), according to OSI Model<indexterm>
          <primary>OSI Model</primary>
        </indexterm> (ISO/IEC 7498-1). HTTP powers the Web. Along with other
      application layer protocols -- Simple Mail Transfer Protocol
      (SMTP)<indexterm>
          <primary>SMTP</primary>
        </indexterm>, File Transfer Protocol (FTP)<indexterm>
          <primary>FTP</primary>
        </indexterm> and DNS (domain name system) protocols -- HTTP
      constitutes the whole Internet as we know it. HTTP works as a
      <quote>request-response</quote> protocol, presuming an underlying
      transport layer protocol on top of which it works. The underlying
      transport protocol is almost always represented by Transmission Control
      Protocol (TCP)<indexterm>
          <primary>TCP</primary>
        </indexterm>, however, UDP can be used as well (for example in case of
      Simple Service Discovery Protocol (SSDP). <citation>ssdp-udp</citation>
      Nowadays, HTTP is not only used by web browser clients but also, thanks
      to its simplicity, by various mobile applications and Internet services,
      requesting new data or updating the information on a server.</para>

      <para>HTTP is a very lightweight client-server protocol, where a client
      carries out a request and a server responds. The request specifies the
      action and a resource the action relates to, along with the protocol
      version. For example, the following request line represents a request
      fetching index.html file from the server:</para>

      <programlisting>GET /index.html HTTP/1.1</programlisting>

      <para>A further request data is optional. After the initial line, custom
      request headers can be specified, along with an optional request body,
      which usually contains the request data. <citation>rfc-http</citation>
      For example, in case of POST request, updating the resource, the new
      resource data is contained in the request body.</para>

      <para>HTTP response structure is similar to a request. The first initial
      line contains the response status code and a <quote>reason
      phrase</quote>, which identify how the request was handled.
      <citation>rfc-http</citation> Then, optional headers and message body
      can be listed. The following piece of code displays the response to the
      previous example request, resulted in success and transferring simple
      HTML code to the client:</para>

      <programlisting>HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8

&lt;html&gt;&lt;body&gt;&lt;p&gt;
  This is the HTML content in response body, 
  separated by one blank line from the headers.
&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</programlisting>

      <para>The very first approach to achieve RTC in a web browser, for a
      very long time the only one, is hacking HTTP. The idea is very simple.
      Generally, the client sends an extra request and it is not awaiting an
      immediate response. Instead, the server keeps the request for some time
      and sends the data as it comes in the response. There are several
      techniques to achieve such behaviour, in general called
      <emphasis>Comet</emphasis><indexterm>
          <primary>Comet</primary>
        </indexterm>. Naive approach, consisting of ordinary HTTP requests,
      along with more advanced techniques of HTTP long polling and HTTP
      streaming are described in the following sections.</para>

      <sect2>
        <title>Naive approach to real-time communication with HTTP</title>

        <para>It would be useful to keep an HTTP request opened for a bit
        longer time in order to perform real-time communication within an
        opened stream. When simple HTTP is used, however, each request
        corresponds to exactly one resource retrieved from a server. There is
        one common misunderstanding about long-lived HTTP requests. Since HTTP
        1.1 (actually implemented even before, but not covered in the RFC
        specification), there is a possibility for the client to claim a
        persistent TCP<indexterm>
            <primary>TCP</primary>
          </indexterm> connection to the server, declaring
        <computeroutput>Connection: Keep-Alive</computeroutput> in the request
        header.<indexterm>
            <primary>HTTP</primary>

            <secondary>Keep-Alive</secondary>
          </indexterm> Actually, all connections are considered persistent
        unless declared otherwise. <citation>rfc-http</citation> Even though
        the default timeout after which the server closes the connection lasts
        only several seconds, <citation>apache-core-features</citation> the
        persistent TCP connection is very useful for delivering various
        resources (style sheets, scripts, images, etc.) to the client without
        the unnecessary overhead of creating multiple streams. However, every
        single transmission within the TCP connection has to be in form of a
        separate HTTP request/response, always initiated by the client. On no
        account is the server allowed to push any data without a respective
        request from the client. Therefore, such TCP connection is of no use
        to RTC.</para>

        <para>The situation is depicted in <xref linkend="fig-http-polling" />
        and <xref linkend="fig-http-polling-wrong" />. In the former case, a
        valid sequence of HTTP requests and responses is shown. Nevertheless,
        there is a delay between the moment the server gets (either generates
        or receives from a third party) the data (2) and the following request
        (3). Yet, it is possible to reduce the latency by shortening the
        polling time (the time between Response (1.1) and Request (3)), it is
        still a trade-off between the delay and overhead caused by frequent
        empty request/response pairs.</para>

        <figure id="fig-http-polling">
          <title>Correct HTTP polling with delay</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/http-polling.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <figure id="fig-http-polling-wrong">
          <title>Forbidden HTTP response without respective request</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/http-polling-wrong.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>On the other hand, <xref linkend="fig-http-polling-wrong" />
        depicts the forbidden situation of generating an HTTP response without
        a respective previous request. When the server gets the data (2), it
        is not allowed to initiate the connection and send an HTTP response
        without an appropriate preceding request (2.1). Even though the delay,
        mentioned in the previous paragraph, can be minimized in this
        situation, HTTP servers cannot use such a technique. To sum it up, a
        response (2.1) is forbidden by HTTP protocol and, therefore, this
        situation solution is not valid.</para>
      </sect2>

      <sect2 id="chap-http-long-polling">
        <title>HTTP long polling<indexterm>
            <primary>HTTP</primary>

            <secondary>long polling</secondary>
          </indexterm></title>

        <para>The essence of HTTP long polling springs from the idea of
        prolonging the time span between two poll requests. In traditional
        <quote>short polling</quote>, a client sends regular requests to the
        server and each request attempts to <quote>pull</quote> the available
        data. If no data is available, an empty response is sent.
        <citation>rfc-bidirectional-http</citation> That generates unnecessary
        overhead for both the client and the server.</para>

        <para>On the contrary, long polling tries to reduce this load. After
        receiving the request, the server <emphasis>does not</emphasis> answer
        immediately and holds the connection opened. When the server receives
        (or even makes up by itself) new data, it carries out the response
        with the respective content, as depicted in <xref
        linkend="fig-http-long-polling" />.</para>

        <figure id="fig-http-long-polling">
          <title>HTTP long polling</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/http-long-polling.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>As soon as the client obtains the response, it usually issues a
        new request immediately, so the process can repeat endlessly. If no
        data appears on the server for a certain amount of time, it usually
        responds with an empty data field just to renew the connection.</para>

        <para>One of the main drawbacks of long polling is the header
        overhead. Every chunk of data in RTC applications is usually very
        short, for example a text message of minimal length. However, each
        update is served by a full HTTP request/response with the header
        easily reaching 800 characters.
        <citation>pro-html5-programming</citation> If the payload is a message
        20 characters long, the header constitutes 4000% overhead!<indexterm>
            <primary>HTTP</primary>

            <secondary>header overhead</secondary>
          </indexterm> This drawback has an even bigger impact as the number
        of clients increases. <xref linkend="fig-http-overhead" /> shows the
        comparison of 1000 (A), 10000 (B) and 100000 (C) clients polling the
        server every second with the message 20 characters long, both using
        classic HTTP requests and WebSockets technology (mentioned in <xref
        linkend="chap-ws" />). <citation>pro-html5-programming</citation> It
        is obvious that there is huge unnecessary network overhead when using
        HTTP polling instead of WebSockets.</para>

        <figure id="fig-http-overhead">
          <title>Comparison of network overhead (HTTP and WebSockets)</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="img/http-overhead.png" width="420pt" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Furthermore, if the server has just received the data and sent
        the response to the client, there is a <quote>blind window</quote>
        when the server cannot notify the client. The whole push system is
        blocked until the response is received by the client, processed and a
        new request is delivered back to the server. Considering also the
        possible packet loss and required retransmission in the TCP protocol,
        the delay can be even longer than double bandwidth latency.
        <citation>rfc-bidirectional-http</citation></para>
      </sect2>

      <sect2 id="chap-http-streaming">
        <title>HTTP streaming<indexterm>
            <primary>HTTP</primary>

            <secondary>streaming</secondary>
          </indexterm></title>

        <para>HTTP streaming is a slightly different technique than long
        polling, although they are confused one with the other very often.
        What is mutual for both of the approaches is the client initializing
        the communication by an HTTP request. The server also sends the update
        as the part of the HTTP response. The main difference is that once the
        server initializes the response and sends the data, it does not
        terminate the response and keeps the HTTP connection opened.
        Meanwhile, the client listens to the response stream and reads the
        data pushed from the server. When any new data springs up on the
        server side, it is concatenated to the one existing response stream.
        <citation>rfc-bidirectional-http</citation> See the scheme in <xref
        linkend="fig-http-streaming" />.</para>

        <figure id="fig-http-streaming">
          <title>HTTP streaming</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/http-streaming.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>It is very important not to confuse HTTP streaming with the
        <quote>persistent</quote> HTTP requests. As said at the beginning of
        this chapter, declaring <computeroutput>Connection:
        Keep-Alive</computeroutput> does not allow the server to issue
        multiple responses to a single request. Such behaviour would be
        serious violation of HTTP protocol. Instead, the server can declare
        <computeroutput>Transfer-Encoding: chunked</computeroutput><indexterm>
            <primary>HTTP</primary>

            <secondary>chunked response</secondary>
          </indexterm> status in the response header and send the response
        split into separate pieces, as shown below (chunk of zero length
        stands for the end of the response):
        <citation>rfc-bidirectional-http</citation></para>

        <programlisting>HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

0</programlisting>

        <para>The main drawback of HTTP streaming can be generally called
        buffering. There is no requirement for both the client and an
        intermediary (proxies, gateways, etc.) to handle the incoming data
        until the whole response is sent. Therefore, all parts of the response
        could be kept by the proxy and the messages (single HTTP response
        chunks) are not delivered to the client until the whole response is
        sent. Similarly, when the response consists of JavaScript statements,
        the browser does not have to execute them before the whole response is
        obtained (yet, most of the browsers execute it immediately). In such
        cases, HTTP streaming will not work.
        <citation>rfc-bidirectional-http</citation></para>
      </sect2>
    </sect1>

    <sect1 id="chap-ws">
      <title>Permanent TCP streams with WebSockets<indexterm>
          <primary>WebSockets</primary>
        </indexterm></title>

      <para>Although the World Wide Web with an HTTP request/response scheme
      has never been intended to serve as an RTC platform, the contemporary
      applications require such functionality and developers started to bend
      the protocol in an undesirable way. Most of the patterns described in
      <xref linkend="chap-http-streaming" /> do their jobs and one can achieve
      sufficient two-way communication. Yet, there are certain performance
      issues and drawbacks which make them difficult to use. At least, those
      techniques carry HTTP header overhead which is unnecessary for standard
      bidirectional streams. Therefore, a brand new standard for creating
      full-duplex communication channels between a web browser and a server
      has been created. The technology is called
      <emphasis>WebSockets</emphasis><indexterm>
          <primary>WebSocket</primary>
        </indexterm> (sometimes shortened as WS) and it stands for a
      communication protocol layered over the TCP along with a browser API for
      web developers. Anyway, not even WebSockets are allowed to access wider
      network -- their connection possibilities are limited only to the
      dedicated WS servers (usually HTTP servers with additional module for WS
      support attached). <citation>js-definitive-guide</citation></para>

      <para>Similarly as in HTTP, there is an unencrypted version of
      WebSockets working directly on top of TCP connection. The simplest way
      to recognize such a connection is WebSocket URI<indexterm>
          <primary>WebSocket</primary>

          <secondary>URI</secondary>
        </indexterm>, beginning with <computeroutput>ws://</computeroutput>.
      It should not be used for two reasons. The first one, rather obvious, is
      security<indexterm>
          <primary>security</primary>
        </indexterm> -- the communication can be captured during the
      transmission. Transparent proxy servers are the second reason. If an
      unencrypted WebSocket connection is used, the browser is unaware of the
      transparent proxy and as a result, the WebSocket connection is most
      likely to fail.
      <citation>ws-proxy</citation><citation>definitive-guide-to-ws</citation>
      As opposite, there is a secure way to use WebSockets. WebSockets Secure
      (WSS)<indexterm>
          <primary>WebSocket</primary>

          <secondary>Secure</secondary>
        </indexterm> protocol is standard WS wrapped in TLS tunnel, similarly
      as HTTP can be transmitted over TLS layer. When using WSS, the URI
      begins with <computeroutput>wss://</computeroutput> and it uses port 443
      by default. <citation>definitive-guide-to-ws</citation></para>

      <sect2>
        <title>WebSocket handshake<indexterm>
            <primary>WebSocket</primary>

            <secondary>handshake</secondary>
          </indexterm></title>

        <para>WebSockets, as any other multilateral protocol, need to perform
        a handshake before an actual transmission can occur. During the
        handshake, a connection is established and both peers acknowledge the
        properties of the communication.</para>

        <para>Since WebSockets emerged as an HTTP supplement, the handshake is
        initialized by an HTTP request<footnote>
            <para>According to RFC6455, the protocol is designed to work over
            the HTTP port 80, as well as 443 to support HTTP proxies. However,
            the design is not limited to HTTP and the future implementations
            can use simpler handshake over a dedicated port.
            <citation>rfc-ws</citation></para>
          </footnote> initialized by a client. The client sends the request as
        follows: <citation>rfc-ws</citation></para>

        <programlisting>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: RWFzdGVyIGVnZyBmb3IgQWRh
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13</programlisting>

        <para>Let us have a look at what each of the lines means. The first
        two lines are obvious, they represent a typical HTTP GET request.
        Specifying <computeroutput>Host</computeroutput> is important for the
        server to be able to handle multiple virtual hosts on a single IP
        address. The following two lines, <computeroutput>Upgrade:
        websocket</computeroutput> and <computeroutput>Connection:
        Upgrade</computeroutput>, are the most important. A client informs a
        server about the desire to use WebSockets. The rest of the request
        stands for additional information for the server to be able to respond
        correctly. RFC 6455 describes the details.
        <citation>rfc-ws</citation></para>

        <para>The server should send an HTTP response looking similar to the
        following example: <citation>rfc-ws</citation></para>

        <programlisting>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</programlisting>

        <para>The number 101 on the first line of the response stands for the
        HTTP status code <computeroutput>Switching Protocols</computeroutput>,
        <citation>rfc-http</citation> which means the server supports
        WebSockets and the connection can be established. Any status code
        other than 101 indicates that the WebSocket handshake has not
        completed and the semantics of the HTTP still apply.
        <citation>rfc-ws</citation></para>

        <para><computeroutput>Sec-WebSocket-Key</computeroutput> is a random
        secret issued by a client, base64-encoded and added to an initial
        protocol-switching request. A server is supposed to concatenate the
        secret with Globally Unique Identifier (GUID)<indexterm>
            <primary>GUID</primary>
          </indexterm> "258EAFA5-E914-47DA- 95CA-C5AB0DC85B11" and hash the
        result with the SHA-1 algorithm. The result is returned as
        <computeroutput>Sec-WebSocket-Accept</computeroutput> header field,
        base64-encoded. <citation>rfc-ws</citation> However, a security issue
        here seems to be in this process. If the initial request is not sent
        over an encrypted HTTP connection (HTTPS), it can be caught by a third
        party. Since the server does not authenticate in any way and the
        algorithm does not contain any server secret, the third party attacker
        could fake the response and pretend to be the server.</para>
      </sect2>

      <sect2>
        <title>Frames and masking</title>

        <para>All the data sent via the WebSockets protocol is chunked into
        frames<indexterm>
            <primary>frames</primary>
          </indexterm>, working similarly to TCP frames. All transmission
        features are handled by the WebSocket API and the transmission is
        transparent for the application layer above (for example the
        JavaScript API) so that every message appears in the same state as it
        was sent. This means the message, a single portion of WS
        communication, can be fragmented during the transmission.</para>

        <para>There are several special features concerning WS frames, one of
        the interesting ones is masking<indexterm>
            <primary>masking</primary>
          </indexterm>. The payload data of every frame sent from a client is
        XORed by a masking key of a 32-bit size. The purpose of masking is to
        prevent any third party from picking any part of the payload and
        reading it. The other goal might be distinguishing a server stream
        from a client stream instantly since client-to-server frames always
        <emphasis>must</emphasis> be masked and server-to-client frames
        <emphasis>must not</emphasis> be masked under any circumstances. In
        addition, WS peers have to use masking even if the communication is
        running on top of TLS layer so the <quote>encryption</quote> function
        is pointless. <citation>rfc-ws</citation> The security function of
        masking is also questionable because the masking key is included in a
        frame header. The only reason is preventing from random cross-protocol
        attacks. <citation>pro-html5-programming</citation></para>
      </sect2>

      <sect2>
        <title>WS JavaScript API<indexterm>
            <primary>WebSocket</primary>

            <secondary>API</secondary>
          </indexterm></title>

        <para>Since the WebSocket technology is intended to be used
        particularly from browser applications, there is a need for an API web
        developers can use. The most widespread programming language of web
        browser client applications is JavaScript and so is the WebSocket API
        created for it. The API consists of one relatively simple JavaScript
        interface called <computeroutput>WebSocket</computeroutput>,<footnote>
            <para>In the older versions of some browsers, the interface was
            called differently due to the technology immaturity. For instance,
            Firefox from version 6 to 10 supports WebSockets only as
            <computeroutput>MozWebSocket</computeroutput>. An interesting fact
            is that Firefox 4 and 5 provides
            <computeroutput>WebSocket</computeroutput> interface as it is,
            just implementing a different WebSocket protocol version. Since
            Firefox 11.0, current (RFC 6455) WS protocol version is accessible
            via <computeroutput>WebSocket</computeroutput> interface.
            <citation>mozilla-ws</citation></para>
          </footnote> <citation>ws-api</citation> placed as a property of
        <computeroutput>window</computeroutput> object.<footnote>
            <para>Properties of <computeroutput>window</computeroutput> are
            accessible in JavaScript directly. Simple test
            <computeroutput>window.WebSocket === WebSocket</computeroutput>
            returning <computeroutput>true</computeroutput> proves it.</para>
          </footnote> It wraps the WebSocket client functionality performed by
        a user agent (i.e. a web browser). Using the API is very simple. The
        object, which handles all the WS functionality, is created by calling
        a <computeroutput>WebSocket</computeroutput> constructor:
        <citation>ws-html5rocks</citation></para>

        <programlisting>var connection = new WebSocket(
        'ws://html5rocks.websocket.org/echo', 
        ['soap', 'xmpp']
);</programlisting>

        <para>The first (mandatory) argument stands for a WebSocket URI a
        client attempts to connect to. It can either begin with a
        <computeroutput>ws://</computeroutput> prefix or
        <computeroutput>wss://</computeroutput>, depending whether the TLS
        layer is to be used or not. The second parameter is optional --
        specific WS subprotocols can be demanded there. Since there are only a
        few subprotocols recorded by IANA registry, it has been of little use
        so far. <citation>ws-iana</citation></para>

        <para><computeroutput>WebSocket</computeroutput> interface provides at
        least four event handlers, to each of whom a custom callback can be
        attached. <citation>ws-api</citation> Those are
        <computeroutput>onopen</computeroutput>,
        <computeroutput>onmessage</computeroutput>,
        <computeroutput>onerror</computeroutput> and
        <computeroutput>onclose</computeroutput>. The names are rather
        self-explanatory, they serve as the event listeners watching for an
        incoming activity -- anytime the websocket obtains a message, its
        status changes or an error occurs, and the respective callback is
        fired. The callback registration can look as follows:</para>

        <programlisting>connection.onmessage = function (message) {
  console.log('We got a message: ' + message.data);
};</programlisting>

        <para>In addition, there is a property
        <computeroutput>readyState</computeroutput> (it would be
        <computeroutput>connection.readyState</computeroutput> in the previous
        example), keeping the current WebSocket status all the time. The
        status can be retrieved by testing the property against one of the
        <computeroutput>WebSocket</computeroutput> property constants
        <computeroutput>CONNECTING</computeroutput>,
        <computeroutput>OPEN</computeroutput>,
        <computeroutput>CLOSING</computeroutput> or
        <computeroutput>CLOSED</computeroutput>.</para>

        <para>Sending the data to a server is also rather straightforward.
        Either <computeroutput>DOMString</computeroutput>,
        <computeroutput>ArrayBuffer</computeroutput>,
        <computeroutput>ArrayBufferView</computeroutput> or
        <computeroutput>Blob</computeroutput> can be sent via the
        <computeroutput>send</computeroutput> method. See the examples below:
        <citation>ws-html5rocks</citation></para>

        <programlisting>// Sending a String
connection.send('string message');

// Sending the canvas ImageData as an ArrayBuffer
var img = canvas_context.getImageData(0, 0, 400, 320);
var binary = new Uint8Array(img.data.length);
for (var i = 0; i &lt; img.data.length; i++) {
  binary[i] = img.data[i];
}
connection.send(binary.buffer);

// Sending a file as a Blob
var file = document.querySelector('input[type="file"]').files[0];
connection.send(file);</programlisting>

        <para>To sum it up, using WebSockets became a very simple and elegant
        way to provide a real-time communication channel between a web browser
        and a WS server. The main drawback of WS is lack of support not only
        in the older versions of web browsers but also in the mobile platform
        browsers. Currently, less than 60 % of users can make use of the
        WebSocket full support. <citation>ws-caniuse</citation> Particularly,
        all versions of Internet Explorer below 10 (which means more than 98 %
        of IE users in November 2012) <citation>ie-statistics</citation> do
        not implement the WebSockets JavaScript API. There are two favourable
        aspects in favour of WebSockets. Firstly, more and more web browsers
        add the JavaScript API to support WebSockets. Secondly, the ratio of
        clients who use an old version of a web browser without the WS support
        tends to diminish. Nevertheless, if the real-time functionality
        constitutes the application core functionality, there is a strong need
        for offering a fallback technology that every browser supports --
        usually represented by the HTTP long polling or streaming mechanism,
        described in <xref linkend="chap-http-requests" />.</para>
      </sect2>

      <sect2>
        <title>WebSocket API wrappers</title>

        <para>WebSockets is a powerful technology, yet there are many browsers
        which do not support it. In that case, when the real-time
        communication constitutes the core functionality, a fallback (i.e. an
        alternative technology used when the original is missing) must be
        defined to substitute the WebSockets. It might be Adobe Flash or the
        HTTP polling. It would be great not to have to define a fallback in
        every project again and again. Luckily, there are several API wrappers
        for this, doing this part of job for the developer
        automatically.</para>

        <para>The basic use case is obvious. Using the wrapper instead of the
        WS API itself guarantees the developer that a fallback is used when
        the application runs in an environment without WebSockets. The whole
        process of choosing the transport technology is transparent and not
        necessary to be specified. As examples, however not used in Talker
        application, the projects Socket.IO<footnote>
            <para>http://socket.io/</para>
          </footnote> and SockJS should be mentioned.<footnote>
            <para>https://github.com/sockjs/sockjs-client</para>
          </footnote></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Server-sent events<indexterm>
          <primary>Server-sent events</primary>
        </indexterm></title>

      <para>The Server-sent events (aka EventSource, from this point referred
      only as SSE) should in fact not be listed here but in the next section.
      It is a technology based on the HTTP streaming<indexterm>
          <primary>HTTP</primary>

          <secondary>streaming</secondary>
        </indexterm>, described in <xref linkend="chap-http-streaming" /> so
      it is not at the basic <quote>zero</quote> level. However, SSE are often
      compared to WebSockets so that the topic is introduced here. SSE have
      been standardized as part of the HTML5 standard.
      <citation>sse-api</citation> There is a very brief summary of an SSE API
      and its usage in this section.</para>

      <para>As any other web technology, an SSE connection must be initialized
      by a client. There is a JavaScript API providing event handlers, very
      similar to the WS API. An event stream is opened with a constructor,
      pointing to a resource on a server:</para>

      <para><programlisting>var eventSource = new EventSource("sse-example.php");</programlisting></para>

      <para>A script on the server,
      <computeroutput>sse-example.php</computeroutput> in our case, pushes the
      data to an opened HTTP response stream. What is important to get the SSE
      work, the <computeroutput>Content-Type</computeroutput> header must be
      set to the value <computeroutput>text/event-stream</computeroutput>. The
      data has to be organized in a form of <quote>paragraphs</quote>,
      separated by a blank line, where every paragraph stands for one message.
      Have a look at an example below:</para>

      <para><programlisting>data: This is one-line message

id: 123
event: myevent
data: Message of type "myevent" which consists of several lines
data: Another line of the event message</programlisting></para>

      <para>As shown above, every line in the message consists of a key and a
      value, separated by a colon, similar to the JSON format. When we need to
      transfer a multi-line message, we can repeat the key several times.
      <citation>sse-multiline</citation> Depending on the
      <computeroutput>event</computeroutput> entry
      (<computeroutput>myevent</computeroutput> in our example), the
      respective event handler is triggered in the JavaScript API. In this
      case, it would be the following event listener (if it has been attached
      in JavaScript before) logging the event to the console:</para>

      <programlisting>eventSource.addEventListener("myevent", function(e) {
    // process the event
    console.log(e);
}, false);</programlisting>

      <para>A connection is closed either by a client by calling
      <computeroutput>close</computeroutput> method on the
      <computeroutput>EventSource</computeroutput> object or by a server (when
      all data is sent). However, if a server closes the connection, a client
      attempts to reconnect to the same resource. So, a server cannot close
      the connection permanently.</para>

      <para>Server-sent events are often compared to WebSockets, though they
      are much less known. The support of both in the current web browsers is
      very similar. The only main difference is the lack of support of SSE in
      Internet Explorer 10, which finally provides the WebSocket API. Another
      difference is the fact that SSE, unlike WS, does not provide a real
      bidirectional stream. Only a server can publish new messages through an
      opened HTTP connection. A client has to push the data to the server via
      another (standard) HTTP requests. Finally, there is rather a big
      limitation in the message format. While WebSockets provide a real TCP
      connection any data can be transferred through (including binary
      streams), SSE is restricted to the textual data in the form of key/value
      pairs. So, the only compelling reason to use SSE when WebSockets exist
      is the fact that WS communication is not so matured. There are proxies
      and NATs (network address translation points) which do not respect the
      long-lived nature of WebSockets and close them after relatively short
      period of time (1 minute for example). Therefore, it comes in handy to
      know about the SSE when working with real-time applications in a web
      browser.</para>
    </sect1>

    <sect1>
      <title>Media streaming with a WebRTC technology<indexterm>
          <primary>WebRTC</primary>
        </indexterm></title>

      <para>Up to here, none of the technologies mentioned was fully suited as
      a complete solution for a web-browser-based media communication, such as
      video calling. Although WebSockets are the most advanced approach, it is
      only a low level API providing a TCP stream. On that account, the web
      browser developers, with Chromium developers in the vanguard, invented a
      WebRTC technology. It is an API linking up a user media API (webcam,
      microphone) with the streaming API for sending the multimedia from a
      browser to the other communication node.<footnote>
          <para>Apart from the video calling, the WebRTC provides an API for
          sending the files from one peer to another.</para>
        </footnote></para>

      <para>While WebSockets serve as an interconnection between a client (a
      web browser) and a dedicated server, which makes the technology suitable
      for the <quote>server-based</quote> protocols such as XMPP, WebRTC
      provides a real peer-to-peer connection<indexterm>
          <primary>peer-to-peer connection</primary>
        </indexterm>, directly between two web browsers. That makes WebRTC a
      perfect tool for implementing the direct media communication, such as
      the video calls.</para>

      <sect2>
        <title>Signaling<indexterm>
            <primary>WebRTC</primary>

            <secondary>Signaling</secondary>
          </indexterm></title>

        <para>In fact, a server has to mediate the <quote>meta data</quote> in
        WebRTC, such as initializing a connection or negotiating the available
        media capabilities (such as codecs). This level of communication,
        exchanging the information about the connection itself, is called
        <emphasis>signaling</emphasis><indexterm>
            <primary>signaling</primary>
          </indexterm>. WebRTC does not take care either about a layer the
        signaling data is transferred at, or the signaling protocol itself. It
        can be SIP, XMPP or any other, transferred via XMLHTTPRequest or
        WebSockets. What is important, signaling is not a part of a WebRTC
        API. The WebRTC connection itself then concerns only the peers, as
        shown in <xref linkend="fig-webrtc" />.
        <citation>webrtc-signaling</citation></para>

        <figure id="fig-webrtc">
          <title>WebRTC communication schema</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="img/webrtc.png" width="420pt" />
            </imageobject>
          </mediaobject>
        </figure>
      </sect2>

      <sect2>
        <title>WebRTC API</title>

        <para>WebRTC provides a very high level API abstracting the media
        device access, a network connection and the process of
        encoding/decoding the media streams from a programmer. Unfortunately,
        the WebRTC API is still in the phase of a draft and it has not been
        standardized yet. <citation>webrtc-rfc</citation> It means that
        JavaScript objects are prefixed by vendor prefixes, so that there is
        <computeroutput>webkitRTCPeerConnection</computeroutput> instead of
        <computeroutput>RTCPeerConnection</computeroutput> in Chromium.</para>

        <para>The core API object is a JavaScript object
        <computeroutput>RTCPeerConnection</computeroutput>. Creating one may
        look as follows (with a respective prefix):</para>

        <programlisting>var config =  {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]};
var pc = new RTCPeerConnection(config); // webkitRTCPeerConnection</programlisting>

        <para>Then, we can send all available ICE<indexterm>
            <primary>ICE</primary>
          </indexterm><footnote>
            <para>ICE stands for Interactive Connectivity Establishment</para>
          </footnote> candidates to the other peer, via a specified
        STUN<indexterm>
            <primary>STUN</primary>
          </indexterm> server. ICE candidate<indexterm>
            <primary>ICE candidate</primary>
          </indexterm> is basically a possible transport address for the media
        stream, later validated for the peer-to-peer connectivity.
        <citation>ice</citation> So, each possible connection address is sent
        via the previously created <computeroutput>pc</computeroutput> object.
        The process is still in the phase of negotiation, so the sending is up
        to a signaling service:</para>

        <programlisting>pc.onicecandidate = function (event) {
    // use existing signaling channel to send the candidate
    signalingChannel.send(JSON.stringify({ "candidate": event.candidate }));
};</programlisting>

        <para>In case the other side publishes its video stream, we set up a
        hook which handles it and shows it in a remote video element, stored
        in the <computeroutput>remoteView</computeroutput> JavaScript
        variable. <citation>webrtc-rfc</citation> In other words, the incoming
        URL is assigned to the <computeroutput>video</computeroutput> element
        as a source (<computeroutput>src</computeroutput>) attribute. The
        <computeroutput>src</computeroutput> attribute determines the media
        source bound to the element.
        <citation>definitive-guide-to-html5</citation></para>

        <programlisting>pc.onaddstream = function (event) {
    remoteView.src = URL.createObjectURL(event.stream);
};</programlisting>

        <para>Sending a media stream from the local browser to the other peer
        is similar. First, we capture the audio and video stream from the
        local multimedia devices. The result, multimedia stream, is passed as
        an argument to the function which adds it to the
        <computeroutput>RTCPeerConnection</computeroutput> object
        <computeroutput>pc</computeroutput>. Besides, there is a common habit
        to add the video of self to the page as well. It is handled by the
        <computeroutput>selfView</computeroutput> variable, containing a
        reference to another video element on the page. The example below
        represents the described situation:</para>

        <programlisting>navigator.getUserMedia({ "audio": true, "video": true }, function (stream) {
    selfView.src = URL.createObjectURL(stream);
    pc.addStream(stream);
});</programlisting>

        <para>Closing the connection is rather straightforward -- by invoking
        the <computeroutput>close</computeroutput> method on the
        <computeroutput>RTCPeerConnection</computeroutput> object, which has
        been instantiated before as
        <computeroutput>pc</computeroutput>.</para>
      </sect2>

      <sect2>
        <title>WebRTC in various environments</title>

        <para>WebRTC is truly a new technology, not yet adopted by many web
        browsers. And for those which support it, the implementation may
        differ since the standard has not been fully defined and finished yet.
        Chromium browser (i.e. Chrome and Chromium) developers were the first
        to add WebRTC API to their products -- in 2012. At the beginning of
        2013, WebRTC API was added also to the newest Firefox builds so that
        Chrome and Firefox can <quote>talk</quote> to each other.<footnote>
            <para>Note that in current Firefox version (22, nightly build by
            the time this thesis part is created), the user has to enable
            <computeroutput>media.peerconnection.enabled</computeroutput>
            field in <computeroutput>about:config</computeroutput> to get
            WebRTC run.</para>
          </footnote> <citation>webrtc-interop</citation> Opera browser also
        takes part in this initiative, yet no existing official claim of
        support has been released. All mentioned browsers used the same
        back-end implementation, hosted at <ulink
        url="http://www.webrtc.org">http://www.webrtc.org</ulink>. In theory,
        this back-end implementation (written in C++) can be built into any
        application to support WebRTC, not only a web browser.</para>

        <para>For the web browsers which do not support WebRTC yet, several
        attempts have been made to add its functionality via browser plugins.
        It can be useful as a temporary improvement for the experienced users
        but one can never rely on the user having the plugin installed. The
        library providing WebRTC functionality for Safari, Opera, IE and older
        versions of Firefox is called webrtc4all.
        <citation>webrtc4all</citation> However, it is still a proprietary
        solution, adding another prefix (<computeroutput>w4a</computeroutput>)
        to the world of WebRTC JavaScript APIs.</para>

        <para>There are also other parties which implement WebRTC in their own
        way, keeping to the API, more or less. One of such initiatives is
        Ericsson Browser (called just Browser), which claimed to be the first
        browser to implement WebRTC. Ericsson Browser uses a different
        back-end implementation but it tries to be in accordance with the
        official API. <citation>webrtc-ericsson</citation></para>

        <para>Microsoft came up with a different approach. Even though
        Internet Explorer does not support WebRTC, Microsoft invented their
        own API standard proposal. <citation>webrtc-ms</citation> It differs
        from the <quote>official</quote> API mainly in the extended
        possibilities to control more aspects of WebRTC communication,
        including low level <quote>transport</quote> layers. Since none of the
        standards has been finished yet, it is possible (and probable) that
        the final API definition will end up somewhere in between.</para>

        <para>One of the logical reasons why Microsoft does want to intervene
        in the process of defining WebRTC API as much as possible is
        Skype<indexterm>
            <primary>Skype</primary>
          </indexterm>. Skype has been bought by Microsoft some time ago and,
        as everything nowadays, is planned to be available in the web browser.
        Microsoft seems to bet on WebRTC technology.
        <citation>webrtc-skype</citation> As a pleasant side-effect of Skype
        working on top of WebRTC, it would be finally possible to play along
        with Skype with other technologies. Of course, the technology barrier
        is the smaller one compared to licences and legal regulations, but it
        is another story.</para>
      </sect2>
    </sect1>

    <sect1 id="chap-high-level-rtc">
      <title>Other RTC solutions</title>

      <para>Actually, there are several other, mostly higher-level solutions
      for achieving the bidirectional (and thus real-time) communication in a
      web browser. Some of them use the HTTP requests described above (such as
      Bayeux), some of them are based on WebSockets (OpenTok) or even WebRTC
      (OpenTok), and several of them are built completely independently,
      installed as web browser plugins and thus behaving as separate runtime
      platforms (Adobe Flash, Google Talk). And, to be precise, some of the
      frameworks are built on top of the others, for example OpenTok uses
      Adobe Flash in some cases. See the sections below to understand each of
      the technologies.</para>

      <sect2>
        <title>Adobe Flash<indexterm>
            <primary>Flash</primary>
          </indexterm> and Microsoft Silverlight</title>

        <para>Among all, one of the most widespread technologies is Adobe
        Flash.<footnote>
            <para>http://www.adobe.com/software/flash/about/</para>
          </footnote> Apart from the possibility to establish a bidirectional
        persistent TCP connection, Flash allows the developer to create almost
        any graphics, animations and user interface with nearly no
        limits.</para>

        <para>Nevertheless, the disadvantages of Flash are significant. First,
        Flash is not a native part of any web browser. Until recently, it had
        to be installed manually as a plugin. Now, it is bundled and shipped
        with the Chromium-based browsers (Chrome, Chromium), but it is still
        an external plugin. <citation>flash-bundled-with-chrome</citation>
        Another drawback of Flash is the lack of support on mobile devices.
        Apple has been clear about it: iPhones and iPads have never supported
        Flash technology and it is not likely to change in the future.
        <citation>iphone-flash-support</citation> Android devices supported
        Flash at first, but later Adobe quit Google Play.
        <citation>android-flash-support</citation></para>

        <para>There are many other technologies similar to Adobe Flash, but
        they all suffer the same pain. Because they are installed as
        proprietary plugins, a developer can never be sure the application
        will run in any environment. This concerns the technologies as
        Microsoft Silverlight<indexterm>
            <primary>Silverlight</primary>
          </indexterm><footnote>
            <para>http://www.microsoft.com/silverlight/</para>
          </footnote> or Adobe AIR<indexterm>
            <primary>AIR</primary>
          </indexterm><footnote>
            <para>http://www.adobe.com/products/air.html</para>
          </footnote> (even though AIR has been intended to be
        browser-independent platform).</para>

        <para>To sum it up, Adobe Flash is often used as a fallback for older
        browsers, running on non-mobile devices, which do not support WebRTC
        yet. It has been used as a fallback for the video calls in Talker
        application. However, creating a new application based on Flash (as a
        <emphasis>primary</emphasis> technology) in 2013 is not a good
        idea.</para>
      </sect2>

      <sect2 id="chap-opentok">
        <title>OpenTok video call library</title>

        <para>OpenTok is a high-level video call platform for building
        real-time communication applications in a web browser. It allows the
        developer to easily set up a video call session, using an OpenTok
        server as a mediator. OpenTok is available as a free library for
        one-to-one calls. If more users were participating in one call, a
        payed subscription would have to be bought.
        <citation>opentok-pricing</citation></para>

        <para>From the technical point of view, there are two versions of the
        client-side OpenTok library. The first one is built on top of Adobe
        Flash, using it for establishing a connection with the OpenTok server
        and handling the media stream. The other one uses WebRTC (and it is
        therefore limited to the browsers which support it). Unfortunately,
        the two versions are not mutually compatible so it is impossible for
        one user to have a Flash version and for the other to use WebRTC when
        communicating together.</para>

        <para>Each OpenTok session is identified by a session ID and every
        user who wants to join the session must hold a token generated for the
        session. Therefore, OpenTok contains a server-side library (SDK) for
        issuing and managing the session IDs and tokens, available for the
        most commonly used server-side languages.
        <citation>opentok-server-side-lib</citation></para>

        <para>OpenTok library is the tool that has been used for implementing
        video calls in the Talker application, hence the library API usage is
        described separately in <xref linkend="chap-video-calling" />. The
        main advantage of OpenTok is a low entry barrier and a simple API that
        can be used out of the box. On the other hand, it is still a
        proprietary tool and every application built with OpenTok heavily
        relies on the third party service. Nevertheless, we have not
        experienced any serious problems during almost one year running
        OpenTok in Celebrio.</para>
      </sect2>

      <sect2>
        <title>Bayeux protocol<indexterm>
            <primary>Bayeux</primary>
          </indexterm></title>

        <para>Bayeux is one of the higher level protocols designed
        specifically for the bidirectional communication between a web browser
        and a server, primarily intended to work on top of HTTP. The idea of
        communication is almost the same as in case of HTTP long polling. To
        transfer the messages from a server to a client, the server holds the
        request and responds only when there is an available message. Sending
        the data from a client to a server is straightforward, an ordinary
        HTTP request is sufficient.</para>

        <para>Apart from HTTP requests, Bayeux defines the structure for the
        transmitted data, contained in the body of HTTP requests/responses.
        Each message has to be in form of JSON, containing structured data
        such as a channel name, a client ID and of course the transmitted data
        itself. <citation>bayeux</citation> Although Bayeux provides an
        interesting way to communicate, it has not been used in this thesis.
        The main reason for choosing XMPP is its better interoperability with
        other existing services and ability to easily communicate with the
        clients not running in a web browser.</para>
      </sect2>

      <sect2>
        <title>SignalR framework<indexterm>
            <primary>SignalR</primary>
          </indexterm></title>

        <para>SignalR is a framework taking care of both a client (a web
        browser) and a server side of the application. SignalR is designed for
        the .NET platform on a server side, so the web application should be
        powered by the ASP.NET framework. SignalR abstracts the user from
        finding out which technology the web browser, in which an application
        runs, supports. Instead, SignalR provides an API for sending the
        messages and handling the incoming ones. Internally, it uses
        WebSockets for establishing the connection. When the WebSocket API is
        not available (for example in IE9, which is funny considering that
        SignalR is Microsoft-platform-based technology), it tries Server Sent
        Events and then falls back on the long polling technique.
        <citation>signalr</citation> To take it short, SignalR provides an
        envelope for the client-side WebSockets and HTTP long polling
        techniques, with ASP.NET API for handling the messages on a
        server.</para>
      </sect2>

      <sect2 id="chap-google-tools">
        <title>Real-time communication tools from Google<indexterm>
            <primary>Google</primary>
          </indexterm></title>

        <para>There are three topics briefly mentioned in this section, all
        developed by Google -- Channel API, the Google Talk chat service and
        Google Hangouts API, all of which serve as RTC tools or even complete
        applications.</para>

        <para>The first one, Google Channel API<indexterm>
            <primary>Channel API</primary>
          </indexterm>, is a tool for creating persistent connections between
        a browser-based client and a server. It simply wraps common Comet
        techniques (i.e. HTTP long polling or streaming) with convenient
        methods for binding handlers to incoming events, usually messages.
        Nevertheless, the Channel API is part of Google App Engine and it is
        intended to be used only within the web applications built on it.
        Although it is possible to use only the client side of the Channel API
        in a custom web application, using only a half of the tool does not
        seem to be very helpful.</para>

        <para>The other tool (more precisely standalone application) from
        Google is a chat service. It became natural part of Gmail, serving for
        quick and more informal messages than e-mail. It is a service built on
        XMPP protocol, not dissimilar to Talker application. Thanks to using
        XMPP, it is possible to connect with a Gmail account from various IM
        clients such as Pidgin or Miranda. Recently, Google added the support
        for video calls in a web browser -- originally powered by a browser
        plugin that had to be installed, now switching to WebRTC.</para>

        <para>The last topic in this section is about Hangouts API. Hangouts
        is a platform for creating group video chat, running within a web
        application. Although Hangouts offer neat user experience, they can
        only be customised to a small extent. In other words, it is possible
        to add a Hangout to an arbitrary web application but its look and feel
        cannot be altered. This is an insurmountable problem for Celebrio
        Talker since it must strictly keep up with the user interface of
        Celebrio, the system it is built into.</para>

        <para>Recently (on May 16, 2013), Google announced transforming
        <emphasis>Hangouts</emphasis><indexterm>
            <primary>Hangouts</primary>
          </indexterm> to a complex real-time communication platform,
        incorporating the Google Talk service, previously mentioned
        <quote>old</quote> Hangouts and Google+ Messenger chat application.
        <citation>new-hangouts</citation> The new Hangouts platform is
        currently available either as a standalone Android/iOS application or
        an extension for Google Chrome, so it is not purely a technology of a
        web browser. On the other hand, the browser plugin allows the user to
        use new Hangouts at any web page, offering very simple user interface
        for both a text chat or a video call.</para>

        <para>The new platform will preserve XMPP as an underlying protocol,
        so it will basically extend the Google Talk service. However, Google
        declared one important constraint. Their XMPP service will no longer
        support a server-to-server communication.
        <citation>new-hangouts</citation> More information about
        interoperability problems is to be found in <xref
        linkend="chap-interoperability-problems" />.</para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="chap-xmpp">
    <title>Extensible Messaging and Presence Protocol</title>

    <para>Extensible Messaging and Presence Protocol (XMPP) technologies were
    invented by Jeremie Miller in 1998.
    <citation>xmpp-the-definitive-guide</citation> It is one of the most
    widespread technologies for instant messaging (IM),<footnote>
        <para>Actually, the IM client or even the technology itself is
        sometimes called <quote>Instant Messenger</quote>. This term is
        registered as a trademark by AOL company.
        <citation>aol-trademarks</citation></para>
      </footnote> i.e. exchanging the text or multimedia data between several
    endpoints. The <quote>native</quote> implementation of XMPP works right on
    top of the TCP protocol: XMPP endpoint (called client as it represents the
    first actor in the client-server architecture) opens a long-lived TCP
    connection. Then, both the client and the server negotiate and open XML
    streams, so there is one stream in each direction.
    <citation>xmpp-the-definitive-guide</citation> When the connection is
    established, both the client and the server can push any changes as XML
    elements to the stream and the other side obtains them immediately. The
    usual XMPP clients are standalone applications able to open a TCP
    connection and listen to the stream opened by the server.</para>

    <para>XMPP stands for communication protocol handling not only sending and
    receiving the messages, but also presence notification, contact list
    (roster) management and others. The architecture is distributed and
    decentralized. There is no central or top level XMPP server. Anyone can
    run an XMPP server, very similarly as an HTTP or FTP server.
    Identification and recognition on the network is also similar -- XMPP
    relies on Domain Name System (DNS), so that every server is identified via
    string domain name with arbitrary subdomain level (e.g. xmpp.example.com
    or just example.org).
    <citation>xmpp-the-definitive-guide</citation></para>

    <para>The user name, called Jabber ID (or shortly as JID), has the same
    structure as an e-mail address so the user name is followed by
    <computeroutput>@</computeroutput> and the server domain name. This rule
    also guarantees that every XMPP user is registered on a certain server. If
    there is a message or notification for the particular user, her
    <quote>home</quote> server is looked up first, the message is transferred
    to that server and then, the respective server (that the user belongs to)
    is responsible for delivering the message to the user or saving it until
    she logs in. Therefore, two possible connection types take place in XMPP.
    Client-to-server communication is the first one, when the clients can talk
    only to their <quote>home</quote> server. Then, server-to-server
    communication is designed for delivering the messages to users at
    different domains. When two servers are exchanging any data, a direct
    connection to the target server has been established. This approach is
    dissimilar to the way SMTP servers exchange e-mail messages. It helps to
    prevent address spoofing or spamming.
    <citation>xmpp-the-definitive-guide</citation></para>

    <para>XMPP has been chosen as the communication protocol for this thesis
    topic -- Talker application. XMPP has been verified by big companies such
    as Google or Facebook. In addition, the openness of the protocol allows a
    very easy connection to existing wide communication networks, using their
    server infrastructure, client software and an existing user base.</para>

    <sect1 id="chap-xmpp-stanzas">
      <title>XML Stanzas -- XMPP building blocks</title>

      <para>As mentioned in the introduction to this chapter, when an XMPP
      connection is established, two streams are opened and both the client
      and the server can send any XML elements at any time. The meanings of
      various pieces of XML are described in this section.</para>

      <para>There are three basic XML elements that every XMPP communication
      consists of. Those are
      <computeroutput>&lt;message/&gt;</computeroutput>,
      <computeroutput>&lt;presence/&gt;</computeroutput> and
      <computeroutput>&lt;iq/&gt;</computeroutput> (which stands for an
      Info/Query), altogether called
      <computeroutput>Stanza</computeroutput><indexterm>
          <primary>stanza</primary>
        </indexterm>s. <citation>xmpp-the-definitive-guide</citation> Each
      stanza element usually contains several attributes which specify the
      exact meaning of it. An actual content is usually placed in the element
      body. An example message<indexterm>
          <primary>XMPP</primary>

          <secondary>message</secondary>
        </indexterm> stanza looks as follows:</para>

      <programlisting>&lt;message from="pavel.smolka@celebrio.cz/talker"
         to="tomas.pitner@celebrio.cz"
         type="chat"&gt;
    &lt;body&gt;Hello, how are you?&lt;/body&gt;
&lt;/message&gt;</programlisting>

      <para>The attributes <computeroutput>from</computeroutput> and
      <computeroutput>to</computeroutput> identify a sender and a recipient of
      the message. Actually, the value set to the
      <computeroutput>from</computeroutput> attribute does not matter at all,
      it can even be left out. The <quote>home</quote> XMPP server the sender
      is registered at (it would be the one running at
      <computeroutput>celebrio.cz</computeroutput>, in the previous example)
      has to set the from attribute according to the real user name and the
      domain name. This is one of the interesting defensive mechanisms
      distinguishing XMPP from other communication protocols such as
      SMTP.</para>

      <para>You might have noticed that the
      <computeroutput>from</computeroutput> field does not contain only an
      XMPP address. There is a <emphasis>resource</emphasis><indexterm>
          <primary>XMPP</primary>

          <secondary>resource</secondary>
        </indexterm> identifier following the domain name. Since it is
      possible to connect multiple times with the same user name, the resource
      makes a difference between the sessions of the same user. In addition,
      it is useful information for other peers the user might communicate
      with. It is usual to set the resource field according to a place the
      user logs from or a device she uses.</para>

      <para>Receiving a message stanza is not acknowledged by the recipient so
      the sender has no information whether it has been delivered successfully
      or not. On the contrary, an IQ stanza <indexterm>
          <primary>XMPP</primary>

          <secondary>IQ</secondary>
        </indexterm> can be used in case the sender requires an answer -- it
      usually constitutes a <emphasis>query</emphasis>. The best example is
      obtaining a contact list -- in XMPP terms called <emphasis>a
      roster</emphasis><indexterm>
          <primary>XMPP</primary>

          <secondary>roster</secondary>
        </indexterm>:</para>

      <programlisting>&lt;iq id="123456789" type="get"&gt;
  &lt;query xmlns="<emphasis>jabber:iq:roster</emphasis>"/&gt;
&lt;/iq&gt;</programlisting>

      <para>As an answer, a server sends the result as another IQ stanza
      (notice that the <computeroutput>id</computeroutput> attribute remains
      the same while the <computeroutput>type</computeroutput> attribute
      changed): <citation>xmpp-the-definitive-guide</citation></para>

      <programlisting>&lt;iq id="123456789" type="result"&gt;
  &lt;query xmlns="jabber:iq:roster"&gt;
    &lt;item jid="pavel@celebrio.cz"/&gt;
    &lt;item jid="tomas@celebrio.cz"/&gt;
    &lt;item jid="marek@celebrio.cz"/&gt;
  &lt;/query&gt;
&lt;/iq&gt;</programlisting>

      <sect2 id="chap-xmpp-subscriptions">
        <title>Subscription mechanism</title>

        <para>The third letter of the abbreviation XMPP stands for the
        <emphasis>presence</emphasis><indexterm>
            <primary>XMPP</primary>

            <secondary>presence</secondary>
          </indexterm>, in practice represented by sending
        <computeroutput>presence</computeroutput> stanzas. It is one of the
        important signs of a real-time communication (not only in XMPP but
        overall) that the peers can see each other's presence -- whether the
        other side is online, alternatively whether it is available or busy.
        Even though such functionality is generally desired, it might slip to
        a huge privacy breach when anyone could see your presence
        status.</para>

        <para>XMPP solves the potential privacy problem with a
        subscription<indexterm>
            <primary>XMPP</primary>

            <secondary>subscriptions</secondary>
          </indexterm> mechanism. Each user has full control over the peers
        who can monitor her online status. If anyone else wants to track a
        presence status, a subscription request must be sent. When received,
        the user decides whether a permission will be granted or not.
        Unfortunately, the subscription request can be blocked by the
        respective <quote>home</quote> XMPP server of the user we try to
        reach. To be specific: there are two widely used XMPP providers --
        <computeroutput>jappix.com</computeroutput> and
        <computeroutput>gmail.com</computeroutput>. If a user of the former
        sends a subscription to another user registered at the latter, it is
        not guaranteed it will be delivered (actually, it is not, see <xref
        linkend="chap-interoperability-problems" /> for details). It is one of
        the drawbacks of an opened protocol that one can never be sure that
        the other party co-operates.</para>
      </sect2>
    </sect1>

    <sect1 id="chap-bosh">
      <title>XMPP over BOSH</title>

      <para>Having described XMPP as a communication protocol over TCP, it
      might be unclear how it is related to the topic of this thesis. XMPP is
      a nice and mature technology and it would be nice to use it in a web
      browser, but it does not support communication over HTTP. Fortunately,
      XMPP offers many extensions (indeed, the first letter X stands for
      <quote>extensible</quote>) providing an additional functionality. In
      fact, we speak about XMPP <emphasis>Extension Protocols</emphasis> and
      thus they are called XEPs<indexterm>
          <primary>XEP</primary>
        </indexterm>.</para>

      <para>This section briefly describes one of the XEP extensions called
      BOSH<indexterm>
          <primary>BOSH</primary>
        </indexterm> (XEP-0124), designed for transferring XMPP over
      HTTP.<footnote>
          <para>In fact, there are two more XEPs related to HTTP. First of
          them, XEP-0025: Jabber HTTP Polling, has been replaced by BOSH. It
          is obsolete and recommended not to be used any longer.
          <citation>xep-0025</citation> The other one is XEP-0206: XMPP Over
          BOSH. It is currently used as a standard but it constitutes just a
          supplement for BOSH (XEP-0124). XEP-0206 describes mainly the
          session creation and an authentication process in BOSH.
          <citation>xep-0206</citation></para>
        </footnote> <citation>xep-0124</citation> The idea behind this
      extension is very simple: BOSH uses an HTTP long polling technique
      (described in <xref linkend="chap-http-long-polling" />) to imitate a
      bidirectional TCP communication necessary for XMPP. We can imagine BOSH
      (itself a protocol) as a middle layer protocol or a wrapper protocol
      between HTTP (only capable of sending requests from a client to a
      server) and XMPP (understanding only the XML stanzas). BOSH requests and
      responses are subset of all conceivable HTTP requests or responses (they
      include all HTTP features such as an HTTP method in a request or a
      status code in a response). The constraint defined by BOSH protocol
      restricts the body part to have a specific structure.</para>

      <para>Each BOSH request or response body should be valid XML, which
      wraps up XMPP stanzas in a special
      <computeroutput>&lt;body/&gt;</computeroutput> element. For the purposes
      of the protocol itself, it is also possible to send just the
      <computeroutput>body</computeroutput> element with no child (XMPP) nodes
      -- for example when starting a session or reporting an error. So, the
      XMPP part of the communication is clearly separated from the BOSH part:
      the former is represented by payload elements inside the
      <computeroutput>body</computeroutput>, the latter consists of
      <computeroutput>body</computeroutput> attributes. Have a look at an
      example of a BOSH request: <citation>xep-0124</citation><programlisting>POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 188

&lt;body rid='1249243562'
      sid='SomeSID'
      xmlns='http://jabber.org/protocol/httpbind'&gt;
  &lt;message to='tomp@example.com'
           xmlns='jabber:client'&gt;
    &lt;body&gt;Good morning!&lt;/body&gt;
  &lt;/message&gt;
  &lt;message to='pavel@example.com'
           xmlns='jabber:client'&gt;
    &lt;body&gt;Hey, what&amp;apos;s up?&lt;/body&gt;
  &lt;/message&gt;
&lt;/body&gt;</programlisting> As you can see, the request header is an
      ordinary HTTP header. So much for the HTTP part. The request body
      consists of a <computeroutput>body</computeroutput> element, which
      represents a BOSH layer, along with the element attributes (plus the
      namespace). <computeroutput>sid</computeroutput> attribute represents a
      <emphasis>session</emphasis> ID, identifying the connection. It should
      not be mutated during one session. The other one,
      <computeroutput>rid</computeroutput>, stands for an ID of the
      <emphasis>request</emphasis> and it gets incremented with each request.
      Ultimately, the child nodes of the <computeroutput>body</computeroutput>
      element represent the XMPP stanzas, which would be two message stanzas
      in this case. It is obvious that multiple XMPP stanzas can be
      transmitted via a single BOSH request.</para>

      <para>Those <computeroutput>sid</computeroutput> and
      <computeroutput>rid</computeroutput> properties are rather important in
      BOSH. The security is ensured just by that pair of strings in BOSH,
      because of the stateless nature of HTTP. If an attacker stole
      <computeroutput>sid</computeroutput> and
      <computeroutput>rid</computeroutput>, he could communicate with a server
      on behalf of the actual user. On the other hand, there is one big
      advantage. A connection can be established and handed over from one
      point to another. For example, a web server can initiate a connection
      (carry out a handshake) and then only
      <computeroutput>sid</computeroutput> and
      <computeroutput>rid</computeroutput> are passed to a client (a web
      browser), which can continue communicating. This approach is used in the
      Talker application so the user credentials (JID and a password) are not
      sent to a browser at all.</para>

      <para>BOSH protocol is an important part of the Talker application
      implemented as a programming part of this thesis. Despite bearing the
      disadvantages of an HTTP bidirectional communication, as described
      before, it is the only reliable technology nowadays. There are several
      mature client-side libraries using BOSH (such as Strophe.js we used) and
      it is also easy to install, configure and run a BOSH extension on the
      server side. An HTTP server usually hands over a BOSH HTTP request to an
      XMPP server with a relevant module enabled, as described in
      <citation>setting-up-bosh</citation> and depicted in <xref
      linkend="fig-xmpp-server-plugins" />. However, the server side XMPP is
      not the topic of this thesis so it is not further discussed.</para>
    </sect1>

    <sect1 id="chap-xmpp-ws">
      <title>XMPP over WebSockets</title>

      <para>Since there is a possibility to transmit arbitrary data from a web
      browser application to a server via WebSockets, it could be handy to
      transfer XMPP stanzas using WS as well. Using WebSockets saves a
      considerable amount of overhead and fixes several issues that can happen
      with BOSH (for example unreliability of HTTP). It generally works, yet
      the programmer should be wary of several pitfalls that WebSockets bring.
      First, a server side must accept a WebSockets connection. Usually, XMPP
      servers do provide such functionality through addons or
      modules.<footnote>
          <para>Additional module for a Prosody server has been used as well
          when running the Talker application. The process of the installation
          includes downloading the module, adding it to the path that Prosody
          searches for modules. Then, it must be enabled in a configuration
          file. Moreover, <computeroutput>luajit</computeroutput> and
          <computeroutput>liblua5.1-bitop0</computeroutput> packages had to be
          downloaded for the module to work correctly (assuming Debian/Ubuntu
          on the server side).</para>
        </footnote> Provided that a WebSocket extension to the XMPP server is
      running on localhost, using WS to connect to the server is as simple as
      follows:</para>

      <programlisting>var ws = new WebSocket("ws://localhost:5280/xmpp-websocket/", "xmpp");
// XMPP handshake takes place here, omitting in the example
ws.send(
 "&lt;message to='lasaris@example.com' xmlns='jabber:client'&gt; \
    &lt;body&gt;Hello, lab!&lt;/body&gt; \
  &lt;/message&gt;"
);</programlisting>

      <para>Probably the most important difference compared to BOSH is that
      every WebSocket message (i.e. one chunk of incoming or outcoming
      communication -- can be compared to BOSH request) can contain only one
      XMPP stanza. <citation>xmpp-over-websockets</citation> It means that a
      client or a server cannot send more XMPP messages packed together, even
      if they are available by the time a WS message is sent.</para>

      <para>The main drawback of using XMPP over WebSockets is still partial
      lack of support both in the web browsers (which includes WS support
      itself and the JavaScript XMPP libraries) and on the XMPP servers.
      Nevertheless, there is a huge trend of implementing it at all
      sides.<footnote>
          <para>You might want to have a look at some of the current
          discussions concerning client-side (i.e. JavaScript)
          libraries:</para>

          <para><ulink
          url="https://github.com/metajack/strophejs/issues/68">https://github.com/metajack/strophejs/issues/68</ulink></para>

          <para><ulink
          url="https://github.com/metajack/strophejs/pull/95">https://github.com/metajack/strophejs/pull/95</ulink></para>

          <para><ulink
          url="http://stackoverflow.com/questions/1850162/">http://stackoverflow.com/questions/1850162/</ulink></para>
        </footnote> Both BOSH and WS require additional plugins to be
      installed on a server since they are not part of XMPP. The plugins
      basically handle a connection (or a request, in case of BOSH) and hand
      over a pure XMPP message to the core XMPP server. In case of BOSH, the
      request can be sent to the plugin directly when the port is specified,
      or redirected by default HTTP server. The schema of transitions between
      the users at one side (using either WS, direct BOSH with specified
      plugin port or BOSH request to default HTTP port) and a server side is
      depicted in <xref linkend="fig-xmpp-server-plugins" />.</para>

      <figure id="fig-xmpp-server-plugins">
        <title>Communicating to XMPP server with WS and BOSH plugins</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="vp/bosh-ws-xmpp.pdf" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect1>

    <sect1>
      <title>Jingle -- XMPP media extension<indexterm>
          <primary>XEP</primary>
        </indexterm></title>

      <para>Not only can XMPP send the text messages but it also supports
      transferring various multimedia streams. Audio and video above all, yet
      it is also possible to send raw binary files. All the functionality
      related to those <quote>advanced</quote> transfers is being managed by
      an XMPP protocol extension (XEP) called Jingle<indexterm>
          <primary>Jingle</primary>
        </indexterm>. According to the protocol extension, the two parties
      negotiate a data stream using the standard IQ stanzas (described in
      <xref linkend="chap-xmpp-stanzas" />). Then, a stream is established
      according to the prearranged entries.
      <citation>xep-0166</citation></para>

      <para>Although Jingle is relatively old and mature XMPP extension, it
      has not been used in the web browsers for a long time. Web browsers had
      not supported multimedia transfers due to the troublesome bidirectional
      communication and a difficult access to multimedia devices (a microphone
      and a webcam). Ergo, Jingle has not been used in the Talker application
      either -- the main reason for not using Jingle in the Talker application
      is the lack of JavaScript libraries supporting it. There is just an
      unofficial Strophe.js<indexterm>
          <primary>Strophe.js</primary>
        </indexterm> plugin for Jingle, published by Michael Weibel, not very
      well maintained and relying on the WebRTC technology<indexterm>
          <primary>WebRTC</primary>
        </indexterm>.<footnote>
          <para>See <ulink
          url="http://candy-chat.github.com/candy-webrtc/">http://candy-chat.github.com/candy-webrtc/</ulink>
          and <ulink
          url="https://github.com/mweibel/strophejs-plugins/tree/jingle">https://github.com/mweibel/strophejs-plugins/tree/jingle</ulink>
          for the references.</para>
        </footnote> Therefore, Jingle is not described further in this thesis,
      it is mentioned here just as an option for the future.</para>

      <para>Nevertheless, C/C++ Jingle libraries seem to be rather mature and
      ready to be used in the desktop client applications. Above all, there is
      a library developed by Google called libjingle<indexterm>
          <primary>libjingle</primary>
        </indexterm>, supporting multi-user audio/video/file transfers.
      <citation>libjingle</citation> Google seems to believe that Jingle is
      the right protocol for developing a multimedia client that can be used
      by everyone. They even sidelined the original Google Talk VOIP protocol
      and switched to Jingle as their <quote>primary signalling protocol for
      voice calls</quote>, in Gmail, iGoogle and Orkut.
      <citation>jingle-is-the-future</citation></para>
    </sect1>

    <sect1 id="chap-interoperability-problems">
      <title>Interoperability problems</title>

      <para>Google Talk has been the biggest XMPP provider for a long time.
      Smaller XMPP networks, including Celebrio, took an advantage of the
      distributed environment and the interoperability within various XMPP
      domains. It seems, however, that Google starts to prevent the users
      registered at other servers from contacting Google users. More
      precisely, the subscription requests (described in <xref
      linkend="chap-xmpp-subscriptions" />) from other domains are not
      delivered to Google users. <citation>google-closing-xmpp</citation> It
      is very unexpected and unpleasant for all involved -- smaller XMPP
      providers, their users and for the Google users, too. Google confirmed
      that throwing the subscription requests away is an attempt to reduce the
      amount of spam delivered to Google users.
      <citation>spammy-invites</citation></para>

      <para>If Google closes its network for the people from other domains, it
      will be the second huge social network, along with Facebook, which does
      provide XMPP to its users but does not allow them to fully collaborate
      with everyone else. Unlike Facebook<indexterm>
          <primary>Facebook</primary>
        </indexterm>, Google users can still send the subscription requests
      and therefore initiate the connection (in the long-term meaning), but
      this option can be disabled in the future, too.</para>

      <para>Fortunately, severals weeks later, Google announced that the
      alleged spam problems are gone and the XMPP network is opened again.
      <citation>spammy-invites-update</citation> Hence, the users having their
      accounts registered at the external XMPP providers can send invites
      (subscription requests) to Google users without problems.</para>

      <para>Yet another turn came just a few days before this thesis is
      submitted. Google announced the Hangouts<indexterm>
          <primary>Hangouts</primary>
        </indexterm> service to be transformed into a brand new product, as
      described in <xref linkend="chap-google-tools" />. However, it will not
      be further possible to communicate to Google users from external XMPP
      services, similarly as in the time period described in the previous
      paragraphs. Thereby, it will not be possible (according to the latest
      Google statements) to interconnect a Hangouts account with other XMPP
      service providers, such as <computeroutput>jabber.org</computeroutput>
      or <computeroutput>jappix.com</computeroutput>. A possibility to log in
      to a new Hangouts account from a custom XMPP client, i.e. the
      client-to-server communication, will be preserved.
      <citation>new-hangouts</citation> Google justifies this restriction by
      claiming that most of the messages coming to Google XMPP servers from
      external XMPP providers is spam. Unfortunately, no data nor statistics
      on this topic have been released so far.</para>
    </sect1>
  </chapter>

  <chapter id="chap-xmpp-in-javascript">
    <title>JavaScript XMPP client</title>

    <para>In this chapter, the two previous topics are connected together. The
    possibilities of a bidirectional communication, necessary for receiving
    messages in real-time, were mentioned in <xref linkend="chap-rtc" />. In
    simple terms, such techniques (HTTP long polling, WebSockets, ...) stand
    for the <quote>transport</quote> layer of an application, handling a
    low-level connection and transferring the messages from a server to a
    client and vice versa. Above this layer, there is a <quote>real
    communication protocol</quote> definition, which would be the XMPP in our
    case. It does not make any sense to divide the protocols according to the
    OSI Model<indexterm>
        <primary>OSI Model</primary>
      </indexterm> (ISO/IEC 7498-1) since everything above HTTP (including
    HTTP itself) takes place at the 7<superscript>th</superscript>
    (application) layer. In <xref linkend="fig-isoosi" />, the communication
    between layers is depicted for the case of an application initializing a
    Jingle multimedia stream (XEP extension) over XMPP, using the BOSH
    mechanism for sending and receiving messages via HTTP. All the protocols
    have been described (or at least mentioned) previously. Although
    XMLHTTPRequest is an API rather than a protocol, its usage should be shown
    as well.</para>

    <figure id="fig-isoosi">
      <title>Complexity of the communication protocols at application
      layer</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="vp/isoosi.pdf" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>It is neither simple nor easy to take care of such a wide range of
    protocols in the application, handling the communication correctly at all
    levels. Fortunately, there are several existing libraries serving the
    lower level protocols. Specifically, most of them would conceal HTTP
    requests as well as BOSH and simplifying the XMPP layer.</para>

    <para>One of the JavaScript libraries, used when implementing the Talker
    application, called <emphasis>Strophe.js</emphasis>, is described in this
    chapter.</para>

    <para>There are also other libraries for creating an XMPP client in a web
    browser, for example JSJaC. However, JSJaC is not as popular (and thus
    verified) as Strophe.js and has not been used in Talker application. It is
    only mentioned as another option. It would be also possible to handle the
    whole XMPP/BOSH/HTTP stack manually and parse XML with some other
    tool.</para>

    <para>Throughout this thesis, we assume the application runs in a web
    browser. After all, the thesis title has a <quote>web browser</quote> in
    it. Therefore, mostly JavaScript libraries and tools for building a client
    application within a web browser are mentioned in this chapter. Yet, it is
    certainly possible to implement an XMPP client on the server side or as an
    independent desktop application. At the end of this chapter, some
    server-side implementations are also mentioned due to the security
    reasons. See <xref linkend="chap-server-side-xmpp-client" /> for
    details.</para>

    <sect1>
      <title>Strophe.js -- JavaScript XMPP library<indexterm>
          <primary>Strophe.js</primary>
        </indexterm></title>

      <para>Strophe.js<footnote>
          <para>Strophe.js is sometimes referred only as
          <quote>Strophe</quote>. However, Strophe is, strictly speaking, a
          name of the collection of libraries, from which only one is
          Strophe.js, the JavaScript tool described in this chapter.
          Nevertheless, within this thesis, both <quote>Strophe.js</quote> and
          <quote>Strophe</quote> refer to the JavaScript part of the
          library.</para>
        </footnote> is a complex but simple to use JavaScript library for
      creating an XMPP client in a web browser application, initially created
      and further maintained by Jack Moffitt. Since XMPP is the protocol
      powering the Talker application, Strophe.js appeared to be a proper tool
      for creating it. In fact, Strophe handles the whole
      <quote>transport</quote> layer for the application, as it was described
      in the introduction to this chapter.</para>

      <para>Strophe.js uses the BOSH protocol (based on HTTP long polling) for
      sending messages and receiving updates from a server. There is an
      unofficial project fork using WebSockets but it has not been accepted by
      the community yet. The main reason is probably the unfinished standard
      for handling XMPP stanzas in WebSocket stream, currently available as a
      draft. <citation>xmpp-over-websockets</citation></para>

      <para>In the following sections, the essential topics concerning
      Strophe.js are mentioned. It mostly comprises Strophe.js basic usage and
      philosophy, including using plugins for getting additional functionality
      beyond the library itself.</para>

      <sect2>
        <title>New connection</title>

        <para>Since an XMPP client is intended to communicate with various
        nodes in the Internet, a connection represents the essence of an
        application. Strophe connects to a BOSH server through which it
        communicates with the rest of the XMPP world. Its URL is stated as
        BOSH_SERVICE variable in the following example. Setting up the
        connection is simple:</para>

        <programlisting>var BOSH_SERVICE = 'https://bind.jappix.com/',
    jid  = 'pavel@example.com',
    pass = 'mysecretpassword',
    onConnect = function(status) { /* implementation */ };
var connection = new Strophe.Connection(BOSH_SERVICE);
connection.connect(jid, pass, onConnect);</programlisting>

        <para>Apart from the BOSH service URL, a Jabber ID and a password are
        passed to the connection method.</para>

        <para>The last argument stands for a callback function which is
        triggered every time the connection status changes. The status is then
        passed as an argument to the callback function. It must value to one
        of the <computeroutput>Strophe.Status</computeroutput> enum values,
        for example <computeroutput>Strophe.Status.CONNECTED</computeroutput>
        when a connection is established. An example
        <computeroutput>onConnect</computeroutput> callback can look as
        follows:</para>

        <programlisting>onConnect = function(status) {
  if (status === Strophe.Status.CONNECTED) {
    connected();
  } else {
    console.log('Connecting status: ' + status);
  }
};</programlisting>

        <para>When the connection is established, a
        <computeroutput>connected</computeroutput> function is invoked.
        Usually, this is the place the event handlers are attached to the
        connection object, which is passed as
        <computeroutput>this</computeroutput> parameter in the context of the
        <computeroutput>onConnect</computeroutput> function. Event handlers
        are described in <xref linkend="chap-strophe-events" />.</para>
      </sect2>

      <sect2 id="strophe-attach">
        <title>Attaching to an existing connection</title>

        <para>There is one problem with the process mentioned above.
        Generally, passing confidential data to JavaScript hard-coded in the
        rendered HTML files (i.e. within
        <computeroutput>&lt;script/&gt;</computeroutput> tag) constitutes a
        security issue<indexterm>
            <primary>security</primary>
          </indexterm>. As you may have noticed, the previous example
        incorporates a password in the JavaScript snippet, which is exactly
        this kind of problem. Firstly, the page can be stored in plain text as
        a browser cache. Secondly, the web page is available for anyone within
        the browser history tool so the password can be easily tracked down.
        Last but not least, unless TLS is used, the web page with the password
        traverses the Internet unencrypted.
        <citation>attached-to-strophe</citation></para>

        <para>Luckily, Strophe.js comes with a possibility to attach to an
        existing connection. It basically means that the initial BOSH
        handshake takes place on a server side. A connection is established
        and a server-side based XMPP client comes up with a session identifier
        and a current request number (SID and RID, mentioned in <xref
        linkend="chap-bosh" />).<indexterm>
            <primary>SID</primary>
          </indexterm><indexterm>
            <primary>RID</primary>
          </indexterm> Afterwards, RID and SID are sent to the client (either
        within the initial HTML template or as a separate JSON response). RID
        and SID are sufficient to identify the BOSH client. However, unlike
        password, in case of being disclosed to the attacker, only a single
        session is compromised. <citation>xmpp-in-javascript</citation></para>

        <para>Attaching to an existing connection in a JavaScript application
        using Strophe.js is rather simple, similar to initializing a new
        connection: <citation>xmpp-in-javascript</citation> <programlisting>var connection = new Strophe.Connection(BOSH_SERVICE);
connection.attach(jid, sid, rid, onConnect);</programlisting></para>
      </sect2>

      <sect2 id="chap-strophe-events">
        <title>Event handling</title>

        <para>Both JavaScript and XMPP are typical fields of using
        asynchronous processing of incoming events. The idea is simple.
        Generally, we specify the actions we are interested in and attach the
        event handlers to each of them. An event handler<indexterm>
            <primary>event handler</primary>
          </indexterm>, a function or a method, is invoked as soon as the
        specified action occurs. The event handlers, deferred functions, are
        called callbacks<indexterm>
            <primary>callback</primary>
          </indexterm>. Not only Strophe but all other asynchronous libraries
        (event-based or request/response) in JavaScript are based on
        callbacks, for example popular jQuery AJAX functions.<footnote>
            <para>http://api.jquery.com/jQuery.ajax/</para>
          </footnote><footnote>
            <para>Nowadays, the callback approach is getting replaced by
            <quote>promises</quote>, wrapping asynchronous operations to later
            resolved objects. Promises are said to be similar to functional
            <quote>monad</quote> structures, known from Haskell.</para>
          </footnote></para>

        <para>When the idea of a callback is clear, applying them to
        Strophe.js event handling is simple, as depicted in the example below.
        The first parameter is the callback itself (its name or an anonymous
        function implemented on site). The <quote>areas of concern</quote> are
        specified as the remaining five parameters. The example callback here
        is triggered every time a chat message comes, i.e. a
        <computeroutput>message</computeroutput> stanza with an attribute
        <computeroutput>type='chat'</computeroutput>. The parameters specified
        as <computeroutput>null</computeroutput> mean that any value of that
        place is processed by the handler. Therefore, the message sender,
        which can be specified by the next-to-last argument, can be
        anyone:</para>

        <programlisting>connection.addHandler(onChatMessage, null, 'message', 'chat', null,  null);</programlisting>

        <para>A callback function receives an incoming stanza object in a
        Strophe-specific pre-parsed format. Then, the object can be queried
        (with jQuery or plain JavaScript selectors), such as in the example
        below:</para>

        <programlisting>onChatMessage = function(msg) {
  var messageBody = msg.getElementsByTagName('body');
  console.log("Message text: " + messageBody);
  return true;
}</programlisting>

        <para>The last line in the function is a common pattern in Strophe.js
        the developer must be aware of. Each handler must return
        <computeroutput>true</computeroutput> (or any other value which
        evaluates to <computeroutput>true</computeroutput>) to stay bound to
        the event. If <computeroutput>false</computeroutput> is returned, the
        handler is unattached and it is not triggered any more.
        <citation>xmpp-in-javascript</citation> Therefore,
        <computeroutput>false</computeroutput> return values are proper for
        disposable callbacks, used only once.</para>
      </sect2>

      <sect2>
        <title>Stanza builders</title>

        <para>The whole XMPP protocol is represented by XML elements called
        stanzas, transferred between a client and a server. There are various
        approaches to create an XML document structure in JavaScript. Using
        jQuery is the most common way to do so. The jQuery object, created by
        jQuery <computeroutput>$</computeroutput> function, represents an XML
        structure tree which can be extended using methods like
        <computeroutput>append</computeroutput>,
        <computeroutput>wrap</computeroutput> and
        <computeroutput>after</computeroutput>.
        <citation>jquery-api</citation></para>

        <para>Strophe.js comes up with a completely independent XML creator,
        however inspired by jQuery. <citation>xmpp-in-javascript</citation>
        The functionality is to be found within the
        <computeroutput>Strophe.Builder</computeroutput> object. It allows a
        library user to create XML elements such as follows:
        <citation>strophe-api</citation><programlisting>$iq({to: 'tomas', from: 'pavel', type: 'get', id: '1'})
    .c('query', {xmlns: 'strophe:example'})
    .c('example')
    .toString()</programlisting>The previous example code creates an IQ stanza
        and the following snippet represents a respective
        result:<programlisting>&lt;iq to='tomas' from='pavel' type='get' id='1'&gt;
  &lt;query xmlns='strophe:example'&gt;
    &lt;example/&gt;
  &lt;/query&gt;
&lt;/iq&gt;</programlisting>Bijection between the two pieces of code is rather
        obvious. The only catch could be not yet defined
        <computeroutput>$iq</computeroutput> function. Similarly as jQuery,
        Strophe.js provides shorthand functions
        <computeroutput>$msg</computeroutput>,
        <computeroutput>$pres</computeroutput>, and
        <computeroutput>$iq</computeroutput> for creating all three kinds of
        stanzas, along with a <computeroutput>$build</computeroutput> function
        for making any kind of element. Therefore, creating a presence stanza
        and sending it using Strophe.js is as simple as follows:</para>

        <programlisting>this.send($pres().tree());</programlisting>
      </sect2>

      <sect2>
        <title>Logger</title>

        <para>Strophe.js does not conceal any information about its operation.
        It contains several logger methods, divided by a log level, mostly
        used by the library itself (it however can be used by the user code as
        well). Logging functionality is inserted in the main Strophe object
        itself. Calling the logger from the library methods is thus simple,
        however it can hardly be replaced by another logger (all at once),
        defined by the user. All logger methods point to the ultimate
        <computeroutput>log</computeroutput> method, which just returns by
        default. The intention of the library authors is providing this method
        to be overridden by a custom user code. So is done in the Talker
        application, as described in <xref linkend="chap-talker" />.</para>
      </sect2>
    </sect1>

    <sect1 id="chap-strophe-plugins">
      <title>Strophe plugins</title>

      <para>XMPP has been designed to be extensible (even by the protocol
      name) by various XEP extensions. Strophe.js follows the same direction
      and provides a simple way for the plugins to be added. And fortunately,
      there is not just the possibility to create a plugin on one's own, there
      are plenty of existing extensions available publicly at GitHub. In this
      section, a general way to use the plugins is described as well as a
      brief overview of several plugins used in the Talker application.</para>

      <para>Each Strophe.js plugin is contained in a separate JavaScript file,
      included to the application which uses it. The common name convention
      for a plugin file is
      <computeroutput>strophe.myplugin.js</computeroutput>.
      <citation>xmpp-in-javascript</citation> Whole plugin functionality is
      packed to a JavaScript object and passed to Strophe as follows:</para>

      <programlisting>Strophe.addConnectionPlugin('myplugin',
{
  // plugin methods and properties

  init: function(connection) {
    // init body
  },

  exampleMethod: function() { /* ... */ }
});</programlisting>

      <para>Among all plugin object properties and methods, the
      <computeroutput>init</computeroutput> function is explicitly quoted.
      That is because the <computeroutput>init</computeroutput> method is run
      as a plugin setup automatically by Strophe, after a new connection
      object has been created. The new connection object is passed to the
      method as the only parameter. The plugin can save the connection object
      for later use. <citation>xmpp-in-javascript</citation> When the plugin
      is initialized, any method (such as
      <computeroutput>exampleMethod</computeroutput> from the example above)
      can be invoked using the plugin name property of the connection object,
      as follows:</para>

      <programlisting>connection.myplugin.exampleMethod();</programlisting>

      <para>In the Talker application, several Strophe plugins are used.
      Particularly, the application uses plugin called Roster, which provides
      an easy handling of the user contact list (XMPP Roster).<indexterm>
          <primary>XMPP</primary>

          <secondary>roster</secondary>
        </indexterm> The basic use cases comprise retrieving a roster from a
      server by calling
      <computeroutput>connection.roster.get(onRoster)</computeroutput>,
      usually as soon as the Strophe connection is established. The parameter
      represents a callback function invoked when the server responds and the
      contact list is fetched. Of course, the contact list is no static
      structure and it gets changed as the contacts log in and out. All
      incoming changes are captured by the plugin and processed by the handler
      method, if it has been set up. For example, the following line of code
      sets up a <computeroutput>presenceListener</computeroutput> function as
      a callback which is triggered any time the contact list is changed. The
      structure of method parameters is exactly the same as in case of
      ordinary Strophe handlers.</para>

      <programlisting>connection.roster.registerCallback(presenceListener, 
        null, 'presence', null, null,  null);</programlisting>
    </sect1>

    <sect1 id="chap-server-side-xmpp-client">
      <title>Server-side implementations</title>

      <para>The connection attachment, as described in <xref
      linkend="strophe-attach" />, is used in the Talker application. Apart
      from the security advantages and the possibility of boosting performance
      by pre-creating the connections, there are also some drawbacks in this
      approach. The most important one is a need of an XMPP client (or at
      least a connection manager) implemented in the server-side language, or
      alternatively running Strophe itself in the server-side JavaScript
      environment.</para>

      <para>There are several available solutions. For example, a Python XMPP
      connection manager called Punjab<footnote>
          <para>https://github.com/twonds/punjab</para>
        </footnote> is well-suited for <quote>pre-creating</quote> BOSH
      connections. Speaking of PHP (as it is the language Celebrio is powered
      by), there is JAXL<footnote>
          <para>https://github.com/abhinavsingh/JAXL</para>
        </footnote> library which has been used in this project. However, it
      is not very steady tool. I have found two bugs in this library, not
      mentioning its poor documentation. One minor bug fix has already been
      accepted by the library author to the official branch,<footnote>
          <para>https://github.com/abhinavsingh/JAXL/pull/30</para>
        </footnote> the other one is still being opened by the time of
      finishing this thesis.<footnote>
          <para>https://github.com/abhinavsingh/JAXL/issues/32</para>
        </footnote>Although the latter might not be a real issue, it still
      prevents from a successful BOSH connection establishment.</para>
    </sect1>
  </chapter>

  <chapter id="chap-talker">
    <title>Talker -- IM client in a web browser</title>

    <para>As people use computers and the Internet increasingly more often,
    they do not avoid interaction with others. On the contrary, communication
    and sharing represents an essential part of current web systems. The
    social networks mostly provide a way to communicate with other people and
    they are used by millions. The same rules are valid for Celebrio, a smart
    and simple application imitating the interface of an operating system.
    Therefore, Talker application has been designed and implemented to serve
    in Celebrio as a real-time communicator or an instant messenger
    client.</para>

    <para>In this chapter, Talker application is described in depth. There are
    requirements listed, both functional and non-functional. Further on, the
    used technologies are mentioned and compared to possible substitutions.
    Some of the technologies are described in individual dedicated chapters,
    such as Strophe.js in <xref linkend="chap-xmpp-in-javascript" /> so that
    only the parts specific to Talker are mentioned here. Ultimately, several
    sections are dedicated to the implementation and testing. Source codes of
    the application are packed as the thesis supplement. However, they are
    unlikely to run without Celebrio for which the application was
    built.</para>

    <sect1>
      <title>Analysis</title>

      <para>Firstly, this section describes the application analysis, i.e.
      what the requirements are. It includes both the non-functional
      requirements (such as the platform the application must run on or the
      system it has to cooperate with) and the probable usage by customers.
      When the requirements are clear, it must be decided how to implement the
      desired functionality. That is where the design takes place. The
      application design springs from the analysis, further decomposes it and
      clarifies the way it will be implemented. The design part is crucial
      because the sooner possible glitches are unveiled and fixed the lower
      the cost is. The last thing which has to be considered and decided is
      the <quote>stack</quote> of proper technologies to be used, with regard
      to the both non-functional requirements and the design
      complexity.</para>

      <sect2>
        <title>Value proposition</title>

        <para>The first step when creating a successful application (or even a
        whole ecosystem of applications such as Celebrio) should start by
        considering the added customer (or more precisely user) value. The
        value proposition mainly contemplates the possible market, the users
        and the benefits they would have from using our application, i.e.
        Talker. <citation>value-proposition</citation> Our target market is
        well-defined and rather easy to interview: the elderly people. More
        than a half of the elderly use (or are willing to use) a real-time
        communication tool, comprising both text chat and video calls. They
        prefer it to be interoperable so they can speak to the people not
        using directly the same software tool as they do.</para>

        <para>Talker offers the benefit of running within Celebrio, the
        <quote>operating system</quote> designed specifically for the elderly.
        The compatibility is limitless within the XMPP network. Unlike many
        communication tools, it provides a text chat and a video calling
        platform bundled together, so the user simply uses it as a
        <quote>dialogue</quote> application, no matter which way she feels
        like communicating at the moment.</para>
      </sect2>

      <sect2>
        <title>Use cases</title>

        <para>The use case analysis springs from two information sources. The
        first one is based on an author's own opinion and experience with
        online communication tools. The other part is patterned on user
        interviews and the market research, carried out as a part of Celebrio
        marketing activities. In other words, the potential customers said
        what their probable use cases would look like. However, there is no
        quantitative data analysis on this topic.</para>

        <figure id="talker-uc">
          <title>Talker use case diagram</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/talker-uc.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>As depicted in <xref linkend="talker-uc" />, the Talker use case
        analysis is rather simple. There are two actors operating the system,
        a Celebrio user and a remote XMPP server. The former uses all GUI
        application components, i.e. she can display a contact list with the
        presence statuses of the contacts in it, enter the text chat (which
        includes sending and receiving new messages) and set up a video call.
        A contact list, the first application screen, is further described in
        <xref linkend="chap-contact-list" />. When any of the contacts is
        clicked at, communication view is displayed so the user can read the
        incoming messages, send a new message or start a video call. Several
        application screenshots are pictured in <xref
        linkend="appendix-screenshots" />. TODO are they?</para>

        <para>There is one more actor depicted in <xref
        linkend="talker-uc" />. It is a remote XMPP server, communicating with
        the application indirectly through an established connection. When a
        new message appears on a server, it is pushed to the application and
        handled as an incoming message. Each new message, either received or
        sent, is appended to the <quote>chat history</quote>, as it is usual
        in similar IM clients.</para>
      </sect2>

      <sect2 id="sect-choosing-tech">
        <title>Choosing technologies</title>

        <para>The use cases and a value proposition imply certain technologies
        and tools that are obvious to be used and also some constraints. At
        the lowest level, Talker is a part of a web application so it must run
        in a web browser environment. With respect to the interactivity and
        real-time behaviour, it must be powered by
        <emphasis>JavaScript</emphasis>. There are other possibilities, such
        as Adobe Flash<indexterm>
            <primary>Flash</primary>
          </indexterm> or browser plugins. However, they do not play well with
        various environments, as mentioned in <xref
        linkend="chap-high-level-rtc" />.</para>

        <para>XMPP has been chosen as the communication protocol for the
        messages transmission. It is an opened, mature and interoperable
        technology. Creating a new XMPP service means just plugging in the new
        part to a world-wide network. XMPP is described in <xref
        linkend="chap-xmpp" /> and the used JavaScript XMPP framework in <xref
        linkend="chap-xmpp-in-javascript" />. Such nontrivial application, as
        Talker is, deserves a fine client-side framework. Therefore, the
        connections, states, contact lists and all messages are not only
        stored in DOM but also managed by JavaScript itself. In the last
        years, many MVC<footnote>
            <para>MVC stands for Model -- View -- Controller, common
            three-tier architecture. Model is responsible for data layer, View
            stands for presentation layer. The function of controller varies
            from one implementation to another, but it is mostly responsible
            for dispatching the user actions and controlling application flow,
            for example redirecting.</para>
          </footnote> JavaScript frameworks have emerged. When implementing
        the application, I have tried Backbone, Angular, Knockout and Ember --
        all modern MVC JavaScript frameworks. After a short period of testing,
        I chose Ember as the best one. The framework overview, various
        advantages and also some pitfalls are mentioned in <xref
        linkend="chap-ember" />.</para>

        <para>The last important field to be covered is the video calls
        platform. On no account did I consider to implement it from scratch.
        Anyway, there are several handy tools and frameworks which could have
        been used. After all, I decided to use OpenTok, a video calls library
        described in <xref linkend="chap-opentok" />, mostly for its wide
        compatibility. It even supports WebRTC in its newest version, which is
        considered to be the future of media applications on the web.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Application architecture</title>

      <para>As mentioned in the previous section, Talker is not trivial
      application which could be served by several inline scripts manipulating
      the DOM. It has to handle states, keep track of all simultaneous
      conversations and dispatch all messages to the appropriate contacts.
      Those reasons led to a semi-modular architecture, depicted in <xref
      linkend="fig-talker-modules" />. Modules inside the grey package
      represent those I directly implemented, the outside ones are the used
      libraries and third party modules, however necessary to run the
      application.</para>

      <figure id="fig-talker-modules">
        <title>An application modules structure</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="vp/components-talker.pdf" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The main application logic is placed inside an
      <computeroutput>App</computeroutput> module. It is implemented as an
      <computeroutput>Ember.Application</computeroutput> object and it serves
      as a namespace for the rest of the application. Using the namespace to
      wrap the whole application is generally a good practice, so the global
      namespace (i.e. a <computeroutput>window</computeroutput> object) is not
      polluted. Within the namespace, other Ember-based classes are separated
      into four parts, according to the MVC structure, i.e. models, views and
      controllers. The last part is represented by a router, a component
      responsible for handling the application state.</para>

      <sect2>
        <title>Models</title>

        <para>Talker is supposed to handle data: to keep the information about
        a contact list, update it as the contacts sign in and out; to keep
        track of the message lists corresponding to individual contacts. All
        mentioned data manipulation is achieved with
        <emphasis>models</emphasis>. A model hierarchy is depicted in <xref
        linkend="fig-models" />. The main two entities,
        <computeroutput>Contact</computeroutput> and
        <computeroutput>Message</computeroutput>, are rather self-explaining.
        It should be mentioned that the messages are stored directly as a list
        property of each contact. Potential contact removal would erase its
        messages as well. The class<footnote>
            <para>When speaking about classes and displaying them in the class
            diagram, one should be aware of the fact there are no real
            language-based classes in JavaScript. However, Ember provides a
            convenient way to imitate the class behaviour with
            <computeroutput>Ember.Object.extend</computeroutput> method,
            further described in the next section.</para>
          </footnote> <computeroutput>Person</computeroutput> encapsulates the
        properties common for the contacts and the user operating the
        application. In other words, the information about the current user,
        logged in to the application, is stored in an instance of that
        class.</para>

        <figure id="fig-models">
          <title>A structure of the application models</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/cd-app-models.pdf" />
            </imageobject>
          </mediaobject>
        </figure>
      </sect2>

      <sect2>
        <title>Views and controllers</title>

        <para>All Ember-related issues are described in the section <xref
        linkend="chap-ember" />, only the structure is mentioned here. As the
        user traverses the application, various controllers manage the states.
        The structure of controllers bijectively corresponds to the views
        hierarchy (i.e. almost every view has its respective controller and
        vice versa). Thereby, only the controllers are displayed in <xref
        linkend="fig-controllers" />, to show the hierarchy structure. The
        main view, a contact list, is handled by a
        <computeroutput>ContactsController</computeroutput> instance. When the
        user enters the conversation,
        <computeroutput>ConversationController</computeroutput> takes over the
        command. <computeroutput>TextController</computeroutput> and
        <computeroutput>VideoController</computeroutput> (with their
        respective views) are present within the conversation. Calling one or
        another depends on whether the user interacts with the text part (the
        chat) or the video calls.</para>

        <figure id="fig-controllers">
          <title>An application views/controllers structure</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/cd-app-controllers.pdf" />
            </imageobject>
          </mediaobject>
        </figure>
      </sect2>

      <sect2>
        <title>Adapters</title>

        <para>There is a considerable amount of application logic not related
        to the data itself, but comprising the connection establishment, along
        with managing and triggering the correct handlers when a new data
        comes from the server. As Jon Cairns fittingly notes in his blog post,
        models should not contain the unnecessary application logic not
        directly related to them.
        <citation>fat-model-skinny-controller</citation> In Talker, such
        application logic is divided into two <quote>adapter</quote> classes.
        <computeroutput>StropheAdapter</computeroutput> is responsible for
        creating, keeping up and reacting to an XMPP connection to a BOSH
        server. In other words, it mostly handles the text messages. On the
        contrary, <computeroutput>OpenTokAdapter</computeroutput> uses the
        OpenTok library to keep track of the video calls. The video adapter
        object is assigned to every contact because it keeps the state
        information (a session), which is different for each contact. On the
        other hand, <computeroutput>StropheAdapter</computeroutput> is created
        and initialized just once for the whole application since it does not
        contain any contact-specific data. The class structure is depicted in
        <xref linkend="fig-adapters" />.</para>

        <figure id="fig-adapters">
          <title>Connection of the application and adapters</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/cd-adapters.pdf" />
            </imageobject>
          </mediaobject>
        </figure>
      </sect2>
    </sect1>

    <sect1 id="chap-ember">
      <title>Ember.js -- JavaScript MVC framework</title>

      <para>Talker is a purely client-side-based application, implemented in
      JavaScript and running in a web browser. As mentioned in the technology
      overview in <xref linkend="sect-choosing-tech" />, Talker implements the
      MVC structure on the client side, in the form of Ember MVC objects. In
      this section, JavaScript MVC is analysed overall at first, then some
      features specific to Ember, which were used in the implementation, are
      described.</para>

      <sect2>
        <title>Client-side MVC</title>

        <para>First of all, it should be clarified why it is necessary to do
        MVC in JavaScript. Most of the web technologies running on a server
        and powering the web applications use some kind of MVC<indexterm>
            <primary>MVC</primary>
          </indexterm>, across all programming languages. It is Rails for
        Ruby; Zend, Nette or Symphony for PHP; Django for Python; Spring MVC
        or even simple servlets with JSPs in Java; ASP.NET MVC for C#/.NET,
        etc. It appears that three-tier architecture<indexterm>
            <primary>three-tier architecture</primary>
          </indexterm> helps the developers to organize the code. In addition,
        the frameworks can do a considerable amount of job
        automatically.</para>

        <para>In the last couple of years, the approach to a web application
        development has changed a bit. As the performance of clients
        increases, the interactivity and a quick response have become the most
        desired benchmark. And here comes JavaScript, which can manage a whole
        application at the client side, only synchronizing a data with a
        server using AJAX requests. It seems this trend of a <emphasis>thick
        client</emphasis> (sometimes also referred as a <emphasis>fat
        client</emphasis>) will be increasingly stronger in the next years. A
        server is going to be transformed only to a proxy in front of a
        database system.
        <citation>yehuda-talk</citation><citation>new-dev-era</citation></para>

        <para>It is obvious that many tasks, for which a server was
        responsible previously, have moved to a client -- to JavaScript. Above
        all, a JavaScript application handles the user actions (such as
        clicking a button or even typing to an input), renders HTML snippets
        (i.e. templates) and stores the <quote>temporary</quote> data, i.e.
        the data the application currently works with. Storing the data has
        become a bit tricky, because the JavaScript application works as a
        first level cache, which processes all changes but synchronizes with
        the server only occasionally. A simple example: let there be an input
        for a user name, bound to a JavaScript model object representing a
        user. Whenever a new letter appears in the input, JavaScript updates
        its corresponding model object (still on the client side). No sooner
        has a whole user name been entered (either submitted or after a
        certain delay) when JavaScript synchronizes it with the server. A
        schema of the whole process is depicted in <xref
        linkend="fig-js-mvc-input" />.</para>

        <figure id="fig-js-mvc-input">
          <title>Example client-handled input, bound to JavaScript
          model</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/js-mvc-input.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The main advantage of such approach is definitely the swiftness.
        The input changes (numbered 1, 2 and 3) are processed immediately at
        the client. If a browser ran in an offline mode, submitting would
        store the data to the local storage eventually. Another very important
        benefit, especially for an application developer, is the separation of
        concerns among individual tiers. The result is much better organized
        and thus better maintainable than a monolithic blend of code,
        containing all application aspects at one place.</para>

        <para>In modern client-side JavaScript MVC frameworks, JavaScript is
        also responsible for rendering HTML. This topic is set aside to a
        separate section in <xref linkend="sect-html-rendering" />.</para>
      </sect2>

      <sect2>
        <title>Comparison to other frameworks</title>

        <para>Ember.js is not the only available JavaScript MVC framework. In
        fact, there are plenty of similar frameworks, each of which provides a
        slightly different set of tools and asserting a slightly different
        philosophy. I have chosen Ember for Talker due to several reasons. The
        facts in this section may be a little subjective as they are mostly
        just opinions of mine, as author of this thesis and the Talker
        application. There is actually not very much comparison but rather the
        features specific for Ember are described and explained.</para>

        <para>First of all, Ember provides automatic bindings. There are
        automatic bindings between the object properties, so that all computed
        properties are automatically updated when the <quote>raw</quote>
        properties, which they are based on, change their values.
        <citation>ember-in-action</citation> The following snippet of code
        from the <computeroutput>Message</computeroutput> object represents
        such situation: the <computeroutput>fromName</computeroutput>
        attribute represents a contact name, which is based on the contact
        JID, stored in the <computeroutput>from</computeroutput>
        attribute:</para>

        <programlisting>App.Message = Ember.Object.extend({
    from : null,
    fromName : function() {
        /* implementation */
    }.property('from')
});</programlisting>

        <para>The binding is really valuable when a value of the
        <computeroutput>fromName</computeroutput> property has already been
        rendered in a template. There is no
        <computeroutput>render</computeroutput> function (as it is in Backbone
        framework, for instance) to render the template; templates are
        rendered automatically and updated automatically as well, as the
        underlying data changes.</para>

        <para>There is a considerable amount of additional work which Ember
        takes care of. The framework follows the <quote>convention over
        configuration</quote> rule to the maximum extent, above all other MVC
        frameworks. For instance, when one keeps up to the official naming
        conventions, the framework creates the objects which are necessary and
        have not yet been defined, such as a missing controller.</para>

        <para>Ember.js uses a templating engine Handlebars, which provides a
        very clean and convenient way to create a presentation layer of the
        application. In my opinion, using a dedicated templating engine makes
        the code much more cleaner than using HTML attributes, as for example
        Knockout.js does. Templating is further described in <xref
        linkend="sect-html-rendering" />.</para>

        <para>To sum it up, Ember.js is a modern and powerful tool doing a
        considerable amount of job that a programmer does not have to take
        care about. On the other hand, the learning curve of Ember is told to
        be one of the steepest and it is rather difficult to make the
        <emphasis>second</emphasis> step, after reading the basic tutorials
        and examples. Fortunately, there is an active community working on
        screencasts<footnote>
            <para><ulink
            url="http://emberwatch.com/">http://emberwatch.com/</ulink></para>
          </footnote>, documentation and actively answering questions on
        Twitter and StackOverflow.</para>
      </sect2>

      <sect2 id="sect-ember-controllers">
        <title>Controllers</title>

        <para>Application controllers are responsible for storing the current
        state and mediating the communication between the views and models.
        <citation>ember-howto</citation> In Ember (and thus in Talker as
        well), the controllers also represent collections of the model
        objects.</para>

        <para>The first function, processing the user actions from the view,
        is represented by the <computeroutput>processMessage</computeroutput>
        method in <computeroutput>TextController</computeroutput>. The
        following snippet is a shortened part taken from the Talker source
        code:</para>

        <programlisting>App.TextController = Ember.ObjectController.extend({

    processMessage : function(messageText) {

        var message = App.Message.create({ ... });

        message.send();
        this.get('content.messages').pushObject(message);
    }

});</programlisting>

        <para>The method <computeroutput>processMessage</computeroutput> is
        called from the view object, when a message input is submitted. The
        view just grabs the data from the input and sends it to the
        controller, which creates a new
        <computeroutput>Message</computeroutput> object, sends the message and
        finally updates the list of messages for the current contact,
        accessible via <computeroutput>this.get('content')</computeroutput>.
        Adding <computeroutput>.messages</computeroutput> to the
        <quote>selector</quote> points the getter directly to the array of
        messages.<footnote>
            <para>Actually, the method contains a lot more code such as an
            argument check and return values. They have been omitted in this
            example for clarity and shortness.</para>
          </footnote></para>

        <para>Another example of a controller from Talker is not an instance
        of <computeroutput>ObjectController</computeroutput>, as in previous
        example, but <computeroutput>ArrayController</computeroutput>. It
        represents a collection of contacts, displayed in the main application
        view:</para>

        <programlisting>App.contactsController = Ember.ArrayController.create({

    content:[],

    pair : function () {
        var content = this.get('content');
        var result = [];
        for (ii = 0; ii &lt; content.length; ii += 2) {
            result.pushObject({
                "first" : content[ii],
                "second" : content[ii + 1] ? content[ii + 1] : null
            });
        }
        return result;
    }.property('content.@each')
});</programlisting>

        <para>The contacts are stored in the
        <computeroutput>content</computeroutput> attribute, which is an Ember
        convention for naming an actual data set within an
        <computeroutput>ArrayController</computeroutput>. Since it is
        necessary to render the contacts as pairs in the two-row-view (TODO
        depicted in screenshot XY), there is the
        <computeroutput>pair</computeroutput> method returning the content
        reformatted as an array of pairs. Notice that the function is a
        property of <computeroutput>content.@each</computeroutput>, which
        means that any update, insertion or deletion of the content array
        forces the pairs to be recalculated as well.</para>
      </sect2>

      <sect2 id="sect-html-rendering">
        <title>Rendering HTML</title>

        <para>A thick JavaScript client is responsible not only for
        manipulating the data but also for rendering it to the HTML page.
        Ember is shipped with Handlebars<indexterm>
            <primary>Handlebars</primary>
          </indexterm> -- a lightweight templating engine. The application is
        decomposed to separate views; in case of Talker, it may be a contact
        list view or the conversation, which consists of another two parts --
        a text chat view and a video view. The structure basically corresponds
        to the controller tree in <xref linkend="fig-controllers" />.
        Additionally, the text chat contains a theoretically unlimited number
        of views, each of which for a single message -- either sent or
        received.</para>

        <para>There are two important parts of a view: the view object itself
        and its template. To describe the philosophy of a presentation layer,
        <computeroutput>VideoView</computeroutput> is further examined here,
        as an example:</para>

        <programlisting>App.VideoView = Ember.View.extend({
    templateName: 'video',

    buttonLabel : function() {
        return this.get('controller.content.isActive') ? m.stop : m.start;
    }.property("controller.content.isActive")
});</programlisting>

        <para>There are two properties in the view object:
        <computeroutput>templateName</computeroutput> and
        <computeroutput>buttonLabel</computeroutput>. The former just
        determines the name of a template connected to this view. The latter
        is a common method returning one of
        <computeroutput>stop</computeroutput> or
        <computeroutput>start</computeroutput> messages, according to the
        value of the property <computeroutput>isActive</computeroutput>,
        located in the <computeroutput>controller.content</computeroutput>
        object, pointing to the contact the user is currently talking to. The
        other important part is the template itself, inserted directly in the
        HTML page:<footnote>
            <para>Handlebars templates must be compiled by Ember to a
            JavaScript code to be ready to be used. It is possible to let
            Ember compile the templates in the browser or precompile the
            templates on a server. However, there is a very poor support for
            doing so in PHP. Therefore, templates are rendered in the HTML
            page and compiled in a browser while application is being
            developed. For a production, it is recommended to precompile them
            using the dedicated Node.js module: <ulink
            url="http://handlebarsjs.com/precompilation.html">http://handlebarsjs.com/precompilation.html</ulink>.</para>
          </footnote></para>

        <programlisting>&lt;script type="text/x-handlebars" data-template-name="video"&gt;

    &lt;div class="content_margin" &gt;
        &lt;div id="video"&gt;&lt;!-- video of me comes here --&gt;&lt;/div&gt;
        &lt;div id="stream"&gt;&lt;!-- video of the contact comes here --&gt;&lt;/div&gt;
        &lt;div id="message"&gt;{{stateMessage}}&lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="button_wrapper_video"&gt;
        &lt;button {{action toggleCall target="controller"}} type="submit"&gt;
            {{view.buttonLabel}}
        &lt;/button&gt;
    &lt;/div&gt;

&lt;/script&gt;</programlisting>

        <para>The template is inserted in a
        <computeroutput>script</computeroutput> element, declaring itself as a
        Handlebars template. The only attribute
        <computeroutput>data-template-name</computeroutput> identifies the
        snippet and connects it to the view object, which specified the same
        value in the <computeroutput>templateName</computeroutput> attribute,
        as shown above. The template can contain any HTML, along with the
        variables and expressions, both enclosed in double braces, sometimes
        referred as <quote>moustaches</quote>. In the example of the video
        template, there is a <computeroutput>stateMessage</computeroutput>
        variable queried, which is looked up in the object bound to the
        template. The object is provided by a router (described in <xref
        linkend="sect-routing" />). In this case, the context object would be
        the current contact the user is talking to.</para>

        <para>The second Handlebars expression in the template is an action.
        Actions are usually bound to the active elements, such as buttons.
        When the button is clicked, the action is triggered. Ember finds the
        controller responsible for the current state, which would be an
        instance of <computeroutput>VideoController</computeroutput> in this
        case, and calls the method
        <computeroutput>toggleCall</computeroutput>, specified in the template
        expression. Actions can be placed both in the controllers and the
        views, according to each of whose nature.</para>

        <para>Handlebars templates can transform almost any data stored in
        JavaScript to an HTML code so the rendered template corresponds
        exactly to the current application state. It is also possible to add
        an HTML <computeroutput>class</computeroutput> attribute, according to
        the values of the object properties. In the following snippet, there
        is a message template, rendered individually for each message in the
        conversation. The class is assigned to the wrapping
        <computeroutput>div</computeroutput> element, according to
        <computeroutput>isFromMe</computeroutput> property. If it evaluates to
        true, <computeroutput>from_me</computeroutput> class attribute is
        added, <computeroutput>to_me</computeroutput> otherwise. The
        <computeroutput>message</computeroutput> class is added independently
        of the properties and it is always present so the block can be styled
        as the message with custom CSS.</para>

        <programlisting>&lt;script type="text/x-handlebars" data-template-name="message"&gt;
    &lt;div {{bindAttr class="isFromMe:from_me:to_me :message"}}&gt;
        &lt;span class="from"&gt;{{fromName}}:&lt;/span&gt;
        &lt;span class="text"&gt;{{text}}&lt;/span&gt;
    &lt;/div&gt;
&lt;/script&gt;</programlisting>

        <para>The last two things to be mentioned about templates are the
        topics of iterating and nesting. Have a look at the following example
        from the main contact list view (altered a bit):</para>

        <programlisting>&lt;script type="text/x-handlebars" data-template-name="contact-list"&gt;
    {{#each App.contactsController.pair}}
        &lt;div class="pair_wrapper"&gt;
            {{view App.ContactView contentBinding="first"}}
            {{view App.ContactView contentBinding="second" }}
        &lt;/div&gt;
    {{/each}}   
&lt;/script&gt;</programlisting>

        <para>When the template is rendered, Ember iterates over the
        collection of contacts, accessed by the
        <computeroutput>pair</computeroutput> method (it was mentioned in
        <xref linkend="sect-ember-controllers" />). Then, the framework takes
        each contact from the pair and instantiates the
        <computeroutput>ContactView</computeroutput> for it, passing it as a
        current object for the view and rendering the template exactly in the
        place the view expression is stated. Therefore, the list of contacts
        is rendered, grouped by two inside the
        <computeroutput>pair_wrapper</computeroutput> blocks.</para>
      </sect2>

      <sect2 id="sect-routing">
        <title>Routing</title>

        <para>Although HTTP is a stateless protocol, it is common habit to
        build complex stateful applications on the web. The states are
        simulated by various web pages and the transitions are carried out by
        clicking the links. All changes are simultaneously displayed in the
        URL bar.</para>

        <para>The problem is that JavaScript application cannot switch from
        one web page to another, leaving one and continue at the other.
        JavaScript would lose its context and whole MVC structure would be
        purposeless. Therefore, most JavaScript applications using MVC
        frameworks run at a single web page, no matter how many states they
        contain. In Ember.js, there is a special object called
        <emphasis>Router</emphasis><indexterm>
            <primary>router</primary>
          </indexterm>, responsible for transitions between the states,
        dispatching the events and rendering correct templates.<footnote>
            <para>The Ember router API changed a lot since the application was
            implemented (it is less than a year, but still). Further in this
            section, the old version of API is described since it is the
            version used in the Talker application. Updating Talker to the
            newest version of Ember.js, with the new router, is one of the
            possible future tasks.</para>
          </footnote></para>

        <para>The router contains several states, ordered in a tree structure,
        according to the flow of possible user actions. The routes can be
        nested. The first task of the router is mapping the application states
        to URLs. Every time the transition takes place, the router changes the
        context (it basically renders a different template) and it changes the
        URL as well. Since JavaScript can change only a URL fragment, the
        router does exactly so. And vice versa, when the user types a specific
        URL in the URL bar, the application lets the router choose the
        matching state and set the context in a similar way.</para>

        <programlisting>App.Router = Ember.Router.extend({

    root: Ember.Route.extend({

        goToContactList : Ember.State.transitionTo('contacts'),
        goToConversation : Ember.State.transitionTo('conversation.index'),

        index : Ember.Route.extend({
            route:'/',
            redirectsTo:"contacts"
        }),

        contacts : Ember.Route.extend({
            route:'/contacts'
        }),

        conversation : Ember.Route.extend({
            route:'/conversation/:contact_id'
            index : Ember.Route.extend({
                route:'/'
            })
        })
    })
});</programlisting>

        <para>Handling the application links is the second responsibility of
        the router. In the example above, there are two link destinations,
        named by <computeroutput>goTo-</computeroutput> labels. When any
        element is marked with <computeroutput>{{action
        goTo*}}</computeroutput>, a Handlebars tag, it is transformed into a
        link leading to the corresponding router state. And the router handles
        the event by simply transitioning it to one of the existing
        states.</para>

        <para>Let us have a look at one of the routes in a detail. As
        mentioned before, the router is responsible for creating a unique URL
        for every application state. That usually means serializing the
        application state to URL when the transition is carried out via the
        link. In the other case, when the URL is typed directly into the URL
        bar, the router has to deserialize the URL and establish the proper
        application state.</para>

        <programlisting>conversation : Ember.Route.extend({

    route : '/conversation/:contact_id',

    connectOutlets : function (router, contact) {
        // binds current contact to the conversationController 
        // so the text/video view can access it
        router.get('applicationController')
              .connectOutlet('conversation', contact);
    },
    deserialize : function (router, params) {
        return App.contactsController.find(function(item) {
            return item.id == params.contact_id;
        });
    },
    serialize : function (router, context) {
        return context ? { contact_id : context.get('id') } : {};
    }
})</programlisting>

        <para>There are two methods providing such functionality,
        <computeroutput>serialize</computeroutput> and
        <computeroutput>deserialize</computeroutput>. The former picks the
        unique identifier for the current context (a contact object) and
        returns it as <computeroutput>contact_id</computeroutput>. This
        parameter is used in the route
        <computeroutput>'/conversation/:contact_id'</computeroutput> as a
        dynamic segment, so that actual route would be
        <computeroutput>'/conversation/42'</computeroutput> for example.
        <citation>ember-router</citation> Deserializing works in the exactly
        opposite way. Ember prepares the URL segment for the router so it is
        passed as an object containing the map of dynamic segments, which
        would be <computeroutput>{ contact_id : '42' }</computeroutput> in our
        (example) case. The only job
        <computeroutput>deserialize</computeroutput> must do is to find the
        appropriate object (a contact with ID 42) and to return it as the
        current context object.</para>

        <para>The last remarkable aspect of the router is choosing the
        appropriate templates and connecting them together. Basically, the
        <computeroutput>connectOutlets</computeroutput> method tells the main
        application controller to <quote>include</quote> the controller
        responsible for the current state, which would be a
        <computeroutput>ConversationController</computeroutput> instance in
        the example above. This is important when the templates are rendered.
        First, a main application template is rendered. Then, Ember looks into
        the template for the <computeroutput>{{outlet}}</computeroutput> tag
        and it inserts the conversation template exactly to the place it is
        found. The last thing, the appropriate contact object is passed as the
        context for the conversation controller (and thus the template as
        well). Everything described in this paragraph is deduced from the
        one-line implementation of
        <computeroutput>connectOutlets</computeroutput> method in the example
        above.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Initializing the connection</title>

      <para>When the user clicks at the Talker icon in the Celebrio main menu,
      a request is sent to the server which generates an HTML page (containing
      directly HTML as well as the Handlebars templates) and sends it along
      with all necessary assets, such as JavaScript files and CSS style
      sheets. When the page is loaded, Talker starts running. First of all,
      the connection to a remote BOSH server must be established so that the
      application can communicate with the rest of the world. There are two
      options to do it: creating a brand new connection or using the existing
      one, i.e. attaching to the connection as it is described in <xref
      linkend="strophe-attach" />.</para>

      <para>As JavaScript files are loaded, the
      <computeroutput>App</computeroutput> object is defined by Ember firstly
      -- a whole MVC structure described in <xref linkend="chap-ember" /> is
      initialized. Then, a new <computeroutput>StropheAdapter</computeroutput>
      object is created and it attempts to establish the connection with a
      BOSH server immediately. The Strophe adapter supports both creating a
      new connection and letting the server to create one. The initialization
      code basically checks whether the password has been provided, i.e.
      passed to the client code. If yes, a BOSH authentication takes place, as
      depicted in <xref linkend="fig-conn-establish" />. When the password has
      not been provided, the JavaScript client sends an authentication request
      to the server, which should establish the connection and return JID, SID
      and RID so the client can attach to the connection and use it for the
      further communication. The workflow is depicted in <xref
      linkend="fig-conn-attach" />. In both cases, an authentication handshake
      follows the SASL authentication protocol defined by XEP-0206.
      <citation>xep-0206</citation></para>

      <figure id="fig-conn-establish">
        <title>Establishing a new BOSH connection from JavaScript</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="vp/conn-establish.pdf" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure id="fig-conn-attach">
        <title>Establishing a new BOSH connection using a server side XMPP
        client</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="vp/conn-attach.pdf" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>It is recommended not to send a password to the client, for
      obvious security reasons. Therefore, Talker is set to use a server-side
      connection establishment by default. On the other hand, PHP
      implementations of XMPP clients are not that matured and certain
      problems have appeared, as mentioned in <xref
      linkend="chap-server-side-xmpp-client" />.</para>
    </sect1>

    <sect1>
      <title>Processing events</title>

      <para>Talker works as a typical asynchronous application. The
      application mostly consists of various
      <emphasis>callbacks</emphasis><indexterm>
          <primary>callback</primary>
        </indexterm> (i.e. event listeners), attached to different events and
      awaiting to be triggered within the JavaScript event loop.
      <citation>async-javascript</citation> It is a common pattern in
      JavaScript applications, nowadays,
      <citation>js-definitive-guide</citation> along with the
      <emphasis>promises</emphasis><indexterm>
          <primary>promises</primary>
        </indexterm> pattern, which wraps the event listener function to a
      later resolved object, which can be further processed even before the
      event occurs. <citation>domenic-promises</citation></para>

      <para>Talker does expect the events<indexterm>
          <primary>events</primary>
        </indexterm> to come either from the user (traversing the application,
      sending a message, ...) or from the network (a response from a BOSH
      server, an incoming message, ...). Basically, almost everything in
      Talker is intended to be either
      <emphasis>declarative</emphasis><indexterm>
          <primary>declarative programming</primary>
        </indexterm> (Ember object patterns) or
      <emphasis>event-based</emphasis> (Strophe events).</para>

      <para>The first kind of events are those incoming from the network. As
      it was mentioned in <xref linkend="chap-strophe-events" />, Strophe is
      set up with the event handlers attached to various event types. There is
      not even one synchronous call between the application and the server, so
      that every response is handled by a custom callback asynchronously. All
      callbacks are defined as the methods of a
      <computeroutput>StropheAdapter.prototype</computeroutput> object, so
      that they are shared by all
      <computeroutput>StropheAdapter</computeroutput> instances.
      <citation>js-enlightnment</citation></para>

      <para>Incoming chat messages are handled by a
      <computeroutput>chatMessage</computeroutput> method. The message is
      passed to the method from the Strophe library in a form of an
      <computeroutput>Element</computeroutput> object. The method parses the
      message, constructs the Ember model
      <computeroutput>Message</computeroutput> object and tries to assign the
      message to a contact (the recipient). When the recipient is known (ergo
      she is present in the user's contact list), a new message is appended to
      an existing list of messages. Ember automatically updates the view so
      the message appears in the list immediately.</para>

      <programlisting>var message = App.Message.create({
    to : msg.getAttribute('to'),
    from : Strophe.getBareJidFromJid(msg.getAttribute('from')),
    type : msg.getAttribute('type')
});

var contact = App.contactsController.find(function(item) {
    return item.jid == message.from;
});

contact.get('messages').pushObject(message);</programlisting>

      <para>The user actions are handled mostly by Ember itself. For example,
      sending a new message is managed by the controller (described in <xref
      linkend="sect-ember-controllers" />), which only calls an adapter
      function, which actually sends the prepared message object. It is one of
      the design drawbacks of the application, that there is a two-way
      awareness between the adapter and the controllers (sometimes a
      controller calls the adapter, sometimes the adapter actively calls the
      controller). Such design was chosen for its simplicity and it appeared
      to be sufficient for the application of Talker's size.</para>

      <sect2>
        <title>Notifications<indexterm>
            <primary>notifications</primary>
          </indexterm></title>

        <para>Talker is only a part of a bigger system -- Celebrio. The user
        has to find out when a new message arrives. Therefore, a simple
        mechanism of notifications has been developed and used across the
        system, not only in Talker. When a new chat message arrives, the
        application triggers a built-in mechanism of notifications and the
        notification message is propagated to the main Celebrio frame,
        utilizing the <computeroutput>postMessage</computeroutput>
        API.<footnote>
            <para><ulink
            url="https://developer.mozilla.org/en-US/docs/DOM/window.postMessage">https://developer.mozilla.org/en-US/docs/DOM/window.postMessage</ulink></para>
          </footnote> Since the notifications are not specific to Talker and
        they were not developed as a part of the application, they are not
        further described here.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Logger</title>

      <para>Although JavaScript is a very popular language, at least in web
      applications, there is no common way to log<indexterm>
          <primary>logging</primary>
        </indexterm> events or custom messages. There are two possible
      reasons: Firstly, JavaScript runs in a web browser and frequent AJAX
      requests would be necessary to log everything what happens. Secondly, a
      web browser is kind of a <quote>hostile</quote> environment, so the
      system developer cannot rely on the message truthfulness at all.
      Nevertheless, it is useful to have some information logged, at least
      while developing the application, locally to the browser
      console.<footnote>
          <para>All current browsers have the
          <computeroutput>console.log</computeroutput> method implemented,
          which outputs a message from the JavaScript code to the browser
          console, accessible to anyone using the browser. The main advantage
          is the fact that the console is hidden from the ordinary users, yet
          it can be easily accessed by anyone debugging the application or
          reporting a bug. See the API for details: <ulink
          url="https://developer.mozilla.org/en/docs/DOM/console.log">https://developer.mozilla.org/en/docs/DOM/console.log</ulink>.</para>
        </footnote></para>

      <para>The main problem with the frequently used
      <computeroutput>console.log</computeroutput> method is the impossibility
      of hiding a certain kind of messages. In Talker, there are several
      different kinds of logs: those related to messages, the video,
      subscriptions, notifications etc. It is impossible to have the output
      uncluttered without constant commenting and uncommenting the
      <computeroutput>console.log</computeroutput> calls.</para>

      <para>In order to solve this trouble, a logging library Log4js<indexterm>
          <primary>Log4js</primary>
        </indexterm> has been used in the application. It allows to create
      various loggers (with various appenders). Each logger has its own log
      level set, so that it outputs only the messages tagged by that level, or
      higher. Actually, the logger usage is very similar to a well-known
      log4j<indexterm>
          <primary>log4j</primary>
        </indexterm>, including formating layouts. There is an AJAX appender
      available in Log4js so it is possible to send the messages to the server
      to be stored permanently. This might be also useful to log the error
      messages not reproducible in the development environment.</para>

      <sect2>
        <title>Setup</title>

        <para>The logger (with a console appender) is set up as
        follows:</para>

        <programlisting>Log4js.getLogger("message")
      .setLevel(Log4js.Level.INFO)
      .setAppenders([new Log4js.BrowserConsoleAppender()]);</programlisting>

        <para>Originally, the library does not allow chaining methods so a
        local variable must be created to set up the logger (or the
        <computeroutput>getLogger</computeroutput> method must be called
        multiple times). I believe method chaining is a sensible pattern so I
        reimplemented several methods in the library to get it supported.
        Unfortunately, the project is not hosted on GitHub so it is rather
        difficult to offer the changes back to the community.</para>

        <para>Once the logger is initialized, it is stored in the Log4js
        internal list of loggers. Later on, each logger can be retrieved from
        that list by calling the same
        <computeroutput>getLogger</computeroutput> method as during the
        initialization.</para>
      </sect2>

      <sect2>
        <title>Logging</title>

        <para>Logging a message is also rather easy; it might look as the
        following example (cut out of
        <computeroutput>onConnect</computeroutput> method in Talker):</para>

        <programlisting>App.log.logger.info('Strophe is connected as ' + App.me.jid);
App.log.logger.debug(this);</programlisting>

        <para>Two notes should be mentioned about the code. Firstly, all
        loggers which have been set up are accessible not only directly from
        Log4js object, but also via the
        <computeroutput>App.log</computeroutput> object. It is a wrapper so
        the used logging library (Log4js in our case) can be changed (and it
        was changed several times during the development). As long as the
        logger objects implement common logging methods (such as
        <computeroutput>info</computeroutput> and
        <computeroutput>debug</computeroutput>), the application will work
        without the need to change the logging itself.</para>

        <para>The second thing is logging complex objects such as
        <computeroutput>this</computeroutput>, pointing to the
        <computeroutput>Strophe.connection</computeroutput> in the example
        call. Log4js does not provide any layout which would not transform the
        value to string -- [object Object] in our case. This is not very
        useful. The developer usually knows there is an object and she just
        wants the possibility to inspect it. Therefore, I enhanced the library
        again in order to log complex objects. First of all, the logger
        outputs a text message saying a complex value is about to be logged.
        Then, the complex value is logged individually, without being cast to
        string. Therefore, it is possible to access it interactively in the
        console, to fold and unfold nested properties and to carry out other
        inspections. Logging the object from the example above thus looks as
        follows (arrows inside the object symbolize that the property can be
        further inspected):</para>

        <programlisting>INFO - Strophe is connected as pavel.smolka@jappix.com
DEBUG - [object Object]
Strophe.Connection {
 -&gt; adapter: StropheAdapter
 -&gt; addHandlers: Array[0]
 ...
}</programlisting>
      </sect2>
    </sect1>

    <sect1 id="chap-contact-list">
      <title>Contact list</title>

      <para>The list of contacts is an essential part of every instant
      messaging application. The same applies to Talker, with a tiny
      modification compared to classical IM clients. Talker has been designed
      and implemented as a part of Celebrio -- a comprehensive <quote>web
      operating system</quote>. The contact list is not managed by Talker
      itself, it servers to other applications as well. On the other hand, the
      user can connect an existing third party XMPP account to Celebrio, with
      its own contact list (a roster). It is crucial to deal with the contacts
      duplication and to perform appropriate matching of one to the
      other.</para>

      <sect2>
        <title>Fetching Celebrio contact list</title>

        <para>As mentioned in the previous paragraph, the contact list base
        comes from the server-side database. Celebrio asks the user for adding
        her contacts in the People application, another part of the system.
        All contacts are stored in a relational database and they available
        throughout the system, in all applications. One of the properties of a
        contact entity is its JID. For the needs of Talker, the contacts are
        filtered on the server so that only those which have a JID filled are
        returned as the user's contact list.</para>

        <para>Since Talker is a JavaScript application, the contacts are
        passed to JavaScript in a JSON format. To avoid an extra request (and
        thus a delay), contact list is rendered directly by PHP to the
        <computeroutput>&lt;script/&gt;</computeroutput> element in the
        server-side processed template, during the initial request. Then, when
        the Ember application is initialized, the array of plain JavaScript
        objects is transformed to the content of
        <computeroutput>ArrayController</computeroutput>, specifically
        <computeroutput>App.contactsController</computeroutput>. After that,
        the application can easily manage rendering the contact list within a
        Handlebars template and keeping it up-to-date.</para>

        <para>The Ember class <computeroutput>Contact</computeroutput> is one
        of the most voluminous objects in the application. Each
        <computeroutput>Contact</computeroutput> object contains both the
        <quote>static</quote> properties from a server (such as the contact's
        name or its avatar picture) and the dynamic information about the
        current state in the application. The latter category includes the
        information whether the contact is online or not, its presence status
        (DND, Away, ...) and also all messages related to the contact.</para>

        <para>In whole Celebrio system, there is a rule that the contacts the
        user has not added to her contact list (in the People application) do
        not affect the user in any way. In fact, all messages, updates or
        invites from unknown contacts are processed by the application, but
        they are thrown away and not displayed to the user. There is a
        possibility to easily extend the application to be able to communicate
        with contacts that have not been added yet. However, it would break
        the system philosophy. Making such decision is not up to the thesis
        author.</para>
      </sect2>

      <sect2>
        <title>Matching entries from XMPP roster</title>

        <para>A contact list retrieved from the Celebrio back-end, as it was
        described in the previous section, is only an underlying material for
        building the actual contact list. The other part is the XMPP
        roster<indexterm>
            <primary>XMPP</primary>

            <secondary>roster</secondary>
          </indexterm> (an XMPP contact list), stored at the XMPP server. The
        roster can possibly contain contacts different from those originating
        from an internal Celebrio contact list, because the roster can be
        accessed from other XMPP clients as well.</para>

        <para>When the application is connected, fetching a roster from an
        XMPP server is one of the first steps. One of Strophe.js plugins
        (plugins were generally described in <xref
        linkend="chap-strophe-plugins" />), called characteristically Roster,
        provides a convenient API for such task -- a callback function is
        passed to the <computeroutput>roster.get</computeroutput> method and
        executed when the roster is fetched.</para>

        <para>The callback does basically two things, as depicted in <xref
        linkend="fig-roster-fetch" />. The retrieved contacts (those from the
        XMPP roster) are matched to existing contacts, retrieved previously
        from the Celebrio server. For each XMPP contact retrieved in the
        roster, the appropriate record in the
        <computeroutput>contactsController</computeroutput> array is found and
        matched. Contacts present only in the roster are just logged, the
        application does not work with them.</para>

        <figure id="fig-roster-fetch">
          <title>Matching XMPP roster and Celebrio contact list</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/roster-fetch.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The second part (the left side of the picture) of matching
        contacts works from the opposite direction. The application processes
        all contacts that have been retrieved from the server and which are
        not present in the XMPP roster. Then, it sends a subscription request
        to each such contact, which consists of several steps, but it simply
        stands for adding a contact to the user's XMPP roster.</para>
      </sect2>

      <sect2>
        <title>Presence and online statuses</title>

        <para>One of the biggest advantages of real-time communication tools
        is the fact that one can actually see whether her contacts are
        currently available (i.e. online, logged in) or not. In terms of XMPP
        and Talker, we speak about <emphasis>presence</emphasis><indexterm>
            <primary>presence</primary>
          </indexterm>. Strophe does not provide a convenient way to work with
        presence, but Roster plugin does.<footnote>
            <para>It is the same Roster plugin which handles a roster
            retrieval and processing, mentioned in the previous
            section.</para>
          </footnote></para>

        <para>The presence is processed in a way usual to Strophe: the
        developer provides a callback related to a certain topic, which is
        triggered when anything related to that topic happens. The process of
        binding the callback is described in <xref
        linkend="chap-strophe-plugins" />. When the callback is bound, Strophe
        watches over presence changes sent in a form of presence stanzas from
        a server and hands them over to the assigned callback --
        <computeroutput>onPresenceChange</computeroutput> method -- where the
        presence change is processed.</para>

        <para>The callback function receives two parameters. The first one
        contains the list of all contacts, the second parameter represents the
        information only about the contact whose presence has changed. This is
        a bit tricky because the callback is triggered even if only the
        presence of the currently logged in user changes -- in this case the
        second parameter (i.e. <computeroutput>changed</computeroutput>) is
        undefined.</para>

        <para>The presence is processed in two ways. Firstly, there is basic
        telling online from offline status. The other part is an optional
        online status specifying the availability (away, DND, ...), contained
        in the <computeroutput>&lt;show/&gt;</computeroutput> element of an
        XMPP message. <citation>rfc-3921</citation> The online status is
        processed as well and the current value is stored for each contact.
        Unfortunately, the graphic design for showing statuses has not been
        proposed yet so it is not displayed within the application, yet ready
        to be.</para>

        <para>There is one more glitch about online statuses. XMPP makes it
        possible for the user to be logged in simultaneously from several
        devices. In such case, each session (called a resource in terms of
        XMPP) should state its priority. By changing the priority
        appropriately, it is possible to keep the client running at home and
        yet receive the messages at work by being logged there in with a
        higher priority. In case the contact is logged in from several places
        (i.e. several distinct pieces of presence information are fetched from
        the server), Talker finds the resource with a highest priority and
        processes its online status.</para>

        <para>Another possible approach would be sorting online statuses from
        the most desirable (i.e. online would be the first, then away, ...)
        and looking for the <quote>best</quote> one, regardless of the
        priority. It could actually more correspond to the real state of
        matters because some clients (such as Google Talk client) set always
        the highest priority. However, I decided to keep the rules XMPP
        protocol sets.</para>
      </sect2>

      <sect2>
        <title>Subscriptions</title>

        <para>Subscribing in XMPP basically addresses adding the contacts to
        the contact list and asking them to do the same. On the account of the
        application simplicity, Talker deals with subscriptions automatically.
        When a new contact (i.e. a new contact added in Celebrio) is found,
        the subscription request is sent when Talker starts and loads the
        contact list. In the opposite direction, when a subscription request
        is received, the application tries to find the appropriate contact and
        subscribe too. If no such contact is found, information is logged and
        nothing happens.</para>

        <para>This approach has one big advantage: the user does not have to
        respond to subscription requests and she does not need to send own
        requests either. Yet, there is also one disadvantage, basically the
        same thing from the opposite point of view. The user cannot fully
        control her contact list -- for example to refuse a subscription
        request from the contact in the roster. We decided for this trade off
        to make the application as simple as possible.</para>
      </sect2>
    </sect1>

    <sect1 id="chap-video-calling">
      <title>Video calls</title>

      <para>Providing a simple interface for video calls is one of the goals
      of Talker application. To achieve it, OpenTok library has been used.
      OpenTok is a high-level library from TokBox company, allowing the
      developer to embed video calls support to an arbitrary web application.
      In this section, a basic usage of OpenTok library is described as well
      as the specifics for Talker implementation. OpenTok consists of a
      JavaScript part and a server-side SDK, necessary to initialize a
      session.</para>

      <sect2>
        <title>Initializing OpenTok session</title>

        <para>Before actually working with the OpenTok JavaScript library, the
        application must create a session for a new call that is about to be
        established. Therefore, the JavaScript web application queries a
        server (with an OpenTok SDK running) to generate one. The server-side
        SDK connects to the official OpenTok server<footnote>
            <para><ulink
            url="http://api.opentok.com/hl">http://api.opentok.com/hl</ulink></para>
          </footnote> and retrieves the session. The reason why the request
        cannot be sent directly from JavaScript is a security<indexterm>
            <primary>security</primary>
          </indexterm> -- the server-side SDK proves its identity with a
        unique API secret, issued along with an API key directly by TokBox and
        assigned to every OpenTok application. The process of retrieving a
        session ID is depicted in <xref linkend="fig-opentok-sid" />.</para>

        <figure id="fig-opentok-sid">
          <title>The process of initializing OpenTok session</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/opentok-sid.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Along with the session, a unique token is generated by the
        server-side SDK. It simply constitutes a hash of the session ID,
        timestamp, a client role (either publisher or subscriber) and optional
        user data. Within Talker, the last mentioned field is used for
        distinguishing free users from the premium ones, i.e. handing over the
        additional information to the session. To sum it up, the session ID
        identifies the session (i.e. one call among various number of people,
        typically two) and a token serves as a specific user
        identification.</para>
      </sect2>

      <sect2>
        <title>Using OpenTok JavaScript library</title>

        <para>After including the OpenTok JavaScript file into the
        application, the library is accessible via global
        <computeroutput>TB</computeroutput> object. When the session ID and a
        token are created for the application instance, the actual call can be
        established. The session object is created and the application
        connects to the new session, identifying self with the previously
        issued token:</para>

        <programlisting>var API_KEY = '1234567';
var session = TB.initSession(sessionId);
session.connect(API_KEY, token);</programlisting>

        <para>Even though the previous code would establish the connection, no
        matter what happens with the connection, the application can not
        respond to it. That is the reason why event handlers must be bound to
        the session so the application can respond, for example to someone
        connecting to the same session and sending a stream. Binding an event
        listener looks as follows:</para>

        <programlisting>session.addEventListener("sessionConnected", function (event) {
    subscribeToStreams(event.streams);
    var publisher = TB.initPublisher(API_KEY, 'publishing');
        session.publish(publisher);
    });
};</programlisting>

        <para>In this way, every time something happens within the session,
        the provided callback is triggered.</para>
      </sect2>

      <sect2>
        <title>Interconnection of callers</title>

        <para>Within Talker, the previously described methods are set aside
        along with the code related to video calls into a separate object --
        OpenTokAdapter. The adapter is instantiated for each contact in the
        application since, theoretically, several video calls can take place
        independently. Once a video call is established and an OpenTok session
        is created, the information about the session is sent to the other
        party so that she can join the call.</para>

        <para>We decided to use an ordinary XMPP chat message to inform the
        other side about the call event, because the user of Talker can either
        communicate with someone else using Talker as well or the other party
        can be connected via any other XMPP client. Therefore, the message
        informing about a video call contains a short label
        <computeroutput>Celebrio-CALL</computeroutput>, followed by a link.
        The link contains the information about the session and when clicked
        (in case the other party uses an ordinary IM client, such as Pidgin),
        a new Celebrio window is opened and the user answers the call. This
        separate window has (almost) nothing to do with Celebrio and it could
        be implemented as an independent application as well. It is just a
        substitution of Talker for the contacts not communicating via
        Celebrio.</para>

        <para>When the application receives an incoming call request (in a
        form of the link described above), it parses the request link and
        hence obtains a session ID. The next step is asking the server to
        generate another unique token, which Talker uses for establishing the
        call (i.e. connecting to the session, subscribing to the other party
        stream and publishing its own).</para>
      </sect2>

      <sect2>
        <title>Call states</title>

        <para>Once a call is initiated, it can be either answered or timed
        out. There are 60 seconds within the other side must respond to the
        call. If not answered, the video call is hung up. All possible states
        along with the transition actions are depicted in <xref
        linkend="fig-call-states" />.</para>

        <figure id="fig-call-states">
          <title>Video call states</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/video-calls.pdf" />
            </imageobject>
          </mediaobject>
        </figure>
      </sect2>

      <sect2>
        <title>Embedding the video element</title>

        <para>If the video call is successfully established, two video
        elements must be embedded to the page. One for the user of the
        application to be able to see herself, the other one (the bigger one)
        for displaying the other call participant. OpenTok provides a
        convenient way to create a video element. There is an action listener
        which triggers the following code when the session is connected (i.e.
        when the application connects to the session identified by given
        session ID), creating a video element of the caller (it is referred as
        the video of <quote>me</quote> in the application):</para>

        <programlisting>$("#video").append("&lt;div id='publishing'&gt;&lt;/div&gt;")
var publisher = TB.initPublisher(API_KEY, 'publishing', {
    width: 100,
    height: 80
});</programlisting>

        <para>The previous piece of code creates a new HTML element
        (<computeroutput>#publishing</computeroutput>), in which OpenTok
        embeds the video. Depending on the used library version, either a
        Flash object or an HTML5 video element is created, with the specified
        width and height. The reason why the application creates a wrapper
        element each time a call is established is caused by the library
        removing both video element <emphasis>and</emphasis> its wrapper, when
        the call is hung up (or dismissed after the timeout).</para>

        <para>Creating and an automatic disposal of a video element of the
        other call participant is similar, only it is triggered when a new
        stream is created within the session.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Testing</title>

      <para>Every application is somehow tested during the development. The
      most popular way of doing so is traversing the application manually,
      especially in case of web applications. It is definitely the easiest but
      also not repeatable and thus difficult to scale in large projects.
      Therefore, automatic tests are often used. There are three kinds of
      tests concerning web applications. The most widespread are server-side
      code tests, mostly unit tests. Testing server-side code brings the
      benefit of a predictable and easily modifiable runtime environment.
      However, Talker is a client-side application and therefore server-side
      unit testing is not an option. The other two types of tests, both
      related to Talker, are JavaScript code (unit) tests and user interface
      tests with Selenium, both described below.</para>

      <para>JavaScript unit testing<indexterm>
          <primary>unit test</primary>
        </indexterm> is a relatively new technique, definitely younger than
      classic JUnit tests in Java or PHPUnit in PHP. Earlier, a JavaScript
      application consisted of several action listeners bound to HTML elements
      on a web page. However, hardly did the real application logic move to
      JavaScript when the application code grew bigger. Therefore, it must be
      tested automatically.</para>

      <para>There are several available solutions for unit testing in
      JavaScript. Some solutions cover a whole testing <quote>stack</quote>,
      such as Jasmine or QUnit. On the other hand, there are tools which
      separate the problem of testing (setting up the environment and running
      tests) from assertion, which is responsible for injecting the functions
      which help with checking whether the tested method behaves correctly and
      returns correct values. I believe the separation of concerns is a good
      pattern overall so I have used the tools from the second group:
      Mocha<indexterm>
          <primary>Mocha</primary>
        </indexterm> and Intern<indexterm>
          <primary>Intern</primary>
        </indexterm> -- testing frameworks, both using Chai<indexterm>
          <primary>Chai</primary>
        </indexterm> as the assertion library.</para>

      <para>JavaScript is specific by not having a strictly defined runtime
      environment. Usually, a client-side JavaScript runs in a web browser
      interpreter. However, there are also many tools running with Node.js,
      the JavaScript server-side platform and runtime environment. Since
      Talker is web-based application, it is crucial to have it tested in the
      web browser environment. Most of the solutions described below perform
      the automatic tests in the web browser environment, only plain Mocha
      tests are run with Node.js.</para>

      <para>As a part of this thesis, Talker code has been tested with the
      Intern framework, Mocha unit testing library and JsTestDriver framework.
      In addition, the system tests have been implemented using Selenium
      framework, to check whether the application works as a whole.</para>

      <sect2>
        <title>Chai assertion library</title>

        <para>Before the unit testing frameworks can be described, another
        part of testing must be mentioned. It is the assertion, i.e. checking
        whether the code resulted to the expected values. Both Intern and
        Mocha, testing frameworks described later on (and both used for
        testing Talker), use the assertion library Chai. It provides a
        convenient and easily readable way to check various conditions.</para>

        <para>There are two assertion styles which can be used with Chai: a
        behavior-driven development/descriptions (BDD style) and a test-driven
        ones (TDD). They differ only by syntax, their expression power is
        equal. TDD style looks similarly to JUnit or PHPUnit:
        <citation>chai-api</citation></para>

        <programlisting>assert.include([ 1, 2, 3 ], 3);
assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');</programlisting>

        <para>On the other hand, BDD provides an easy-to-read word chaining,
        resulting to a sentence. The following example of BDD equals the
        previous one (TDD), only the used style differs:
        <citation>chai-api</citation></para>

        <programlisting>expect([1,2,3]).to.include(3);
expect({ tea: { green: 'matcha' }})
    .to.have.deep.property('green.tea', 'matcha');</programlisting>
      </sect2>

      <sect2>
        <title>Unit testing with Intern framework</title>

        <para>Intern is a tool for creating, running and managing JavaScript
        unit tests, all with a minimal need to set up other third party tools
        and environments. Intern can be either installed as a npm<footnote>
            <para>Node.js package</para>
          </footnote> package, from the central repository,<footnote>
            <para><ulink
            url="https://npmjs.org/package/intern">https://npmjs.org/package/intern</ulink></para>
          </footnote> or built manually (which was the only way to install it
        until recently). <citation>intern-blog</citation> After the
        installation, a configuration file must be set up to tell the
        framework where the tests are and how the testing environment should
        look like.</para>

        <para>Similarly as with Chai, the tests can be implemented in two
        syntax ways: TDD and BDD. The following examples are snippets from the
        real tests implemented for Talker, executed with Intern, using BDD
        style. The overall test structure uses Dojo (a library Intern depends
        on, providing the <computeroutput>define</computeroutput> method) and
        it looks as follows:</para>

        <programlisting>define([
  /* load dependencies */
], function (bdd, expect) {
  with (bdd) {

    /* test suite */
    describe('StropheAdapter', function () {
  
      /* before each test */
      beforeEach(function() {
        adapter = new StropheAdapter();
        send = adapter.connection.send;
      });

      /* inner test suite = set of tests */
      describe('#constructor', function () {

        /* test itself, with description */
        it('should do something...', function () {
          /* perform test, make assertions */
        });
      });
    });
  }
});</programlisting>

        <para>First, there are dependencies defined, so the framework loads
        them before the test suite is executed. Almost all JavaScript files
        included in the application are defined here to emulate the
        environment of the application as precisely as possible. The next
        statement tells that the BDD style is going to be used. Later on,
        actual test suites with tests are listed. Each suite can mention
        <computeroutput>before</computeroutput>,
        <computeroutput>beforeEach</computeroutput>,
        <computeroutput>after</computeroutput> and
        <computeroutput>afterEach</computeroutput> functions to be run,
        similarly as other testing frameworks allow. A test itself consists of
        a description label and a test body, defined as an anonymous function.
        The label should describe the test aim and hence identify it. Inside
        the test body function, any code can be executed as well as assertions
        can be carried out.</para>

        <para>JavaScript differs from common programming languages in the way
        the asynchronous code is executed. JavaScript does not provide
        multithreading by default. <citation>js-definitive-guide</citation>
        Hence, the pattern of passing a callback to the asynchronous operation
        is used instead. Unfortunately, it is a nontrivial task to test
        asynchronous code in JavaScript. Intern provides a convenient way to
        do so, using the <emphasis>promises</emphasis><indexterm>
            <primary>promises</primary>
          </indexterm> pattern. The following example tests that
        <computeroutput>start</computeroutput> method connects the application
        to an XMPP server in 10 seconds, using Chai assertion to check
        it.</para>

        <programlisting>it('should connect and call onConnection callback', function () {
    var dfd = this.async(10000);
    adapter.start(dfd.rejectOnError(function (status) {
        if (!(status === Strophe.Status.ATTACHED 
                || status === Strophe.Status.CONNECTED)) {
            return;
        }

        expect(adapter.connection.connected).to.be.true;
        // explicitly resolve the test since 
        // it was successful to this point
        dfd.resolve();
    }));
});</programlisting>

        <para>The callback is handed over to the
        <computeroutput>start</computeroutput> method to be triggered every
        time the connection status changes. This means it is also triggered if
        Strophe only performs the authentication or even if the connection
        fails! Therefore, the promise is resolved (so the test succeeds) only
        if the correct status is passed as an argument.</para>

        <para>It has to be admitted that the previous test is not a real unit
        test, mocking all surrounding objects the function interacts with.
        Considering that the goal of testing is making sure the implemented
        methods work as expected, having it implemented like this is the
        easiest and most straightforward way to achieve the goal. Mocking the
        libraries and network requests would require substantial architecture
        changes in the application, leading to an inappropriate complexity and
        problems for anyone when working with the application <quote>out of
        the box</quote>.</para>
      </sect2>

      <sect2>
        <title>Mocha unit tests</title>

        <para>Mocha<indexterm>
            <primary>Mocha</primary>
          </indexterm> is another framework for creating unit tests in
        JavaScript. The structure of tests is similar to Intern, as well as
        support for the BDD style with
        <computeroutput>describe</computeroutput> and
        <computeroutput>it</computeroutput> keywords. What makes the
        difference is the way Mocha tests are executed and the dependencies
        are loaded. Mocha is more lightweight than Intern, not including any
        configuration files nor environment administration.</para>

        <para>The easiest way to run Mocha is from command line:
        <computeroutput>mocha test-file.js</computeroutput>. However, to be
        able to use Chai to do assertions, each test file must declare it with
        Node <computeroutput>require</computeroutput> function. The unit test
        implemented with Mocha then looks as the following example --
        similarly to the Intern test:</para>

        <programlisting>var expect = require('chai').expect;

describe('StropheAdapter', function(){
    describe('#constructor', function(){
        it('should do something...', function () {
          /* perform test, make assertions */
        });
    })
});</programlisting>
      </sect2>

      <sect2>
        <title>JsTestDriver<indexterm>
            <primary>JsTestDriver</primary>
          </indexterm> framework</title>

        <para>Running Mocha tests in a console with Node brings one huge
        disadvantage. There is no easy option to load custom JavaScript files
        which are necessary to perform the test, unless they are packed as npm
        packages. Therefore, I used another tool called JsTestDriver to wrap
        Mocha tests, load dependencies before executing them and also run them
        in the browser environment.</para>

        <para>JsTestDriver (JSTD) is a Java library allowing the developers to
        run the tests in a certain environment, according to a specified
        configuration file. Although JSTD has not originally been intended to
        be used with Mocha, there is an available adapter which bridges this
        imperfection.<footnote>
            <para><ulink
            url="https://github.com/wikidi/mocha-jstd-adapter">https://github.com/wikidi/mocha-jstd-adapter</ulink></para>
          </footnote> Furthermore, JSTD can be easily run from PHPStorm or
        WebStorm IDEs (with a plugin in the IDE, designed specifically for
        JSTD).</para>

        <para>There is a configuration file for JSTD test suite, specifying
        the scripts to be loaded and test files to be executed, similarly as
        Intern does. The structure is self-explaining:</para>

        <programlisting>load:
  - "lib/mocha.js"
  - "lib/chai.js"
  - "../path/to/../strophe_adapter.js"
test:
  - "test-file.js"</programlisting>

        <para>Mocha and Chai have to be loaded explicitly. Moreover, Mocha and
        Chai must be set up manually in each test file:</para>

        <programlisting>mocha.setup('bdd');
expect = chai.expect;</programlisting>

        <para>Although JSTD looks like a worthwhile tool, I had serious
        problems with keeping it running. A nondeterministic behavior, when
        the same test (a simple test without any side effects, network
        dependencies and so on) sometimes passes and sometimes results in an
        infinite loop never ending the process, makes JSTD almost impossible
        to be used.</para>
      </sect2>

      <sect2>
        <title>Selenium tests<indexterm>
            <primary>Selenium</primary>
          </indexterm></title>

        <para>Testing the functionality of individual methods with unit tests
        or packages with integration tests is usually insufficient. Even if
        all functions and methods worked correctly, it is not guaranteed that
        the application behaves fine as a whole. Therefore, <emphasis>system
        testing</emphasis> comes in handy, here in the form of
        <emphasis>testing user interface</emphasis> actions with the Selenium
        framework.</para>

        <para>Selenium is the user interface testing framework for web
        applications. It traverses the application from the user's point of
        view, performing the same actions as user usually does, directly in a
        web browser. Therefore, a Selenium test suite is more or less just a
        set of instructions -- user actions, that are performed in a certain
        succession (in a web browser environment), written in a custom
        programming language. PHP has been chosen for Talker Selenium tests,
        since whole Celebrio back-end is written in PHP.</para>

        <para>The Selenium framework itself is a Java tool, running on
        background. Java basically starts a server, which serves as a proxy
        and starts a web browser instance. In this web browser instance,
        Selenium tests are run automatically. Selenium could be compared to an
        arbitrary macro tool, recording and replaying user actions.</para>

        <para>There are two versions of Selenium. The older version, Selenium
        1, sometimes also called Selenium RC, basically
        <quote>injected</quote> the tests to a web browser in the form of
        JavaScript functions and then ran them using JavaScript as well. On
        the contrary, Selenium 2, which uses a WebDriver API, drives the
        browser directly using its built-in support for automation.
        <citation>selenium-webdriver</citation> Since the version 2 is more
        lightweight and provides several additional features, it has been used
        as a testing framework for the UI tests in Talker.</para>

        <para>The generic tests functionality, common to a whole system, used
        not only in Talker, is implemented in the
        <computeroutput>SeleniumBase</computeroutput> class. The specific web
        browser the tests will run in is chosen there, along with several
        additional actions mutual to all test suites, not only Talker. The
        other important thing to be handled in the base class is logging in a
        user. Each Selenium test runs separately (there is a usual requirement
        for test independency) so the user has to be logged in before the test
        enters the application itself. Logging the user is implemented in the
        same way as the tests are, so that Selenium opens a web page with the
        login screen, it fills in the user credentials and the login button is
        pressed.</para>

        <para>When the user is logged in, the main specifics of the
        application can be tested. The test suite checks whether the important
        elements are present on a page. Then, it performs basic operations
        such as entering the conversation view and sending a message. The
        tests are implemented within the
        <computeroutput>TalkerTest</computeroutput> class. An example of a
        testing method looks as follows:</para>

        <programlisting>public function testConversationRoute() {
    $this-&gt;signIn();
    $this-&gt;url("app/talker");
    $contact = $this-&gt;byClassName("menu_item_people");
    $contact-&gt;click();
    $this-&gt;assertRegExp('/#\\/conversation\\/\\d+/i', $this-&gt;url());
}</programlisting>

        <para>At the start, the example test method logs the user in and
        enters the Talker application. In fact, the steps copy the standard
        user actions. When the application is loaded, a specific element
        (representing an item in the contact list) is selected and clicked. In
        case the element was missing, the test would fail immediately.
        Finally, the PHPUnit testing and assertion library checks whether the
        URL has been correctly set to a new one, identifying a conversation
        view.</para>

        <para>To keep the tests as much independent as possible, incoming
        actions (such as an incoming message or an answered video call) are
        not incorporated in the test suite. Still, the main aim of the
        Selenium test suite is met. Whenever the application code is changed,
        the test suite ensures that nothing has broken and that the important
        parts have not changed.</para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title>Conclusion</title>

    <para>The thesis embraces the topic of real-time communication in a web
    browser. Several approaches to RTC in a web browser were described,
    including HTTP polling and WebSockets, in the first, theoretical, part.
    Several frameworks were mentioned. From the simple ones such as
    Server-sent events, providing just a thin layer over the HTTP, to the
    complex solutions (e.g. WebRTC or even OpenTok), serving for video calling
    right in a web browser.</para>

    <sect1>
      <title>How the results are used</title>

      <para>It is obvious from the wide range of frameworks, libraries and
      complete solutions that a web browser turns from a web document reader
      into a platform that can host almost any kind of application, including
      real-time ones. Therefore, such an application -- Talker -- has been
      created. It is a real-time communication application serving as an IM
      client for Celebrio, a web-based system for the elderly. Talker
      implements both text chat, using XMPP due to its wide usage and
      interoperability, and video calls, built with OpenTok framework (using
      Flash or HTML5 WebRTC).</para>

      <para>Talker has been designed, implemented, tested and integrated into
      Celebrio. It is part of the production version now and actually one of
      the main reasons users are willing to pay for the system. Hence, the
      thesis goal has not only been reached but in some parts even extended.
      Talker is available in the system<footnote>
          <para>Production version of the system is running at <ulink
          url="http://system.celebriosoftware.com">http://system.celebriosoftware.com</ulink>.</para>
        </footnote> so anyone can try it. Nevertheless, several changes have
      been made recently but they have not been deployed in the system yet.
      Thus, the latest source code is attached to the thesis. It is not
      intended to run alone, without the system.</para>
    </sect1>

    <sect1>
      <title>Future possibilities</title>

      <para>There is still a long way to go until the application is perfect.
      It can be (and certainly will be) updated in many aspects since all used
      frameworks still evolve.</para>

      <para>Version 1.0.0 of Ember.js is about to be released any day now. The
      new version will certainly contain many improvements, both in
      performance and code style. Ember router has been completely reworked
      and additional support for loading data from a server with Ember Data
      framework is available. All of these are definitely worth
      updating.</para>

      <para>Strophe.js is more stable and not evolving so fast. However, it
      might be interesting to use WebSockets instead of sending HTTP long
      polling requests, which are about to be added to the library soon.
      Unofficial implementations already exist and the library author is
      working on a XMPP over WebSockets specification.
      <citation>xmpp-over-websockets</citation> Jingle is about to be added to
      Strophe as well, but maybe in a longer time period.</para>

      <para>Finally, even the application itself may be further enhanced. The
      core concept has been proven and the main features have been
      implemented, yet there are several fancy additions that can be
      introduced. Above all, the already implemented chat states (away, DND,
      ...) are not shown in the user interface yet. This is job which only
      depends on the system graphical designer. Additionally, the chat history
      can be added so the user can see the messages sent and received during
      the previous sessions.</para>

      <para>Because the application has been developed as part of proprietary
      software system Celebrio, it has not been opensourced and it is not
      likely to be. However, the application core could be generalized and
      provided to the community. In that case, adding the XMPP chat and video
      calling to any web application could become just a matter of including
      <quote>Talker component</quote>.</para>

      <para>TODO the possibility of creating independent software component --
      probably opensourced</para>
    </sect1>
  </chapter>

  <bibliography>
    <biblioentry>
      <abbrev>xmpp-the-definitive-guide</abbrev>

      <authorgroup>
        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Kevin</firstname>

          <surname>Smith</surname>
        </author>

        <author>
          <firstname>Remko</firstname>

          <surname>Tronçon</surname>
        </author>
      </authorgroup>

      <title>XMPP: The Definitive Guide</title>

      <subtitle>Building Real-Time Applications with Jabber
      Technologies</subtitle>

      <publisher>
        <publishername>Sebastopol: O'Reilly</publishername>
      </publisher>

      <pubdate>2009</pubdate>

      <isbn>978-0-596-52126-4</isbn>

      <pagenums>310 (7, 13, 14, 16, )</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>definitive-guide-to-ws</abbrev>

      <authorgroup>
        <author>
          <firstname>Vanessa</firstname>

          <surname>Wang</surname>
        </author>

        <author>
          <firstname>Frank</firstname>

          <surname>Salim</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Moskovits</surname>
        </author>
      </authorgroup>

      <title>The Definitive Guide to HTML5 WebSocket</title>

      <subtitle>Build real-time web applications with HTML5</subtitle>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2012</pubdate>

      <isbn>978-1430247401</isbn>

      <pagenums>210 (140, 156, )</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>definitive-guide-to-html5</abbrev>

      <authorgroup>
        <author>
          <firstname>Adam</firstname>

          <surname>Freeman</surname>
        </author>
      </authorgroup>

      <title>The Definitive Guide to HTML5</title>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2011</pubdate>

      <isbn>978-1-4302-3960-4</isbn>

      <pagenums>1080 (880)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>js-definitive-guide</abbrev>

      <authorgroup>
        <author>
          <firstname>David</firstname>

          <surname>Flanagan</surname>
        </author>
      </authorgroup>

      <title>JavaScript: The Definitive Guide</title>

      <publisher>
        <publishername>O'Reilly Media</publishername>
      </publisher>

      <pubdate>2011</pubdate>

      <isbn>978-0-596-80552-4</isbn>

      <pagenums>1100 (320, 322, 333)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>js-enlightnment</abbrev>

      <authorgroup>
        <author>
          <firstname>Cody</firstname>

          <surname>Lindley</surname>
        </author>
      </authorgroup>

      <title>JavaScript Enlightenment</title>

      <publisher>
        <publishername>O'Reilly Media</publishername>
      </publisher>

      <pubdate>2013</pubdate>

      <isbn>978-1449342883</isbn>

      <pagenums>166 (49)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>async-javascript</abbrev>

      <authorgroup>
        <author>
          <firstname>Trevor</firstname>

          <surname>Burnham</surname>
        </author>
      </authorgroup>

      <title>Async JavaScript</title>

      <subtitle>Build More Responsive Apps with Less Code</subtitle>

      <publisher>
        <publishername>The Pragmatic Programmers</publishername>
      </publisher>

      <pubdate>2012</pubdate>

      <isbn>978-1-93778-527-7</isbn>

      <pagenums>104 (3)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>realtime-web-apps</abbrev>

      <authorgroup>
        <author>
          <firstname>Jason</firstname>

          <surname>Lengstorf</surname>
        </author>

        <author>
          <firstname>Phil</firstname>

          <surname>Leggetter</surname>
        </author>
      </authorgroup>

      <title>Realtime Web Apps</title>

      <subtitle>HTML5 WebSocket, Pusher, And The Web's Next Big
      Thing</subtitle>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2013</pubdate>

      <isbn>978-1430246206</isbn>

      <pagenums>400</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>pro-html5-programming</abbrev>

      <authorgroup>
        <author>
          <firstname>Peter</firstname>

          <surname>Lubbers</surname>
        </author>

        <author>
          <firstname>Frank</firstname>

          <surname>Salim</surname>
        </author>

        <author>
          <firstname>Brian</firstname>

          <surname>Albers</surname>
        </author>
      </authorgroup>

      <title>Pro HTML5 Programming</title>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2011</pubdate>

      <isbn>978-1-4302-3864-5</isbn>

      <pagenums>352 (165, ...)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>xmpp-in-javascript</abbrev>

      <authorgroup>
        <author>
          <firstname>Jack</firstname>

          <surname>Moffitt</surname>
        </author>
      </authorgroup>

      <title>Professional XMPP Programming with JavaScript and jQuery</title>

      <publisher>
        <publishername>John Wiley &amp; Sons</publishername>
      </publisher>

      <pubdate>2010</pubdate>

      <isbn>978-0470540718</isbn>

      <pagenums>432 (58, 380, 402)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>ember-in-action</abbrev>

      <authorgroup>
        <author>
          <firstname>Joachim</firstname>

          <othername>Haagen</othername>

          <surname>Skeie</surname>
        </author>
      </authorgroup>

      <title>Ember.js in Action</title>

      <publisher>
        <publishername>Manning Publications</publishername>
      </publisher>

      <pubdate>2013</pubdate>

      <isbn>978-1617291456</isbn>

      <pagenums>325 (21)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>ember-howto</abbrev>

      <authorgroup>
        <author>
          <firstname>Marc</firstname>

          <surname>Bodmer</surname>
        </author>
      </authorgroup>

      <title>Ember.js Application Development How-to</title>

      <publisher>
        <publishername>Packt Publishing</publishername>
      </publisher>

      <pubdate>2013</pubdate>

      <isbn>978-1-78216-338-1</isbn>

      <pagenums>40 (16)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>value-proposition</abbrev>

      <authorgroup>
        <author>
          <firstname>Cindy</firstname>

          <surname>Barnes</surname>
        </author>

        <author>
          <firstname>Helen</firstname>

          <surname>Blake</surname>
        </author>

        <author>
          <firstname>David</firstname>

          <surname>Pinder</surname>
        </author>
      </authorgroup>

      <title>Creating and Delivering Your Value Proposition: Managing Customer
      Experience for Profit</title>

      <publisher>
        <publishername>Kogan Page Publishers</publishername>
      </publisher>

      <pubdate>2009</pubdate>

      <isbn>978-0749458591</isbn>

      <pagenums>232</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>internet-usage</abbrev>

      <author>
        <surname>Miniwatts Marketing Group</surname>
      </author>

      <title>Internet Users in the World - 2012 Q2</title>

      <publisher>
        <publishername>Internet World Stats</publishername>
      </publisher>

      <pubdate>2/17/2013 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.internetworldstats.com/stats.htm">http://www.internetworldstats.com/stats.htm</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>facebook-usage</abbrev>

      <author>
        <firstname>Drew</firstname>

        <surname>Olanoff</surname>
      </author>

      <title>Facebook Announces Monthly Active Users Were At 1.01 Billion As
      Of September 30th</title>

      <publisher>
        <publishername>TechCrunch</publishername>
      </publisher>

      <pubdate>10/23/2012 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://techcrunch.com/2012/10/23/facebook-announces-monthly-active-users-were-at-1-01-billion-as-of-september-30th/">http://techcrunch.com/2012/10/23/facebook-announces-monthly-active-users-were-at-1-01-billion-as-of-september-30th/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ria</abbrev>

      <author>
        <firstname>James</firstname>

        <surname>Ward</surname>
      </author>

      <title>What is a Rich Internet Application?</title>

      <pubdate>10/17/2007 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.jamesward.com/2007/10/17/what-is-a-rich-internet-application/">http://www.jamesward.com/2007/10/17/what-is-a-rich-internet-application/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>elderly-questionnaires</abbrev>

      <authorgroup>
        <author>
          <firstname>Pavel</firstname>

          <surname>Smolka</surname>
        </author>

        <author>
          <firstname>Martin</firstname>

          <surname>Novák</surname>
        </author>
      </authorgroup>

      <title>Elderly people and the computers</title>

      <pubdate>2/11/2013 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://infogr.am/Seniori-a-pocitace">http://infogr.am/Seniori-a-pocitace</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>aol-trademarks</abbrev>

      <authorgroup>
        <author>
          <surname>AOL Inc.</surname>
        </author>
      </authorgroup>

      <title>AOL Trademark List</title>

      <pubdate>3/15/2011 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://legal.aol.com/trademarks/">http://legal.aol.com/trademarks/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xmpp-history</abbrev>

      <authorgroup>
        <author>
          <surname>The XMPP Standards Foundation</surname>
        </author>
      </authorgroup>

      <title>History of XMPP</title>

      <pubdate>1/27/2010 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://legal.aol.com/trademarks/">http://xmpp.org/about-xmpp/history/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>gtalk</abbrev>

      <authorgroup>
        <author>
          <surname>Google Developers</surname>
        </author>
      </authorgroup>

      <title>Google Talk Developer Documentation</title>

      <pubdate>3/23/2012 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://developers.google.com/talk/talk_developers_home">https://developers.google.com/talk/talk_developers_home</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>fb-chat</abbrev>

      <authorgroup>
        <author>
          <surname>Facebook Developers</surname>
        </author>
      </authorgroup>

      <title>Facebook Chat API</title>

      <pubdate>2/12/2013 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://legal.aol.com/trademarks/">http://xmpp.org/about-xmpp/history/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>brian-stats-tweet</abbrev>

      <authorgroup>
        <author>
          <surname>Staatss, B. (Brianstaats)</surname>
        </author>
      </authorgroup>

      <title><quote>If you have to customize 1/5 of a reusable component, its
      likely better to write it from scratch @trek at
      #embercamp</quote></title>

      <pubdate>2/15/2013 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>Tweet</releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>fb-erlang</abbrev>

      <author>
        <firstname>Eugene</firstname>

        <surname>Letuchy</surname>
      </author>

      <title>Facebook Chat</title>

      <pubdate>5/14/2008 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://www.facebook.com/note.php?note_id=14218138919">https://www.facebook.com/note.php?note_id=14218138919</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>skype-license</abbrev>

      <author>
        <firstname>Allen</firstname>

        <surname>Smith</surname>
      </author>

      <title>Does SkypeKit work on Android?</title>

      <subtitle>Forum post</subtitle>

      <pubdate>8/7/2012 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://devforum.skype.com/t5/SkypeKit-FAQs/Does-SkypeKit-work-on-Android/m-p/16490/thread-id/78">http://devforum.skype.com/t5/SkypeKit-FAQs/Does-SkypeKit-work-on-Android/m-p/16490/thread-id/78</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>skype-uri</abbrev>

      <author>
        <surname>Microsoft</surname>
      </author>

      <title>Skype URIs</title>

      <pubdate>2013 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://dev.skype.com/skype-uri">http://dev.skype.com/skype-uri</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-http</abbrev>

      <authorgroup>
        <author>
          <firstname>Roy</firstname>

          <othername>Thomas</othername>

          <surname>Fielding</surname>
        </author>

        <author>
          <firstname>James</firstname>

          <surname>Gettis</surname>
        </author>

        <author>
          <firstname>Jeffrey</firstname>

          <surname>Mogul</surname>
        </author>

        <author>
          <firstname>Henrik</firstname>

          <surname>Frystyk</surname>
        </author>

        <author>
          <firstname>Larry</firstname>

          <surname>Masinter</surname>
        </author>

        <author>
          <firstname>Paul</firstname>

          <surname>Leach</surname>
        </author>

        <author>
          <firstname>Tim</firstname>

          <surname>Berners-Lee</surname>
        </author>
      </authorgroup>

      <title>Hypertext Transfer Protocol -- HTTP/1.1</title>

      <subtitle>Request for Comments: 2616</subtitle>

      <pubdate>6/1999 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http://www.w3.org/Protocols/rfc2616/rfc2616.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>apache-core-features</abbrev>

      <author>
        <surname>The Apache Software Foundation</surname>
      </author>

      <title>Apache Core Features</title>

      <pubdate>2013 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://httpd.apache.org/docs/2.2/mod/core.html">http://httpd.apache.org/docs/2.2/mod/core.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-bidirectional-http</abbrev>

      <authorgroup>
        <author>
          <firstname>Salvatore</firstname>

          <surname>Loreto</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Stefano</firstname>

          <surname>Salsano</surname>
        </author>

        <author>
          <firstname>Greg</firstname>

          <surname>Wilkins</surname>
        </author>
      </authorgroup>

      <title>Known Issues and Best Practices for the Use of Long Polling and
      Streaming in Bidirectional HTTP</title>

      <subtitle>Request for Comments: 6202</subtitle>

      <pubdate>4/2011 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.ietf.org/rfc/rfc6202.txt">http://www.ietf.org/rfc/rfc6202.txt</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-ws</abbrev>

      <authorgroup>
        <author>
          <firstname>Ian</firstname>

          <surname>Fette</surname>
        </author>

        <author>
          <firstname>Alexey</firstname>

          <surname>Melnikov</surname>
        </author>
      </authorgroup>

      <title>The WebSocket Protocol</title>

      <subtitle>Request for Comments: 6455</subtitle>

      <pubdate>12/2011 [retrieved 2/24/2013]</pubdate>

      <publisher>
        <publishername>Internet Engineering Task Force (IETF)</publishername>
      </publisher>

      <issn>2070-1721</issn>

      <releaseinfo>from <ulink
      url="http://tools.ietf.org/html/rfc6455">http://tools.ietf.org/html/rfc6455</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-proxy</abbrev>

      <author>
        <firstname>Peter</firstname>

        <surname>Lubbers</surname>
      </author>

      <title>How HTML5 Web Sockets Interact With Proxy Servers</title>

      <subtitle>Request for Comments: 6455</subtitle>

      <pubdate>3/16/2011 [retrieved 2/24/2013]</pubdate>

      <publisher>
        <publishername>InfoQ</publishername>
      </publisher>

      <issn>2070-1721</issn>

      <releaseinfo>from <ulink
      url="http://tools.ietf.org/html/rfc6455">http://tools.ietf.org/html/rfc6455</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-api</abbrev>

      <author>
        <firstname>Ian</firstname>

        <surname>Hickson</surname>
      </author>

      <title>The WebSocket API</title>

      <subtitle>Editor's Draft</subtitle>

      <pubdate>2/9/2013 [retrieved 2/24/2013]</pubdate>

      <publisher>
        <publishername>W3C</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://dev.w3.org/html5/websockets/">http://dev.w3.org/html5/websockets/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>mozilla-ws</abbrev>

      <author>
        <surname>Mozilla Developers</surname>
      </author>

      <title>WebSockets</title>

      <pubdate>2/4/2013 [retrieved 2/25/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://developer.mozilla.org/en-US/docs/WebSockets">https://developer.mozilla.org/en-US/docs/WebSockets</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-html5rocks</abbrev>

      <authorgroup>
        <author>
          <firstname>Malte</firstname>

          <surname>Ubl</surname>
        </author>

        <author>
          <firstname>Eiji</firstname>

          <surname>Kitamura</surname>
        </author>
      </authorgroup>

      <title>Introducing WebSockets: Bringing Sockets to the Web</title>

      <pubdate>2/13/2012 [retrieved 2/25/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.html5rocks.com/en/tutorials/websockets/basics/">http://www.html5rocks.com/en/tutorials/websockets/basics/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-iana</abbrev>

      <author>
        <surname>IANA</surname>
      </author>

      <title>WebSocket Protocol Registries</title>

      <pubdate>11/13/2012 [retrieved 2/25/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.iana.org/assignments/websocket/websocket.xml">http://www.iana.org/assignments/websocket/websocket.xml</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-caniuse</abbrev>

      <author>
        <surname>StatCounter GlobalStats</surname>
      </author>

      <title>Can I use Web Sockets?</title>

      <pubdate>2/2013 [retrieved 3/3/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://caniuse.com/websockets">http://caniuse.com/websockets</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ie-statistics</abbrev>

      <author>
        <surname>Terabyte Media</surname>
      </author>

      <title>Web Browser Usage Statistics</title>

      <pubdate>12/2012 [retrieved 3/3/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.statowl.com/web_browser_usage_by_version.php?limit%5B%5D=ie">http://www.statowl.com/web_browser_usage_by_version.php?limit%5B%5D=ie</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0124</abbrev>

      <authorgroup>
        <author>
          <firstname>Ian</firstname>

          <surname>Paterson</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Dave</firstname>

          <surname>Smith</surname>
        </author>

        <author>
          <firstname>Jack</firstname>

          <surname>Moffit</surname>
        </author>
      </authorgroup>

      <title>XEP-0124: Bidirectional-streams Over Synchronous HTTP
      (BOSH)</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2010 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0124.html">http://xmpp.org/extensions/xep-0124.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0025</abbrev>

      <authorgroup>
        <author>
          <firstname>Joe</firstname>

          <surname>Hildebrand</surname>
        </author>

        <author>
          <firstname>Craig</firstname>

          <surname>Kaes</surname>
        </author>

        <author>
          <firstname>David</firstname>

          <surname>Waite</surname>
        </author>
      </authorgroup>

      <title>XEP-0025: Jabber HTTP Polling</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2009 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0025.html">http://xmpp.org/extensions/xep-0025.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0206</abbrev>

      <authorgroup>
        <author>
          <firstname>Ian</firstname>

          <surname>Paterson</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>
      </authorgroup>

      <title>XEP-0206: XMPP Over BOSH</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2010 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0206.html">http://xmpp.org/extensions/xep-0206.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>setting-up-bosh</abbrev>

      <author>
        <surname>Prosody</surname>
      </author>

      <title>Setting up a BOSH server</title>

      <pubdate>[retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://prosody.im/doc/setting_up_bosh">http://prosody.im/doc/setting_up_bosh</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xmpp-over-websockets</abbrev>

      <author>
        <firstname>Jack</firstname>

        <surname>Moffit</surname>
      </author>

      <title>An XMPP Sub-protocol for WebSocket</title>

      <pubdate>2/25/2013 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://datatracker.ietf.org/doc/draft-moffitt-xmpp-over-websocket/">http://datatracker.ietf.org/doc/draft-moffitt-xmpp-over-websocket/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>google-closing-xmpp</abbrev>

      <author>
        <firstname>John</firstname>

        <surname>Sullivan</surname>
      </author>

      <title>Google backslides on federated instant messaging, on
      purpose?</title>

      <pubdate>3/15/2013 [retrieved 3/31/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://www.fsf.org/blogs/sysadmin/google-backslides-on-federated-instant-messaging-on-purpose">https://www.fsf.org/blogs/sysadmin/google-backslides-on-federated-instant-messaging-on-purpose</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>spammy-invites</abbrev>

      <author>
        <firstname>Per</firstname>

        <surname>Gustafsson</surname>
      </author>

      <title>Spammy invites</title>

      <pubdate>2/13/2013 [retrieved 3/31/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://mail.jabber.org/pipermail/operators/2013-February/001571.html">http://mail.jabber.org/pipermail/operators/2013-February/001571.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0166</abbrev>

      <authorgroup>
        <author>
          <firstname>Scott</firstname>

          <surname>Ludwig</surname>
        </author>

        <author>
          <firstname>Joe</firstname>

          <surname>Beda</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Robert</firstname>

          <surname>McQueen</surname>
        </author>

        <author>
          <firstname>Sean</firstname>

          <surname>Egan</surname>
        </author>

        <author>
          <firstname>Joe</firstname>

          <surname>Hildebrand</surname>
        </author>
      </authorgroup>

      <title>XEP-0166: Jingle</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2009 [retrieved 3/31/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0166.html">http://xmpp.org/extensions/xep-0166.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>libjingle</abbrev>

      <author>
        <surname>Google Developers</surname>
      </author>

      <title>About libjingle</title>

      <pubdate>3/23/2012 [retrieved 3/31/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://developers.google.com/talk/libjingle/">https://developers.google.com/talk/libjingle/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>jingle-is-the-future</abbrev>

      <author>
        <firstname>Dave</firstname>

        <surname>Cridland</surname>
      </author>

      <title>Google: <quote>The Future is Jingle</quote></title>

      <pubdate>6/23/2011 [retrieved 3/31/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/2011/06/the-future-is-jingle/">http://xmpp.org/2011/06/the-future-is-jingle/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>flash-bundled-with-chrome</abbrev>

      <author>
        <firstname>Robin</firstname>

        <surname>Wauters</surname>
      </author>

      <title>Flash Player To Come Bundled With Google Chrome, New Browser
      Plugin API Coming</title>

      <publisher>
        <publishername>TechCrunch</publishername>
      </publisher>

      <pubdate>3/30/2010 [retrieved 4/5/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://techcrunch.com/2010/03/30/flash-player-to-come-bundled-with-google-chrome-new-browser-plugin-api-coming/">http://techcrunch.com/2010/03/30/flash-player-to-come-bundled-with-google-chrome-new-browser-plugin-api-coming/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>android-flash-support</abbrev>

      <author>
        <firstname>Geoff</firstname>

        <surname>Wauters</surname>
      </author>

      <title>Adobe Flash for Android: Gone with barely a whimper</title>

      <publisher>
        <publishername>Digital Trends</publishername>
      </publisher>

      <pubdate>8/17/2012 [retrieved 4/5/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.digitaltrends.com/mobile/adobe-flash-for-android-gone-with-barely-a-whimper/">http://www.digitaltrends.com/mobile/adobe-flash-for-android-gone-with-barely-a-whimper/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>iphone-flash-support</abbrev>

      <author>
        <surname>Apple Support Team</surname>
      </author>

      <title>Does the iPhone support Flash?</title>

      <pubdate>2007 [retrieved 4/5/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.iphonefaq.org/archives/9730">http://www.iphonefaq.org/archives/9730</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>signalr</abbrev>

      <author>
        <firstname>Damian</firstname>

        <surname>Edwards</surname>
      </author>

      <title>SignalR FAQ</title>

      <publisher>
        <publishername>GitHub</publishername>
      </publisher>

      <pubdate>9/7/2012 [retrieved 4/5/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://github.com/SignalR/SignalR/wiki/Faq">https://github.com/SignalR/SignalR/wiki/Faq</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>sse-api</abbrev>

      <author>
        <firstname>Ian</firstname>

        <surname>Hickson</surname>
      </author>

      <title>Server-Sent Events</title>

      <subtitle>Editor's Draft</subtitle>

      <pubdate>3/29/2013 [retrieved 4/5/2013]</pubdate>

      <publisher>
        <publishername>W3C</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://dev.w3.org/html5/eventsource/">http://dev.w3.org/html5/eventsource/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>sse-multiline</abbrev>

      <author>
        <firstname>Remy</firstname>

        <surname>Sharp</surname>
      </author>

      <title>Server-Sent Events</title>

      <subtitle>Editor's Draft</subtitle>

      <pubdate>1/24/2012 [retrieved 4/5/2013]</pubdate>

      <publisher>
        <publishername>HTML5Doctor</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://html5doctor.com/server-sent-events/">http://html5doctor.com/server-sent-events/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>bayeux</abbrev>

      <authorgroup>
        <author>
          <firstname>Alex</firstname>

          <surname>Russell</surname>
        </author>

        <author>
          <firstname>Greg</firstname>

          <surname>Wilkins</surname>
        </author>

        <author>
          <firstname>David</firstname>

          <surname>Davis</surname>
        </author>

        <author>
          <firstname>Mark</firstname>

          <surname>Nesbitt</surname>
        </author>
      </authorgroup>

      <title>The Bayeux Specification</title>

      <pubdate>2007 [retrieved 4/5/2013]</pubdate>

      <publisher>
        <publishername>The Dojo Foundation</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://svn.cometd.org/trunk/bayeux/bayeux.html">http://svn.cometd.org/trunk/bayeux/bayeux.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-signaling</abbrev>

      <author>
        <firstname>Sam</firstname>

        <surname>Dutton</surname>
      </author>

      <title>Getting Started with WebRTC</title>

      <pubdate>7/23/2012 [retrieved 4/6/2013]</pubdate>

      <publisher>
        <publishername>HTML5 Rocks</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://www.html5rocks.com/en/tutorials/webrtc/basics/">http://www.html5rocks.com/en/tutorials/webrtc/basics/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-rfc</abbrev>

      <authorgroup>
        <author>
          <firstname>Adam</firstname>

          <surname>Bergkvist</surname>
        </author>

        <author>
          <firstname>Daniel</firstname>

          <surname>Burnett</surname>
        </author>

        <author>
          <firstname>Cullen</firstname>

          <surname>Jennings</surname>
        </author>

        <author>
          <firstname>Anant</firstname>

          <surname>Narayanan</surname>
        </author>
      </authorgroup>

      <title>WebRTC 1.0: Real-time Communication Between Browsers</title>

      <subtitle>Editor's Draft</subtitle>

      <pubdate>3/22/2013 [retrieved 4/6/2013]</pubdate>

      <publisher>
        <publishername>W3C</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://dev.w3.org/2011/webrtc/editor/webrtc.html">http://dev.w3.org/2011/webrtc/editor/webrtc.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ice</abbrev>

      <authorgroup>
        <author>
          <firstname>Jonathan</firstname>

          <surname>Rosenberg</surname>
        </author>

        <author>
          <firstname>Ari</firstname>

          <surname>Keranen</surname>
        </author>

        <author>
          <firstname>Bruce</firstname>

          <surname>Lowekamp</surname>
        </author>

        <author>
          <firstname>Adam</firstname>

          <surname>Roach</surname>
        </author>
      </authorgroup>

      <title>TCP Candidates with Interactive Connectivity Establishment
      (ICE)</title>

      <pubdate>5/18/2012 [retrieved 4/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://tools.ietf.org/html/draft-ietf-mmusic-ice-tcp-16">http://tools.ietf.org/html/draft-ietf-mmusic-ice-tcp-16</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-interop</abbrev>

      <authorgroup>
        <author>
          <firstname>Maire</firstname>

          <surname>Reavy</surname>
        </author>

        <author>
          <firstname>Serge</firstname>

          <surname>Lachapelle</surname>
        </author>
      </authorgroup>

      <title>Hello Firefox, this is Chrome calling!</title>

      <pubdate>2/4/2013 [retrieved 4/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://blog.chromium.org/2013/02/hello-firefox-this-is-chrome-calling.html">http://blog.chromium.org/2013/02/hello-firefox-this-is-chrome-calling.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-ericsson</abbrev>

      <authorgroup>
        <author>
          <firstname>Stefan</firstname>

          <surname>Alund</surname>
        </author>
      </authorgroup>

      <title>Bowser – The World’s First WebRTC-Enabled Mobile Browser</title>

      <pubdate>10/19/2012 [retrieved 4/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://labs.ericsson.com/blog/bowser-the-world-s-first-webrtc-enabled-mobile-browser">https://labs.ericsson.com/blog/bowser-the-world-s-first-webrtc-enabled-mobile-browser</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-ms</abbrev>

      <authorgroup>
        <author>
          <firstname>Bernard</firstname>

          <surname>Aboba</surname>
        </author>

        <author>
          <firstname>Martin</firstname>

          <surname>Thomson</surname>
        </author>
      </authorgroup>

      <title>Customizable, Ubiquitous Real Time Communication over the Web
      (CU-RTC-Web)</title>

      <pubdate>8/9/2012 [retrieved 4/6/2013]</pubdate>

      <publisher>
        <publishername>Microsoft</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://html5labs.interoperabilitybridges.com/cu-rtc-web/cu-rtc-web.htm">http://html5labs.interoperabilitybridges.com/cu-rtc-web/cu-rtc-web.htm</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-skype</abbrev>

      <authorgroup>
        <author>
          <firstname>Janko</firstname>

          <surname>Roettgers</surname>
        </author>
      </authorgroup>

      <title>Scoop: Microsoft bets on WebRTC for Skype’s browser
      future</title>

      <pubdate>6/26/2012 [retrieved 4/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://gigaom.com/2012/06/26/skype-webrtc-web-client/">http://gigaom.com/2012/06/26/skype-webrtc-web-client/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc4all</abbrev>

      <authorgroup>
        <author>
          <surname>Doubango Telecom</surname>
        </author>
      </authorgroup>

      <title>webrtc4all</title>

      <pubdate>2012 [retrieved 4/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://code.google.com/p/webrtc4all/">https://code.google.com/p/webrtc4all/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>jquery-api</abbrev>

      <authorgroup>
        <author>
          <surname>The jQuery Foundation</surname>
        </author>
      </authorgroup>

      <title>jQuery API Documentation</title>

      <pubdate>2013 [retrieved 4/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://api.jquery.com/append/">http://api.jquery.com/append/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>strophe-api</abbrev>

      <authorgroup>
        <author>
          <firstname>Jack</firstname>

          <surname>Moffitt</surname>
        </author>
      </authorgroup>

      <title>Strophe.js API Documentation</title>

      <pubdate>2013 [retrieved 4/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://strophe.im/strophejs/doc/1.0.2/files2/strophe-js.html">http://strophe.im/strophejs/doc/1.0.2/files2/strophe-js.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>attached-to-strophe</abbrev>

      <authorgroup>
        <author>
          <firstname>Jack</firstname>

          <surname>Moffitt</surname>
        </author>
      </authorgroup>

      <title>Getting Attached To Strophe</title>

      <pubdate>8/3/2008 [retrieved 4/15/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://metajack.im/2008/10/03/getting-attached-to-strophe/">http://metajack.im/2008/10/03/getting-attached-to-strophe/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>fat-model-skinny-controller</abbrev>

      <authorgroup>
        <author>
          <firstname>Jon</firstname>

          <surname>Cairns</surname>
        </author>
      </authorgroup>

      <title><quote>Fat model, skinny controller</quote> is a load of
      rubbish</title>

      <pubdate>4/11/2013 [retrieved 4/21/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://joncairns.com/2013/04/fat-model-skinny-controller-is-a-load-of-rubbish/">http://joncairns.com/2013/04/fat-model-skinny-controller-is-a-load-of-rubbish/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>yehuda-talk</abbrev>

      <authorgroup>
        <author>
          <firstname>Yehuda</firstname>

          <surname>Katz</surname>
        </author>
      </authorgroup>

      <title>Building Web Applications with Ember.js</title>

      <pubdate>4/13/2013 [retrieved 4/26/2013]</pubdate>

      <publisher>
        <publishername>YouTube</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://www.youtube.com/watch?v=u6RFyVN9sNg">http://www.youtube.com/watch?v=u6RFyVN9sNg</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>new-dev-era</abbrev>

      <authorgroup>
        <author>
          <firstname>Tarek</firstname>

          <surname>Ziadé</surname>
        </author>
      </authorgroup>

      <title>A new development era (essay)</title>

      <pubdate>1/25/2013 [retrieved 4/26/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://blog.ziade.org/2013/01/25/a-new-development-era-essay/">http://blog.ziade.org/2013/01/25/a-new-development-era-essay/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-3921</abbrev>

      <authorgroup>
        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>
      </authorgroup>

      <title>Extensible Messaging and Presence Protocol (XMPP): Instant
      Messaging and Presence</title>

      <pubdate>2004 [retrieved 5/4/2013]</pubdate>

      <publisher>
        <publishername>Jabber Software Foundation</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://xmpp.org/rfcs/rfc3921.html">http://xmpp.org/rfcs/rfc3921.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>intern-blog</abbrev>

      <authorgroup>
        <author>
          <firstname>Paul</firstname>

          <surname>Bouchon</surname>
        </author>
      </authorgroup>

      <title>Meet your newest Intern</title>

      <pubdate>5/1/2013 [retrieved 5/4/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.sitepen.com/blog/2013/05/01/intern-javascript-testing/">http://www.sitepen.com/blog/2013/05/01/intern-javascript-testing/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>chai-api</abbrev>

      <authorgroup>
        <author>
          <firstname>Jake</firstname>

          <surname>Luer</surname>
        </author>
      </authorgroup>

      <title>Chai API</title>

      <pubdate>2013 [retrieved 5/4/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://chaijs.com/api/">http://chaijs.com/api/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>spammy-invites-update</abbrev>

      <authorgroup>
        <author>
          <firstname>Per</firstname>

          <surname>Gustafsson</surname>
        </author>
      </authorgroup>

      <title>Update on spammy invites</title>

      <pubdate>5/4/2013 [retrieved 5/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://mail.jabber.org/pipermail/operators/2013-April/001672.html">http://mail.jabber.org/pipermail/operators/2013-April/001672.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>opentok-pricing</abbrev>

      <authorgroup>
        <author>
          <surname>TokBox Inc.</surname>
        </author>
      </authorgroup>

      <title>OpenTok pricing</title>

      <pubdate>2013 [retrieved 5/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.tokbox.com/pricing">http://www.tokbox.com/pricing</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>opentok-server-side-lib</abbrev>

      <authorgroup>
        <author>
          <surname>TokBox Inc.</surname>
        </author>
      </authorgroup>

      <title>OpenTok server-side libraries reference</title>

      <pubdate>2013 [retrieved 5/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.tokbox.com/opentok/docs/server/server_side_libraries.html">http://www.tokbox.com/opentok/docs/server/server_side_libraries.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ssdp-udp</abbrev>

      <authorgroup>
        <author>
          <firstname>Alan</firstname>

          <surname>Presser</surname>
        </author>

        <author>
          <firstname>Lee</firstname>

          <surname>Farrell</surname>
        </author>

        <author>
          <firstname>Devon</firstname>

          <surname>Kemp</surname>
        </author>

        <author>
          <firstname>William</firstname>

          <surname>Lupton</surname>
        </author>

        <author>
          <firstname>Shinichi</firstname>

          <surname>Tsuruyama</surname>
        </author>

        <author>
          <firstname>Shivaun</firstname>

          <surname>Albright</surname>
        </author>
      </authorgroup>

      <title>UPnP Device Architecture</title>

      <pubdate>10/15/2008 [retrieved 5/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.1.pdf">http://www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.1.pdf</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>selenium-webdriver</abbrev>

      <authorgroup>
        <author>
          <surname>Selenium Project Authors</surname>
        </author>
      </authorgroup>

      <title>Selenium WebDriver</title>

      <pubdate>5/17/2013 [retrieved 5/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://docs.seleniumhq.org/docs/03_webdriver.jsp">http://docs.seleniumhq.org/docs/03_webdriver.jsp</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>new-hangouts</abbrev>

      <authorgroup>
        <author>
          <firstname>Sean</firstname>

          <surname>Gallagher</surname>
        </author>
      </authorgroup>

      <title>Hands on with Hangouts, Google’s new text and video chat
      architecture</title>

      <pubdate>5/17/2013 [retrieved 5/20/2013]</pubdate>

      <publisher>
        <publishername>Ars Technica</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://arstechnica.com/information-technology/2013/05/hands-on-with-hangouts-googles-new-text-and-video-chat-architecture/">http://arstechnica.com/information-technology/2013/05/hands-on-with-hangouts-googles-new-text-and-video-chat-architecture/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ember-router</abbrev>

      <authorgroup>
        <author>
          <surname>Tilde, Inc.</surname>
        </author>
      </authorgroup>

      <title>Specifying a route's model</title>

      <pubdate>2013 [retrieved 5/21/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://emberjs.com/guides/routing/specifying-a-routes-model/">http://emberjs.com/guides/routing/specifying-a-routes-model/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>domenic-promises</abbrev>

      <authorgroup>
        <author>
          <firstname>Domenic</firstname>

          <surname>Denicola</surname>
        </author>
      </authorgroup>

      <title>Callbacks, Promises, and Coroutines</title>

      <pubdate>2013 [retrieved 5/20/2013]</pubdate>

      <publisher>
        <publishername>Slideshare</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript">http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript</ulink></releaseinfo>
    </biblioentry>
  </bibliography>

  <index></index>

  <appendix id="appendix-screenshots">
    <title>Screenshots of the application</title>

    <para>TODO Some screenshots from Celebrio Talker</para>
  </appendix>
</book>
