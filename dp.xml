<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!--[
<!ENTITY % fithesis SYSTEM "http://www.fi.muni.cz/~xpavlov/fithesis.mod">
%fithesis;
]>
-->
<book lang="en">
  <bookinfo>
    <title>Real-time Communication \\* in Web Browser</title>

    <subtitle>Master thesis</subtitle>

    <author>
      <firstname>Pavel</firstname>

      <surname>Smolka</surname>

      <fi:woman
      xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">false</fi:woman>

      <fi:faculty
      xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">fi</fi:faculty>

      <fi:advisor xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">doc.
      RNDr. Tomáš Pitner, Ph.D.</fi:advisor>
    </author>

    <fi:thanks xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">Thanks to
    everyone... TODO: Petr Kunc (help with OpenTok &amp; RealTime
    communication). Thanks Káťa for cooking and being patient while I was
    typing the thesis regularly up to 3 AM</fi:thanks>

    <pubdate>2013</pubdate>

    <abstract>
      <para>TODO</para>
    </abstract>

    <keywordset>
      <keyword>XMPP</keyword>

      <keyword>real-time communication</keyword>

      <keyword>RTC</keyword>

      <keyword>Celebrio</keyword>

      <keyword>web browser</keyword>

      <keyword>HTTP</keyword>

      <keyword>Comet</keyword>

      <keyword>JavaScript</keyword>

      <keyword>WebSockets</keyword>

      <keyword>BOSH</keyword>

      <keyword>Ember</keyword>

      <keyword>Strophe</keyword>

      <keyword>OpenTok</keyword>

      <keyword>TODO</keyword>
    </keywordset>
  </bookinfo>

  <toc></toc>

  <chapter id="uvod">
    <title>Introduction</title>

    <para>Millions, billions, trillions. That many and even more messages are
    exchanged every day between various people over the world. The Internet
    created brand new way to communicate and collaborate, even if you are
    located on the opposite parts of the world. Since the times of Alexander
    Graham Bell, the accessibility to the communication devices and their
    simplicity incredibly enhanced. Nowadays, almost 2.5 billion people over
    the world have access to the Internet and therefore they are able to use
    almost limitless communication possibilities it provides.
    <citation>internet-usage</citation></para>

    <para>However, the manner of Internet usage essentially changed during the
    first decade of 21st century. Using the Internet and using the web browser
    became almost synonyms. People use the web browser as the primary platform
    to do every single task on the Internet. Sometimes it's not even possible
    to use the other Internet services without visiting certain web page in
    the web browser and performing the authentication there.<footnote>
        <para>Two examples of such behavior. Wi-fi network in the Student
        Agency coaches forces the user to visit the entry page in the web
        browser. The second example, very well known to the students of the
        Faculty of Informatics at Masaryk University, is the faculty wireless
        network called wlan_fi. Every user has to open the web browser and log
        in with her credentials. It's not possible just to open the terminal
        or e-mail client and start working online.</para>
      </footnote> Considering the mentioned fact, web browsers became also the
    basic platform for the communication tools. Even though the purpose of the
    world wide web and HTTP protocol was completely different at first
    (displaying single documents connected via hypertext links), it appeared
    that there is the need of common rich applications running withing web
    browser - rich Internet application sprung up. <citation>ria</citation> So
    popular social networks are built on top of the web browser platform and
    they are used by more than billion people over the world.
    <citation>facebook-usage</citation> And the main reason why the social
    networks are so popular is the real-time stream of news and messages from
    the other people. By the beginning of the year 2013, I would say that
    static web is dead - users prefer interactivity.</para>

    <para>This thesis embraces the topic of real-time applications in web
    browsers, especially the text communication tools and the technologies
    being used to develop them. It also describes the problem of
    <quote>inter-process</quote> communication between various web pages which
    need to cooperate and exchange information as quickly as possible.
    Finally, the possibilities of multimedia content transfer (audio and
    video) and the current options of capturing multimedia directly from the
    web browser are described as well.</para>

    <para>As mentioned above, the web browser became one of the most popular
    platforms. Celebrio, simple software for the elderly simulating the
    operating system interface, is typical example of rich Internet
    application. <citation>celebrio-system</citation> All the topics mentioned
    in the previous paragraph appeared to be very important in the system.
    When interviewing the elderly people in the Czech Republic, it appeared
    that almost 90 % of the elderly computer users use the real-time
    communication (RTC) applications, mostly Skype.
    <citation>elderly-questionnaires</citation> Interaction with their loved
    ones is the most desired benefit they expect from the computer. Therefore,
    creating real-time application, text messenger supporting video calling,
    became not only programming challenge but also a business goal.</para>

    <para>TODO: rework this a bit. Mention all RTC tools, not only web based.
    Mention more history:</para>

    <para>Considering the fact the people like real-time communication (not
    only direct messaging but also real-time cooperation, simultaneous
    document editing or playing multiplayer games) while using web browser
    brings us the question what the currently available solutions are. There
    are <quote>big players</quote> providing their own services as
    closed-source, without the possibility to use them. To name the most
    important, it's Google Talk web browser client and Facebook chat, using
    XMPP protocol. <citation>gtalk</citation><citation>fb-chat</citation> Even
    though Facebook chat service is not pure XMPP server implementation (the
    message and presence engine is proprietary system of Facebook implemented
    mostly in C++ and Erlang), they provide the possibility to connect to the
    <quote>world of Facebook Chat</quote> via XMPP as proxy.
    <citation>fb-erlang</citation> Combination of the facts that XMPP is open
    technology with open-sourced client and server implementations
    <citation>xmpp-history</citation> and the big Internet companies also use
    it persuaded us to use it in our communication application too. XMPP
    itself and its usage in web applications is described in <xref
    linkend="chap-xmpp" />.</para>

    <para>Since the web browser was designed to perform simple
    requests/response interaction, it is not a typical platform for building
    real-time application. Thus, there is a need for an extra layer enhancing
    or even completely replacing the common way HTTP communicates. Within the
    scope of this thesis, namely the WebSockets and HTTP long polling
    approaches are used. The two of them and basic information about several
    others are covered in <xref linkend="chap-rtc" />.</para>

    <para>There are many existing real-time chat-based applications over the
    Internet we could have used. However, none of them suited our needs
    perfectly. Celebrio has very specific graphical user interface (GUI) and
    there is a need to integrate both text-based chat and video calling. Just
    to mention, there is commercial chat module Cometchat<footnote>
        <para>http://www.cometchat.com/</para>
      </footnote> or even open project Jappix.<footnote>
        <para>https://project.jappix.com/</para>
      </footnote> Video calling web browser applications are provided for
    example by TokBox Inc.<footnote>
        <para>http://www.tokbox.com/</para>
      </footnote> Nevertheless, following the rule that <quote>If you have to
    customize 1/5 of a reusable component, its likely better to write it from
    scratch</quote>, <citation>brian-stats-tweet</citation> just very generic
    existing libraries (Strophe.js) and APIs (OpenTok) were used for
    implementing brand new application called <emphasis>Celebrio
    Talker</emphasis>. The general approaches when building web browser based
    chat application are mentioned in <xref
    linkend="chap-xmpp-in-javascript" />. Within the programming part of the
    thesis, the real-time text chat application, video calling application and
    simple <quote>inter-process</quote> communication tool for Celebrio has
    been implemented. Celebrio Talker application itself, its architecture and
    the specific procedures used to create it are described in <xref
    linkend="chap-talker" />.</para>

    <para>It has been said that Skype<indexterm>
        <primary>Skype</primary>
      </indexterm><footnote>
        <para>http://www.skype.com/</para>
      </footnote> is the most favorite communication tool among the target
    audience. If it had been implemented, the existing customer base could be
    used and converted to our messaging application. However, there is one big
    pitfall in this approach. Skype license strictly prohibits incorporating
    their software into mobile devices. <citation>skype-license</citation>
    They support only prompting the official Skype client to be opened via
    Skype URI, which is insufficient for Celebrio since the messaging client
    has to be built in the system, with the corresponding user interface.
    <citation>skype-uri</citation></para>

    <para>Finally, there are several notes about <quote>inter-process
    communication</quote> between different applications running separately in
    various browser frames, tabs or even windows. <xref
    linkend="chap-inter-process" /> covers this topic and describes the issues
    we came across when implementing such functionality for Celebrio, where
    every application runs in separate iframe.</para>
  </chapter>

  <chapter id="chap-rtc">
    <title>Bidirectional communication between web browser and server</title>

    <para>Suggestion TODO: split the chapter: describe HTTP more in depth,
    tell why HTTP is so important (not only because of browsers), describe the
    history of communication tools. (maybe in the intro)</para>

    <para>Suggestion TODO: mention RTC history (unix talk, IRC, ICQ -
    Meebo)</para>

    <para>The very essence of every instant messaging is the bidirectional
    stream where both sides can immediately <emphasis>push</emphasis> new data
    and the other side (or more other sides, respectively) is promptly
    notified without the need to perform any manual <emphasis>pull</emphasis>
    (update) action<indexterm>
        <primary>pull &amp; push communication</primary>
      </indexterm>.<footnote>
        <para>In this thesis, this behaviour is commonly referred as RTC. The
        <quote>real-time part</quote> relates mostly to the server part since
        the application running in the web browser can perform the AJAX
        request on background anytime and the server receives the request
        instantly.</para>
      </footnote> Such use case requires appropriate transport layer on top
    which the application can send the messages via any other protocol. When
    using HTTP, there is a TCP connection opened by the client (web browser)
    through which the data is sent. However, according to the HTTP
    protocol<indexterm>
        <primary>HTTP</primary>
      </indexterm>, the communication is strictly initiated by the client -
    HTTP is a request/response protocol. <citation>rfc-http</citation> When
    the client needs still up-to-date information, it must poll the server as
    frequently as possible. Such approach takes a lot of bandwidth and
    generates purposeless overhead on the server. So, when one wants to avoid
    that drawbacks and still make the web browser application to communicate
    in both directions, HTTP protocol must be hacked somehow or another
    communication channel has to be used. This chapter covers both - reshaping
    HTTP in <xref linkend="chap-http-requests" /> and brand new approach in
    <xref linkend="chap-ws" />, bypassing HTTP at all. Unfortunately, every
    approach brings also some disadvantages. Ultimately, overview of several
    higher-level solutions is stated in <xref
    linkend="chap-high-level-rtc" />, most of which are based on HTTP requests
    or WebSockets.</para>

    <sect1 id="chap-http-requests">
      <title>Using HTTP requests</title>

      <para>Historically the first approach, for a very long time the only
      one, is hacking HTTP to achieve RTC. The idea is very simple. Generally,
      the client sends an extra request and it is not awaiting the response
      immediately. Instead, the server keeps the request for some time and
      sends the data as it comes in the response. There are several techniques
      to achieve such behaviour, in general called
      <emphasis>Comet</emphasis><indexterm>
          <primary>Comet</primary>
        </indexterm>.</para>

      <para>There is one common misunderstanding about long-lived HTTP
      requests. Since HTTP 1.1 (actually implemented even before, but not
      covered in the RFC specification), there is a possibility for the client
      to claim persistent TCP connection to the server declaring
      <computeroutput>Connection: Keep-Alive</computeroutput> in the request
      header.<indexterm>
          <primary>HTTP</primary>

          <secondary>Keep-Alive</secondary>
        </indexterm> Actually, all connections are considered persistent
      unless declared otherwise. <citation>rfc-http</citation> Even though the
      default timeout after which the server closes the connection is only a
      few seconds, <citation>apache-core-features</citation> the persistent
      TCP connection is very useful for delivering various resources (style
      sheets, scripts, images, etc.) to the client without the unnecessary
      overhead of creating multiple streams. However, every single
      transmission within the TCP connection has to be in form of separate
      HTTP request/response, always initiated by the client. On no account is
      the server allowed to push any data without respective request from the
      client. Therefore, such TCP connection is of no use for RTC.</para>

      <para>The situation is depicted at <xref linkend="fig-http-polling" />
      and <xref linkend="fig-http-polling-wrong" />. In the former case, a
      valid sequence of HTTP requests and responses is shown. Nevertheless,
      there is a delay between the moment the server gets (either generates or
      receives from third party) the data (2) and the following request (3).
      Yet it is possible to reduce the latency by shortening the polling time
      (the time between Response (1.1) and Request (3)), it is still trade-off
      between the delay and overhead caused by frequent empty request/response
      pairs.</para>

      <figure id="fig-http-polling">
        <title>Correct HTTP polling with delay</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="vp/http-polling.pdf" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure id="fig-http-polling-wrong">
        <title>Forbidden HTTP response without respective request</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="vp/http-polling-wrong.pdf" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>On the other hand, <xref linkend="fig-http-polling-wrong" />
      depicts the forbidden situation of generating HTTP response without
      request immediately. When the server gets the data (2) it is not allowed
      to initiate the connection and send HTTP response without appropriate
      preceding request (2.1). Even though the delay, mentioned in the
      previous paragraph, can be minimized in this situation, HTTP servers
      cannot use such technique. To sum it up, response (2.1) is forbidden by
      HTTP protocol and this situation solution is not valid.</para>

      <sect2 id="chap-http-long-polling">
        <title>HTTP long polling<indexterm>
            <primary>HTTP</primary>

            <secondary>long polling</secondary>
          </indexterm></title>

        <para>The essence of HTTP long polling springs from the idea of
        prolonging the time span between two poll requests. In traditional
        <quote>short polling</quote>, a client sends regular requests to the
        server and each request attempts to <quote>pull</quote> the available
        data. If no data is available, an empty response is sent.
        <citation>rfc-bidirectional-http</citation> That generates unnecessary
        overhead for both client and server.</para>

        <para>On the contrary, long polling tries to reduce this load. After
        receiving the request, the server <emphasis>does not</emphasis> answer
        immediately and holds the connection opened. When the server receives
        (or even makes up by itself) new data, it carries out the response
        with the respective content, as depicted at <xref
        linkend="fig-http-long-polling" />.</para>

        <figure id="fig-http-long-polling">
          <title>HTTP long polling</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/http-long-polling.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>As soon the client obtains the response, it usually issues a new
        request immediately so the process can repeat endlessly. If no data
        appears on the server for certain amount of time, it usually responds
        with empty data field just to renew the connection.</para>

        <para>One of the main drawbacks of long polling is header overhead.
        Every chunk of data in RTC applications is usually very short, for
        example some text message of minimal length. However, each update is
        served by full HTTP request/response with the header easily reaching
        800 characters. <citation>pro-html5-programming</citation> In case the
        payload is a message 20 characters long, the header constitutes 4000%
        overhead!<indexterm>
            <primary>HTTP</primary>

            <secondary>header overhead</secondary>
          </indexterm> This drawback has even bigger impact as the number of
        clients increases. <xref linkend="fig-http-overhead" /> shows the
        comparison of 1000 (A), 10000 (B) and 100000 (C) clients polling the
        server every second with the message 20 characters long, both using
        classic HTTP requests and WebSockets technology (mentioned in <xref
        linkend="chap-ws" />). <citation>pro-html5-programming</citation> It
        is obvious that there is huge unnecessary network overhead when using
        HTTP polling instead of WebSockets.</para>

        <figure id="fig-http-overhead">
          <title>Comparison of network overhead (HTTP and WebSockets)</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="img/http-overhead.png" width="420pt" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Furthermore, in case the server just received the data and sent
        the response to the client, there is a <quote>blind window</quote>
        when the server cannot notify the client. Whole push system is blocked
        until the response is received by the client, processed and new
        request is delivered back to the server. Considering also the possible
        packet loss and required retransmission in TCP protocol, the delay can
        be even longer than double bandwidth latency.
        <citation>rfc-bidirectional-http</citation></para>
      </sect2>

      <sect2 id="chap-http-streaming">
        <title>HTTP streaming<indexterm>
            <primary>HTTP</primary>

            <secondary>streaming</secondary>
          </indexterm></title>

        <para>HTTP streaming is slightly different technique than long
        polling, although they are confused one with the other very often.
        What is mutual for both of the approaches is the client initializing
        the communication by HTTP request. The server also sends the update as
        the part of the HTTP response. The main difference is that once the
        server initializes the response and sends the data, it does not
        terminate the response and keeps the HTTP connection opened.
        Meanwhile, the client listens to the response stream and reads the
        data pushed from the server. When any new data springs up on the
        server side, it is concatenated to the one existing response stream.
        <citation>rfc-bidirectional-http</citation> See the schema at <xref
        linkend="fig-http-streaming" />.</para>

        <figure id="fig-http-streaming">
          <title>HTTP streaming</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/http-streaming.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>It is very important not to confuse HTTP streaming with the
        <quote>persistent</quote> HTTP requests. As said at the beginning of
        this chapter, declaring <computeroutput>Connection:
        Keep-Alive</computeroutput> does not allow the server to issue
        multiple responses to a single request. Such behaviour would be
        serious violation of HTTP protocol. Instead, the server can declare
        <computeroutput>Transfer-Encoding: chunked</computeroutput><indexterm>
            <primary>HTTP</primary>

            <secondary>chunked response</secondary>
          </indexterm> status in the response header and send the response
        split into separate pieces, as show below (chunk of zero length stands
        for the end of the response):
        <citation>rfc-bidirectional-http</citation></para>

        <programlisting>HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

0</programlisting>

        <para>The main drawback of HTTP streaming can be generally called
        buffering. There is no requirement for both the client and any
        intermediary (proxies, gateways, etc.) to handle the incoming data
        until whole response is sent. Therefore, all parts of the response
        could be kept by the proxy and the messages (single HTTP response
        chunks) are not delivered to the client until whole response is sent.
        Similarly, when the response consists of JavaScript statements, the
        browser does not have to execute them before whole response is
        obtained (yet, most of the browsers execute it immediately). In such
        cases, HTTP streaming will not work.
        <citation>rfc-bidirectional-http</citation></para>
      </sect2>
    </sect1>

    <sect1 id="chap-ws">
      <title>Permanent TCP streams with WebSockets<indexterm>
          <primary>WebSockets</primary>
        </indexterm></title>

      <para>Although the World Wide Web with HTTP request/response schema has
      never been intended to serve as RTC platform, the contemporary
      applications require such functionality and the developers started to
      bend the protocol in the undesirable way. Most of the patterns described
      in <xref linkend="chap-http-streaming" /> do their jobs and one can
      achieve sufficient two-way communication, but there are certain
      performance issues and drawbacks which make them difficult to use. At
      least, those techniques carry HTTP header overhead which is unnecessary
      for standard bidirectional streams. Therefore, brand new standard for
      creating full-duplex communication channels between the web browser and
      the server has been created. The technology is called
      <emphasis>WebSockets</emphasis><indexterm>
          <primary>WebSocket</primary>
        </indexterm> (sometimes shortened as WS) and it stands for a
      communication protocol layered over TCP along with the browser API for
      web developers. Anyway, not even WebSockets are allowed to access wider
      network, the connection possibilities are limited only to the dedicated
      WS servers (usually HTTP servers with additional module for WS support
      attached). <citation>js-definitive-guide</citation></para>

      <para>Similarly as in HTTP, there is an unencrypted version of
      WebSockets working directly on top of TCP connection. The simplest way
      to recognize such connection is WebSocket URI<indexterm>
          <primary>WebSocket</primary>

          <secondary>URI</secondary>
        </indexterm> beginning with <computeroutput>ws://</computeroutput>. It
      should not be used on account of two reasons. The first one, quite
      obvious, is security<indexterm>
          <primary>security</primary>
        </indexterm> - the communication can be captured during the
      transmission. Transparent proxy servers are the second reason. If an
      unencrypted WebSocket connection is used, the browser is unaware of the
      transparent proxy and as a result, the WebSocket connection is most
      likely to fail.
      <citation>ws-proxy</citation><citation>definitive-guide-to-ws</citation>
      As opposite, there is a secure way how to use WebSockets. WebSockets
      Secure (WSS)<indexterm>
          <primary>WebSocket</primary>

          <secondary>Secure</secondary>
        </indexterm> protocol is standard WS wrapped in TLS tunnel, similarly
      as HTTP can be transmitted over TLS layer. When using WSS, the URI
      begins with <computeroutput>wss://</computeroutput> and it uses port 443
      by default. <citation>definitive-guide-to-ws</citation></para>

      <sect2>
        <title>WebSocket Handshake<indexterm>
            <primary>WebSocket</primary>

            <secondary>handshake</secondary>
          </indexterm></title>

        <para>Alike any other multilateral protocol WebSockets need to perform
        a handshake before actual transmission can take place. During the
        handshake, the connection is established and both peers acknowledge
        the properties of the communication.</para>

        <para>Since WebSockets emerged as HTTP supplement, the handshake is
        initialized by HTTP request<footnote>
            <para>According to RFC6455, the protocol is designed to work over
            HTTP ports 80 and 443 as well to support HTTP proxies. However,
            the design is not limited to HTTP and the future implementations
            can use simpler handshake over a dedicated port.
            <citation>rfc-ws</citation></para>
          </footnote> initialized by the client. The client sends the request
        as follows: <citation>rfc-ws</citation></para>

        <programlisting>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13</programlisting>

        <para>Let us have a look what each of the lines means. The first two
        lines are obvious, they represent typical HTTP GET request. Specifying
        <computeroutput>Host</computeroutput> is important for the server to
        be able to handle multiple virtual hosts on single IP address. The
        following two lines, <computeroutput>Upgrade:
        websocket</computeroutput> and <computeroutput>Connection:
        Upgrade</computeroutput>, are the most important. The client informs
        the server about the desire to use WS. The rest of the request stands
        for additional information for the server to be able to respond
        correctly - RFC 6455 describes them in detail.</para>

        <para>The server should send HTTP response looking similar as this
        example: <citation>rfc-ws</citation></para>

        <programlisting>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</programlisting>

        <para>Number 101 on the first line of the response stands for HTTP
        status code <computeroutput>Switching Protocols</computeroutput>,
        <citation>rfc-http</citation> which means the server supports
        WebSockets and the connection can be established. Any status code
        other than 101 indicates that the WebSocket handshake has not
        completed and that the semantics of HTTP still apply.
        <citation>rfc-ws</citation></para>

        <para><computeroutput>Sec-WebSocket-Key</computeroutput> is random
        secret issued by the client and added to the initial
        protocol-switching request. The server is supposed to concatenate the
        secret with Globally Unique Identifier (GUID)<indexterm>
            <primary>GUID</primary>
          </indexterm> "258EAFA5-E914-47DA- 95CA-C5AB0DC85B11" and hash the
        result with SHA-1 algorithm. The results returned as
        <computeroutput>Sec-WebSocket-Accept</computeroutput> header field,
        base64-encoded. <citation>rfc-ws</citation> However, there seems to be
        a security issue here. If the initial request is not sent over
        encrypted HTTP connection (HTTPS), it can be caught by a third party.
        Since the server does not authenticate in any way and the algorithm
        does not contain any server secret, the third party attacker could
        fake the response and pretend to be the server.</para>
      </sect2>

      <sect2>
        <title>Frames and masking</title>

        <para>All the data sent via WebSockets protocol is chunked into
        frames<indexterm>
            <primary>frames</primary>
          </indexterm>, working similarly as TCP frames. All the transmission
        features are handled by the WebSocket API and the transmission is
        transparent for the application layer above (for example JavaScript
        API) so that every message appears in the same state as it was sent.
        This means the message, single portion of WS communication, can be
        fragmented during the transmission.</para>

        <para>There are several special features concerning WS frames, one of
        the interesting is masking<indexterm>
            <primary>masking</primary>
          </indexterm>. The payload data of every frame sent from the client
        is XORed by the masking key of 32-bit size. The purpose of masking is
        to prevent any third party from picking any part of the payload and
        reading it. The other goal might be distinguishing the server stream
        from the client stream instantly since client-to-server frames always
        <emphasis>must</emphasis> be masked and server-to-client frames
        <emphasis>must not</emphasis> be masked under any circumstances. In
        addition, WS peers have to use masking even if the communication is
        running on top of TLS layer so the <quote>encryption</quote> function
        is pointless. <citation>rfc-ws</citation> The security function of
        masking is also questionable because the masking key is included in
        the frame header. The only reason is preventing from random
        cross-protocol attacks.
        <citation>pro-html5-programming</citation></para>
      </sect2>

      <sect2>
        <title>WS JavaScript API<indexterm>
            <primary>WebSocket</primary>

            <secondary>API</secondary>
          </indexterm></title>

        <para>Since WebSocket technology is intended to be used particularly
        from the browser applications, there is need of an API web developers
        can use. The most widespread programming language of web browser
        client applications is JavaScript and so is the WebSocket API created
        for. The API consists of one relatively simple JavaScript interface
        called <computeroutput>WebSocket</computeroutput>,<footnote>
            <para>In the older versions of some browsers, the interface was
            called differently due to the immaturity of the technology. For
            instance, Firefox from version 6 to 10 supports WebSockets only as
            <computeroutput>MozWebSocket</computeroutput>. Interesting fact is
            that Firefox 4 and 5 provides
            <computeroutput>WebSocket</computeroutput> interface as it is,
            just implementing different WebSocket protocol version. Since
            Firefox 11.0, current (RFC 6455) WS protocol version is accessible
            via interface <computeroutput>WebSocket</computeroutput>.
            <citation>mozilla-ws</citation></para>
          </footnote> <citation>ws-api</citation> placed as the property of
        <computeroutput>window</computeroutput> object.<footnote>
            <para>Properties of window are accessible in JavaScript directly.
            Simple test <computeroutput>window.WebSocket ===
            WebSocket</computeroutput> returning
            <computeroutput>true</computeroutput> proves it.</para>
          </footnote> It wraps the WebSocket client functionality performed by
        the user agent (web browser). Using the API is very simple - the
        object, which handles all the WS functionality, is created by calling
        <computeroutput>WebSocket()</computeroutput> constructor:
        <citation>ws-html5rocks</citation></para>

        <programlisting>var connection = new WebSocket(
        'ws://html5rocks.websocket.org/echo', 
        ['soap', 'xmpp']
);</programlisting>

        <para>The first (mandatory) argument stands for the WebSocket URI the
        client attempts to connect to. It can either begin with
        <type>ws://</type> prefix or <type>wss://</type>, depending whether
        TLS layer is used or not. The second parameter is optional - specific
        WS subprotocols can be demanded there. Since there are only a few
        subprotocols recorded by IANA registry, it is of a little use so far.
        <citation>ws-iana</citation></para>

        <para><computeroutput>WebSocket</computeroutput> interface provides at
        least four event handlers, to each of them a custom callback can be
        attached. <citation>ws-api</citation> Those are
        <computeroutput>onopen</computeroutput>,
        <computeroutput>onmessage</computeroutput>,
        <computeroutput>onerror</computeroutput> and
        <computeroutput>onclose</computeroutput>. The names are quite
        self-explanatory, they serve as the event listeners watching the
        incoming activity - anytime the websocket obtains a message, its
        status changes or an error occurs, the respective callback is fired.
        The callback registration can look as follows:</para>

        <programlisting>connection.onmessage = function (message) {
  console.log('We got a message: ' + message.data);
};</programlisting>

        <para>In addition, there is a property
        <computeroutput>readyState</computeroutput> (it would be
        <computeroutput>connection.readyState</computeroutput> in the previous
        example) keeping current WebSocket status all the time. The status can
        be retrieved by testing the property against one of the
        <computeroutput>WebSocket</computeroutput> property constants
        <computeroutput>CONNECTING</computeroutput>,
        <computeroutput>OPEN</computeroutput>,
        <computeroutput>CLOSING</computeroutput> or
        <computeroutput>CLOSED</computeroutput>.</para>

        <para>Sending the data to the server is also quite straightforward.
        Either <computeroutput>DOMString</computeroutput>,
        <computeroutput>ArrayBuffer</computeroutput>,
        <computeroutput>ArrayBufferView</computeroutput> or
        <computeroutput>Blob</computeroutput> can be sent via
        <computeroutput>send()</computeroutput> method. See the examples
        below: <citation>ws-html5rocks</citation></para>

        <programlisting>// Sending String
connection.send('string message');

// Sending canvas ImageData as ArrayBuffe
var img = canvas_context.getImageData(0, 0, 400, 320);
var binary = new Uint8Array(img.data.length);
for (var i = 0; i &lt; img.data.length; i++) {
  binary[i] = img.data[i];
}
connection.send(binary.buffer);

// Sending file as Blob
var file = document.querySelector('input[type="file"]').files[0];
connection.send(file);</programlisting>

        <para>To sum it up, using WebSockets became a very simple and elegant
        way to provide real-time communication channel between web browser and
        WS server. The main drawback of WS is lack of support not only in the
        older versions of web browsers but also in the mobile platform
        browsers. Currently less than 60 % of users can make use of WebSocket
        full support. <citation>ws-caniuse</citation> Particularly, all
        versions of Internet Explorer below 10 (which means more than 98 % of
        IE users in November 2012) <citation>ie-statistics</citation> does not
        implement WebSockets JavaScript API. There are two favourable aspects
        in favour of WebSockets. Firstly, more and more web browsers add
        JavaScript API to support WebSockets. Secondly, the ratio of clients
        who use old version of the web browser without WS support tends to
        diminish. Anyway, if the real-time functionality constitutes the
        application core functionality, there is a strong need to offer
        fallback technology that every browser supports - usually represented
        by HTTP long polling or streaming mechanism, described in <xref
        linkend="chap-http-requests" />.</para>
      </sect2>

      <sect2>
        <title>WebSocket API wrappers</title>

        <para>Yet WebSockets is powerful technology, there are still many
        browsers not supporting it. In that case, when real-time communication
        constitutes the core functionality, a fallback (i.e. the alternative
        technology used when the original is missing) must be defined to
        substitute WebSockets. It might be Flash or HTTP polling. It would be
        great not to have to define the fallback in every project again and
        again. Luckily, there are several API wrappers for this.</para>

        <para>The basic use case is obvious. Using the wrapper instead of WS
        API itself guarantees the developer that a fallback is used when the
        application runs in the environment without WebSockets. Whole process
        of choosing the transport technology is transparent and not necessary
        to be specified. As examples, however not used within Talker
        application, projects Socket.IO<footnote>
            <para>http://socket.io/</para>
          </footnote> and SockJS should be mentioned.<footnote>
            <para>https://github.com/sockjs/sockjs-client</para>
          </footnote></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Server-sent events<indexterm>
          <primary>Server-sent events</primary>
        </indexterm></title>

      <para>Server-sent events (aka EventSource, from this point referred as
      SSE) should in fact not be listed here but in the next section. It is
      technology based on HTTP streaming<indexterm>
          <primary>HTTP</primary>

          <secondary>streaming</secondary>
        </indexterm> described in <xref linkend="chap-http-streaming" /> so it
      is not at the basic <quote>zero</quote> level. However, SSE are often
      compared to WebSockets so that the topic is introduced here. SSE have
      been standardized as part of HTML5 standard.
      <citation>sse-api</citation> There is very brief summary of SSE API and
      usage in this section.</para>

      <para>As any other web technology, SSE connection must be initialized by
      the client. There is a JavaScript API providing event handlers, very
      similar to WS API. The event stream is opened with the constructor,
      pointing to the resource at the server:</para>

      <para><programlisting>var eventSource = new EventSource("sse-example.php");</programlisting></para>

      <para>The script at the server,
      <computeroutput>sse-example.php</computeroutput> in our case, pushes the
      data to the opened HTTP response stream. What is important to get SSE
      work, the <computeroutput>Content-Type</computeroutput> header must be
      set to the value <computeroutput>text/event-stream</computeroutput>. The
      data has to be organized in form of <quote>paragraphs</quote> separated
      by blank line, where every paragraph stands for one message. Have a look
      at an example below:</para>

      <para><programlisting>data: This is one-line message

id: 123
event: myevent
data: Message of type "myevent" which consists of several lines
data: Another line of the event message</programlisting></para>

      <para>As shown above, every line in the message consists of key and
      value separated by colon, similar to JSON format. When we need to
      transfer multi-line message, we can repeat the key several times.
      <citation>sse-multiline</citation> On the basis of
      <computeroutput>event</computeroutput> field
      (<computeroutput>myevent</computeroutput> in our example), the
      respective event handler is triggered in JavaScript API. In our case, it
      would be the following event listener, if it has been attached in
      JavaScript before, logging the event to the console:</para>

      <programlisting>eventSource.addEventListener("myevent", function(e) {
    // process the event
    console.log(e);
}, false);</programlisting>

      <para>The connection is closed either by the client by calling
      <computeroutput>close()</computeroutput> method on the
      <computeroutput>EventSource</computeroutput> object or by the server
      (when all data is sent). However, if server closes the connection, the
      client attempts to reconnect to the same resource. So, the server cannot
      close the connection permanently.</para>

      <para>Sever-sent events are often compared to WebSockets, though they
      are much less known. The support of both in current web browsers is very
      similar. The only main difference is lack of support of SSE in Internet
      Explorer 10, which finally provides WebSocket API. Another difference is
      the fact that SSE, unlike WS, does not provide real bidirectional
      stream. Only the server can publish new messages through the opened HTTP
      connection, the client has to push the data to the server via other
      (standard) HTTP requests. Finally, there is quite a big limitation in
      the message format. While WebSockets provide real TCP connection any
      data can be transferred through, SSE is restricted to textual data in
      the form of key/value pairs. So, there is no compelling reason to use
      SSE when WebSockets exist. Anyway, it comes in handy to know about it
      when working with real-time applications in web browsers.</para>
    </sect1>

    <sect1>
      <title>Media streaming with WebRTC technology<indexterm>
          <primary>WebRTC</primary>
        </indexterm></title>

      <para>Up to now, none of the technologies mentioned was fully suited as
      a complete solution for web browser based media communication, such as
      video calling. WebSockets are the most advanced, however, it is only low
      level API providing TCP stream. On that account, web browser developers,
      with Chromium developers in the vanguard, invented WebRTC technology. Is
      is an API linking up the user media API (webcam, microphone) with the
      streaming API for sending the multimedia from the browser to the other
      node.<footnote>
          <para>Apart from video calling, WebRTC provides an API for sending
          the files from one peer to another.</para>
        </footnote></para>

      <para>While WebSockets serve as the interconnection between the client
      (web browser) and the dedicated server, which makes it suitable for
      <quote>server-based</quote> protocols such as XMPP, WebRTC provides real
      peer-to-peer connection<indexterm>
          <primary>peer-to-peer connection</primary>
        </indexterm>, directly between two web browsers. That makes WebRTC a
      perfect tool for implementing direct media communication, such as video
      calling.</para>

      <sect2>
        <title>Signaling<indexterm>
            <primary>WebRTC</primary>

            <secondary>Signaling</secondary>
          </indexterm></title>

        <para>In fact, the server has to mediate the <quote>meta data</quote>,
        such as initializing connection or negotiating the available media
        capabilities (such as codecs). This level of communication, exchanging
        the information about connection itself, is called
        <emphasis>signaling</emphasis><indexterm>
            <primary>signaling</primary>
          </indexterm>. WebRTC does not take care nor about the layer
        signaling data is transferred at, neither the signaling protocol
        itself. It can SIP, XMPP or any other, transferred via XMLHTTPRequest
        or WebSockets. What is important, signaling is not part of WebRTC API.
        The WebRTC connection itself then concerns only the peers, as shown at
        <xref linkend="fig-webrtc" />.
        <citation>webrtc-signaling</citation></para>

        <figure id="fig-webrtc">
          <title>WebRTC communication schema</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="img/webrtc.png" width="420pt" />
            </imageobject>
          </mediaobject>
        </figure>
      </sect2>

      <sect2>
        <title>WebRTC API</title>

        <para>WebRTC provides very high level API abstracting media device
        access, network connection and encoding/decoding the media streams
        from the programmer. Unfortunately, the WebRTC API is still in the
        phase of draft and has not been standardized yet.
        <citation>webrtc-rfc</citation> It means that JavaScript objects are
        prefixed by vendor prefixes, so that there is
        <computeroutput>webkitRTCPeerConnection</computeroutput> instead of
        <computeroutput>RTCPeerConnection</computeroutput> in Chromium.</para>

        <para>The core API object is JavaScript object RTCPeerConnection.
        Creating one may look like the following (with respective
        prefix):</para>

        <programlisting>var config =  {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]};
var pc = new RTCPeerConnection(config); // webkitRTCPeerConnection</programlisting>

        <para>Then, we can send all available ICE<indexterm>
            <primary>ICE</primary>
          </indexterm><footnote>
            <para>ICE stands for Interactive Connectivity Establishment</para>
          </footnote> candidate to the other peer, via specified
        STUN<indexterm>
            <primary>STUN</primary>
          </indexterm> server. ICE candidate<indexterm>
            <primary>ICE candidate</primary>
          </indexterm> is basically a possible transport address for media
        stream, later validated for peer-to-peer connectivity.
        <citation>ice</citation> So, each possible connection address is sent
        via previously created <computeroutput>pc</computeroutput> object. The
        process is still in the phase of negotiation so sending is up to the
        signaling service:</para>

        <programlisting>pc.onicecandidate = function (event) {
    // use existing signaling channel to send the candidate
    signalingChannel.send(JSON.stringify({ "candidate": event.candidate }));
};</programlisting>

        <para>In case the other side publishes its video stream, we set up a
        hook which handles it and shows it in the remote video element, stored
        in <computeroutput>remoteView</computeroutput> JavaScript variable.
        <citation>webrtc-rfc</citation> In other words, the incoming URL is
        assigned to the <computeroutput>video</computeroutput> element as a
        source (<computeroutput>src</computeroutput>) attribute. The
        <computeroutput>src</computeroutput> attribute determines the media
        source played within the element.
        <citation>definitive-guide-to-html5</citation></para>

        <programlisting>pc.onaddstream = function (event) {
    remoteView.src = URL.createObjectURL(event.stream);
};</programlisting>

        <para>Sending the media stream from the local browser to the other
        peer is similar. First, we capture audio and video stream from the
        local multimedia devices. The result, multimedia stream, is passed as
        the argument to the function which adds it to the
        <computeroutput>RTCPeerConnection</computeroutput> object
        <computeroutput>pc</computeroutput>. Besides, it is a common habit to
        add the video of self to the page as well. It is handled by
        <computeroutput>selfView</computeroutput> variable, containing
        reference to another video element on the page. The example below
        represents the described situation:</para>

        <programlisting>navigator.getUserMedia({ "audio": true, "video": true }, function (stream) {
    selfView.src = URL.createObjectURL(stream);
    pc.addStream(stream);
});</programlisting>

        <para>Closing the connection is quite straightforward, by invoking
        <computeroutput>close()</computeroutput> method on
        <computeroutput>RTCPeerConnection</computeroutput> object which has
        been instantiated before as
        <computeroutput>pc</computeroutput>.</para>
      </sect2>

      <sect2>
        <title>WebRTC in various environments</title>

        <para>WebRTC is truly new technology, not yet adopted by many web
        browsers. And for those which support it, the implementation may
        differ since the standard has not been fully defined and finished yet.
        Chromium browser (i.e. Chrome and Chromium) developers were the first
        who added WebRTC API to their products - in 2012. By the beginning of
        the year 2013, WebRTC API was added also to the newest Firefox builds
        so that Chrome and Firefox can <quote>talk</quote> to each
        other.<footnote>
            <para>Note that in current Firefox version (22, nightly build by
            the time this thesis part is created), the user has to enable
            <computeroutput>media.peerconnection.enabled</computeroutput>
            field in <computeroutput>about:config</computeroutput> to get
            WebRTC run.</para>
          </footnote> <citation>webrtc-interop</citation> Opera browser also
        takes part in this initiative, yet no existing official claim of
        support has been released. All of the mentioned browsers used the same
        backend implementation, hosted at <ulink
        url="http://www.webrtc.org">http://www.webrtc.org</ulink>. In theory,
        this backend implementation (written in C++) can be built into any
        application to support WebRTC, not only a web browser.</para>

        <para>For the web browsers which does not support WebRTC yet, there
        are several attempts to add its functionality via browser plugins. It
        can be useful as a temporary improvement for the experienced users but
        one can never rely on the user having the plugin installed. The
        library providing WebRTC functionality for Safari, Opera, IE and older
        versions of Firefox is called webrtc4all.
        <citation>webrtc4all</citation> However, it is still proprietary
        solution, adding one more prefix
        (<computeroutput>w4a</computeroutput>) to the world of WebRTC
        JavaScript APIs.</para>

        <para>There are also other parties which implement WebRTC in their own
        way, keeping to the API more or less. One of such initiatives is
        Ericsson Browser (called just Browser), which claimed self to be the
        first browser to implement WebRTC. Ericsson Browser uses different
        backend implementation but it tries to be in accordance with the
        official API. <citation>webrtc-ericsson</citation></para>

        <para>Microsoft came up with another approach. Even though Internet
        Explorer does not support WebRTC, Microsoft invented their own API
        standard proposal. <citation>webrtc-ms</citation> It differs from the
        <quote>official</quote> API mainly in the extended possibilities to
        control more aspects of WebRTC communication, including low level
        <quote>transport</quote> layers. Since the none of the standards has
        been finished yet, it is possible (and probable) that the final API
        definition will result somwhere in between.</para>

        <para>One of the logical reasons why Microsoft does want to intervene
        to the process of defining WebRTC API as much as possible is
        Skype<indexterm>
            <primary>Skype</primary>
          </indexterm>. Skype has been bought by Microsoft some time ago and,
        as everything nowadays, is planned to be available in the web browser.
        Microsoft seems to bet on WebRTC technology.
        <citation>webrtc-skype</citation> As a pleasant side-effect of Skype
        working on top of WebRTC, it would be finally possible to play along
        with Skype with other technologies. Of course, the technology barrier
        is the smaller one compared to licences and legal regulations, but it
        is another story.</para>
      </sect2>
    </sect1>

    <sect1 id="chap-high-level-rtc">
      <title>Other RTC solutions</title>

      <para>Actually, there are several other, mostly higher-level, solutions
      for achieving bidirectional (and thus real-time) communication in web
      browser. Some of them use HTTP requests described above (such as
      Bayeux), some of them are based on WebSockets (OpenTok) and several are
      built completely independent, installed as web browser plugins and thus
      behaving as separate runtime platforms (Adobe Flash, Google Talk). And,
      to be precise, some of the frameworks are built on top of others, for
      example OpenTok can use Flash. See the sections below to understand each
      of the technologies.</para>

      <sect2>
        <title>Adobe Flash<indexterm>
            <primary>Flash</primary>
          </indexterm></title>

        <para>Among all, one of the most widespread technologies is Adobe
        Flash.<footnote>
            <para>http://www.adobe.com/software/flash/about/</para>
          </footnote> Apart from the possibility to establish bidirectional
        persistent TCP connection, Flash allows the developer to create almost
        any graphics, animations and user interface with nearly no
        limits.</para>

        <para>Nevertheless, the disadvantages of Flash are significat. First,
        Flash is not a native part of any web browser. Until recently, it had
        to be installed manually as a plugin. Now, it is bundled and shipped
        with Chromium-based browsers (Chrome, Chromium), but it is still
        external plugin. <citation>flash-bundled-with-chrome</citation>
        Another drawback of Flash is lack of support on mobile devices. Apple
        has been clear about it: iPhones and iPads have never supported Flash
        technology and it is not likely to change in the future.
        <citation>iphone-flash-support</citation> Android devices supported
        Flash at first, but later Adobe quit Google Play.
        <citation>android-flash-support</citation></para>

        <para>There are many other similar technologies such as Adobe Flash,
        but they all suffer the same pain. Since they are installed as
        proprietary plugins, the developer can never be sure the application
        will run in any environment. This concerns technologies like Microsoft
        Silverlight<indexterm>
            <primary>Silverlight</primary>
          </indexterm><footnote>
            <para>http://www.microsoft.com/silverlight/</para>
          </footnote> or Adobe AIR<indexterm>
            <primary>AIR</primary>
          </indexterm><footnote>
            <para>http://www.adobe.com/products/air.html</para>
          </footnote> (even though AIR has been intended to be
        browser-independent platform).</para>

        <para>So, Adobe Flash is often used as a fallback for older browsers,
        running on non-mobile devices, which does not WebRTC yet (described
        below). It has been used as fallback for the video calls in Talker
        application. However, creating a new application based on Flash (as a
        primary technology) in 2013 is not a good idea.</para>
      </sect2>

      <sect2 id="chap-opentok">
        <title>OpenTok video call library</title>

        <para>OpenTok is a high-level video call platform for building
        real-time communication applications in web browser. It allows the
        developer to easily set up a video call session, using OpenTok server
        as a mediator. OpenTok is available as a free library for one-to-one
        calls. If more users were participating in one call, payed
        subscription has to be bought.
        <citation>opentok-pricing</citation></para>

        <para>From the technical point of view, there are two versions of
        client-side OpenTok library. The first one is built on top of Adobe
        Flash, using it for establishing the connection with OpenTok server
        the media streaming, the other one uses WebRTC (and therefore is
        limited to the browsers which support it). Unfortunatelly, the two
        versions are not compatible so it is impossible for one user to have
        Flash version and for the other to use WebRTC when communicating
        together.</para>

        <para>Each OpenTok session is identified by session ID and every user
        who wants to join the session must hold a token generated for the
        session. Therefore, OpenTok contains server-side library for issuing
        and managing session IDs and tokens, available for most commonly used
        server-side languages.
        <citation>opentok-server-side-lib</citation></para>

        <para>OpenTok library is the tool that has been used for implementing
        video calls in Talker application, hence the library API usage is
        described separately in <xref linkend="chap-video-calling" />. The
        main advantage of OpenTok is a low entry barrier and simple API that
        can be used out of the box. On the other hand, it is still proprietary
        tool and every application built with OpenTok heavily relies on the
        third party service. Nevertheless, we have not experienced any serious
        problems during almost one year running OpenTok in Celebrio.</para>
      </sect2>

      <sect2>
        <title>Bayeux protocol<indexterm>
            <primary>Bayeux</primary>
          </indexterm></title>

        <para>Bayeux is one of the higher level protocols designed specificaly
        for bidirectional communication between web browser and the server,
        primarily intended to work on top of HTTP. The idea of communication
        is almost the same as in case of HTTP long polling. For transfer of
        the messages from the server to client, the server holds the request
        and responds only when there is available message. Sending the data
        from the client to the server is straightforward, ordinary HTTP
        request is sufficient.</para>

        <para>Apart from HTTP requests, Bayeux defines the structure for the
        transmitted data, contained in the body of HTTP requests/responses.
        Each message has to be in form of JSON, containing structured data
        such as channel name, client ID and of course the transmitted data
        itself. <citation>bayeux</citation> Bayeux provides interesting way to
        communicate, yet it has not been used in this thesis. The main reason
        for choosing XMPP is much better interoperability with other existing
        services and ability to easily communicate with the clients not
        running in web browser.</para>
      </sect2>

      <sect2>
        <title>SignalR framework<indexterm>
            <primary>SignalR</primary>
          </indexterm></title>

        <para>SignalR is a framework taking care of both client (web browser)
        and server side of the application. SignalR is designed for .NET
        platform on the server side, so the web application should be powered
        by ASP.NET framework on the server side. It abstracts the user from
        finding out which technology the web browser the application runs into
        supports. Instead, SignalR provides API for sending the messages and
        handling the incoming ones. Internally, it uses WebSockets for
        establishing the connection. When the WebSocket API is not available
        (for example in IE9, which is fun fact considering that SignalR is
        Microsoft-platform-based), it tries Server Sent Events and then falls
        back on long polling technique. <citation>signalr</citation> To take
        is short, SignalR provides envelope for client-side WebSockets and
        HTTP long polling techniques, with ASP.NET API for handling the
        messages on the server.</para>
      </sect2>

      <sect2>
        <title>Real-time communication tools from Google<indexterm>
            <primary>Google</primary>
          </indexterm></title>

        <para>There are three topics briefly mentioned in this section, all
        developed by Google - Channel API, Google Talk and Google Hangouts
        API, all of which serve as RTC tools or even complete
        applications.</para>

        <para>The first one, Google Channel API<indexterm>
            <primary>Channel API</primary>
          </indexterm>, is a tool for creating persistent connections between
        a browser-based client and server. It simply wraps common Comet
        techniques (i.e. HTTP long polling or streaming) with convenient
        methods for binding handlers to incoming events, usually messages.
        Nevertheless, Channel API is part of Google App Engine and it is
        intended to be used only within the apps built on it. Although it is
        possible to use only the client side of Channel API in custom web
        application, using only half of the tool does not seem to be very
        helpful.</para>

        <para>The other tool (more precisely standalone application) from
        Google is chat service. It became natural part of Gmail, serving for
        quick and more informal messages than e-mail. It is a service built on
        XMPP protocol, not dissimilar to Talker application. Thanks to using
        XMPP, it is possible to connect with Gmail account from various IM
        clients such as Pidgin or Miranda. Recently, Google added support for
        video calls in web browser - originally powered by a browser plugin
        that had to be installed, now switching to WebRTC.</para>

        <para>The last topic in this section is Hangouts API. Hangouts is a
        platform for creating group video chat, running within a web
        application. Hangouts offer neat user experience, they however cannot
        be much customised. In other words, it is possible to add a Hangout to
        arbitrary web application but its look and feel cannot be altered.
        This is insurmountable problem for Celebrio Talker since it must
        strictly keep up with the user interface of whole Celebrio, the system
        it is built into.</para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="chap-xmpp">
    <title>Extensible Messaging and Presence Protocol</title>

    <para>Suggestion TODO: xmpp: to chce XMPP trochu více popsat a zasadit ho
    do kontextu HTTP komunikace a tu zase do celkového provozu na internetu
    mezi ostatní protokoly</para>

    <para>Extensible Messaging and Presence Protocol (XMPP) technologies were
    invented by Jeremie Miller in 1998.
    <citation>xmpp-the-definitive-guide</citation> It is one of the most
    widespread technologies for instant messaging (IM),<footnote>
        <para>Acutally, the IM client or even the techology itself is
        sometimes called <quote>Instant Messenger</quote>. This term is
        registered as a trademark by AOL company.
        <citation>aol-trademarks</citation></para>
      </footnote> i.e. exchanging the text or multimedia data between several
    endpoints. The <quote>native</quote> implementation of XMPP works right on
    top of TCP protocol: XMPP endpoint (called client as it represents the
    first actor in client-server architecture) opens long-lived TCP
    connection. Then, both the client and the server negotiate and open XML
    streams so there is one stream in each direction.
    <citation>xmpp-the-definitive-guide</citation> When the connection is
    established, both client and server can push any changes as XML elements
    to the stream and the other side obtains them immediately. Usual XMPP
    clients are standalone applications able to open TCP connection and listen
    to the stream opened by the server.</para>

    <para>XMPP stands for communication protocol handling not only sending and
    receiving the messages, but also presence notification, contact list
    (roster) management and others. The architecture is distributed and
    decentralized. There is no central or top level XMPP server. Anyone can
    run XMPP server, very similarly as HTTP or FTP server. Identification and
    recognition on the network is also similar - XMPP relies on Domain Name
    System (DNS) so that every server is identified via string domain name
    with arbitrary subdomain level (e.g. xmpp.example.com or just
    example.org). <citation>xmpp-the-definitive-guide</citation></para>

    <para>The user name, called Jabber ID (or shortly as JID), has the same
    structure as e-mail address so the user name is followed by
    <computeroutput>@</computeroutput> and the server domain name. This rule
    also guarantees that every XMPP user is registered at the certain server.
    If there is any message or notification for the given user, her
    <quote>home</quote> server is looked up first, the message is transferred
    to that server first and then, the respective server (that the user
    belongs to) is responsible for delivering the message to the user or
    saving it until the user logs in. Therefore, two possible connection types
    take place in XMPP. Client-to-server communication is the first one, when
    the clients can talk only to their <quote>home</quote> server. Then,
    server-to-server communication is designed for delivering the messages to
    the users at different domains. When two servers are exchanging any data,
    direct connection to the target server is established. This approach is
    dissimilar to the way SMTP servers exchange e-mail messages. It helps to
    prevent address spoofing or spamming.
    <citation>xmpp-the-definitive-guide</citation></para>

    <para>XMPP has been chosen as the communication protocol for this thesis
    topic - Talker application. XMPP has been verified by big companies such
    as Google or Facebook. In addition, the openness of the protocol allows
    very easy connection to existing wide communication networks, using their
    server infrastructure, client software and existing user base.</para>

    <sect1 id="chap-xmpp-stanzas">
      <title>XML Stanzas - XMPP building blocks</title>

      <para>As mentioned in the introduction to this chapter, when XMPP
      connection is established, two streams are opened and both the client
      and the server can send any XML elements at any time. The meanings of
      various pieces of XML are described in this section.</para>

      <para>There are three three basic XML elements that every XMPP
      communication consists of. Those are
      <computeroutput>&lt;message/&gt;</computeroutput>,
      <computeroutput>&lt;presence/&gt;</computeroutput> and
      <computeroutput>&lt;iq/&gt;</computeroutput> (which stands for
      Info/Query), altogether called
      <computeroutput>Stanza</computeroutput><indexterm>
          <primary>stanza</primary>
        </indexterm>s. <citation>xmpp-the-definitive-guide</citation> Each
      stanza element usually contains several attributes which specify the
      exact meaning of it. The actual content is usually placed in the element
      body. Example message<indexterm>
          <primary>XMPP</primary>

          <secondary>message</secondary>
        </indexterm> stanza can look like this:</para>

      <programlisting>&lt;message from="pavel.smolka@celebrio.cz/talker"
         to="tomas.pitner@celebrio.cz"
         type="chat"&gt;
    &lt;body&gt;Hello, how are you?&lt;/body&gt;
&lt;/message&gt;</programlisting>

      <para>The attributes <computeroutput>from</computeroutput> and
      <computeroutput>to</computeroutput> stand for the sender and recipient
      of the message. Actually, the value the sender sets to the
      <computeroutput>from</computeroutput> attribute (or whether she entirely
      leaves it out) does not matter. The <quote>home</quote> XMPP server the
      sender is registered at (in this example, it would be the one running at
      <computeroutput>celebrio.cz</computeroutput>) has to set the from
      attribute according to the real user name and domain name. This is one
      of the interesting defensive mechanisms distinguishing XMPP from other
      communication protocols as SMTP.</para>

      <para>You might have noticed that <computeroutput>from</computeroutput>
      field does not contain only the XMPP address. There is a
      <emphasis>resource</emphasis><indexterm>
          <primary>XMPP</primary>

          <secondary>resource</secondary>
        </indexterm> identifier after the domain name. Since it is possible to
      connect multiple times with the same user name, the resource makes a
      difference between the sessions of the same user. In addition, it is
      useful information for other peers the user might communicate with. It
      is usual to set the resource field according to the place the user logs
      from or the device she uses.</para>

      <para>Message stanza receiving is not acknowledged so the sender has no
      information whether it has been delivered successfulIy or not. On the
      contrary, IQ stanza <indexterm>
          <primary>XMPP</primary>

          <secondary>IQ</secondary>
        </indexterm> can be used in case the sender requires the answer - it
      is usually a <emphasis>query</emphasis>. The best example is obtaining
      the contact list - in XMPP terms called
      <emphasis>Roster</emphasis><indexterm>
          <primary>XMPP</primary>

          <secondary>roster</secondary>
        </indexterm>:</para>

      <programlisting>&lt;iq id="123456789" type="get"&gt;
  &lt;query xmlns="<emphasis>jabber:iq:roster</emphasis>"/&gt;
&lt;/iq&gt;</programlisting>

      <para>Then, the server sends the result as another IQ stanza (notice
      that <computeroutput>id</computeroutput> attribute remains the same
      while the <computeroutput>type</computeroutput> attribute changed):
      <citation>xmpp-the-definitive-guide</citation></para>

      <programlisting>&lt;iq id="123456789" type="result"&gt;
  &lt;query xmlns="jabber:iq:roster"&gt;
    &lt;item jid="whiterabbit@wonderland.lit"/&gt;
    &lt;item jid="lory@wonderland.lit"/&gt;
    &lt;item jid="mouse@wonderland.lit"/&gt;
    &lt;item jid="sister@realworld.lit"/&gt;
  &lt;/query&gt;
&lt;/iq&gt;</programlisting>

      <sect2 id="chap-xmpp-subscriptions">
        <title>Subscription mechanism</title>

        <para>The third letter in the abbreviation XMPP stands for
        <emphasis>presence</emphasis><indexterm>
            <primary>XMPP</primary>

            <secondary>presence</secondary>
          </indexterm>, practically represented by sending
        <computeroutput>presence</computeroutput> stanzas. It is one of the
        important signs of real-time communication (not only in XMPP but
        overall) that the peers can see each other presence - whether the
        other side is online, alternatively whether it is available or busy.
        However this functionality is desired, it might slip to a huge privacy
        breach when anyone could see your presence status.</para>

        <para>XMPP solves the privacy problem with the subscription mechanism.
        Each user has full control over the peers who can monitor her online
        status. If anyone else wants to track the presence status, the
        subscription request must be sent. When received, the user decides
        whether the permission will be granted or not. Unfortunatelly, the
        subscription request can be blocked by the respective
        <quote>home</quote> XMPP server of the user we try to reach. To be
        tangible: there are two widely used XMPP providers -
        <computeroutput>jappix.com</computeroutput> and
        <computeroutput>gmail.com</computeroutput>. If the user of the former
        sends the subscription to another user registered at the latter, it is
        not guaranteed it will be delivered (actually, it isn't, see <xref
        linkend="chap-interoperability-problems" /> for details). It is one of
        the drawbacks of the opened protocol that one can never be sure that
        the other party co-operates.</para>
      </sect2>
    </sect1>

    <sect1 id="chap-bosh">
      <title>XMPP over BOSH</title>

      <para>Having described XMPP as communication protocol over TCP, it might
      be unclear how it is related to the thesis topic. XMPP is nice and
      mature technology and it would be nice to use it in web browser but it
      does not support communication over HTTP. Fortunately, XMPP offers many
      extensions (indeed, the first letter X stands for
      <quote>extensible</quote>) providing additional functionality. In fact,
      those are XMPP extension <emphasis>protocols</emphasis> and so they are
      called XEPs<indexterm>
          <primary>XEP</primary>
        </indexterm>.</para>

      <para>This section briefly describes one of XEP exensions called
      BOSH<indexterm>
          <primary>BOSH</primary>
        </indexterm> (XEP-0124) designed for transferring XMPP over
      HTTP.<footnote>
          <para>In fact, there are two more XEPs related to HTTP. First of
          them, XEP-0025: Jabber HTTP Polling, has been replaced by BOSH. It
          is obsolete and recommended not to be used any longer.
          <citation>xep-0025</citation> The other one is XEP-0206: XMPP Over
          BOSH. It is currently used standard but it constitutes just a
          supplement for BOSH. XEP-0206 describes mainly the session creation
          and authentication in BOSH. <citation>xep-0206</citation></para>
        </footnote> <citation>xep-0124</citation> The idea behind this
      extension is very simple: BOSH uses HTTP long polling technique
      (described in <xref linkend="chap-http-long-polling" />) to imitate
      bidirectional TCP communication necessary for XMPP. We can imagine BOSH
      (it is a protocol itself) as a middle layer protocol or wrapper protocol
      between HTTP (only capable of sending requests from client to server)
      and XMPP (understanding only the XML stanzas). BOSH requests and
      responses are subset of all conceivable HTTP requests or responses (they
      include all HTTP features such as HTTP method in request or status code
      in the response). The constraint defined by BOSH protocol restricts the
      body part to have a specific structure.</para>

      <para>Each BOSH request or response body is valid XML, which wraps up
      XMPP stanzas in special <computeroutput>&lt;body /&gt;</computeroutput>
      element. For the purposes of the protocol itself, it is also possible to
      send just the <computeroutput>body</computeroutput> element with no
      child (XMPP) nodes - for example when starting the session or reporting
      an error. So, the XMPP part of the communication is separated from BOSH
      quite well: the former is represented by payload elements inside the
      <computeroutput>body</computeroutput>, the latter consists of
      <computeroutput>body</computeroutput> attributes. Have a look at example
      of BOSH request: <citation>xep-0124</citation><programlisting>POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 188

&lt;body rid='1249243562'
      sid='SomeSID'
      xmlns='http://jabber.org/protocol/httpbind'&gt;
  &lt;message to='tomp@example.com'
           xmlns='jabber:client'&gt;
    &lt;body&gt;Good morning!&lt;/body&gt;
  &lt;/message&gt;
  &lt;message to='pavel@example.com'
           xmlns='jabber:client'&gt;
    &lt;body&gt;Hey, what&amp;apos;s up?&lt;/body&gt;
  &lt;/message&gt;
&lt;/body&gt;</programlisting> As you can see, the request header is ordinary
      HTTP header. So much for the HTTP part. The request body consists of
      <computeroutput>body</computeroutput> element which represents BOSH
      layer, along with the element attributes (plus namespace).
      <computeroutput>sid</computeroutput> attribute represents the session
      ID, identifying the connection and not mutated during one session. The
      other one, <computeroutput>rid</computeroutput>, stands for request ID
      and it gets incremented with each request. Ultimately, the child nodes
      of the <computeroutput>body</computeroutput> represent two XMPP stanzas
      (both of message type). It is obvious that multiple XMPP stanzas can be
      transmitted via single BOSH request. TODO extract RID/SID/handshake
      stuff to separate sub-section here?</para>

      <para>BOSH protocol is an important part of the Talker application
      implemented as a programming part of the thesis. Despite it bears the
      disadvantages of HTTP bidirectional communication, as described before,
      it is the only reliable technology nowadays. There are several mature
      client-side libraries using BOSH (such as Strophe.js we used) and it is
      also easy to install, configure and run BOSH extension at the server
      side. HTTP server usually hands over the BOSH HTTP request to XMPP
      server with relevant module enabled, as described in
      <citation>setting-up-bosh</citation>. However, the server side XMPP is
      not the topic of this thesis so it is not further discussed.</para>
    </sect1>

    <sect1 id="chap-xmpp-ws">
      <title>XMPP over WebSockets</title>

      <para>Since there is possibility to transmit any data from the web
      browser application to the server via WebSockets, it could be handy to
      transfer XMPP stanzas using WS as well. Using WebSockets saves a lot of
      overhead and fixes some issues that can happen with BOSH (for example
      unreliability of HTTP). Generally it works, yet the programmer should be
      wary of several pitfalls that WebSockets bring. First, the server side
      must accept WebSockets connection. Usually, the XMPP servers does
      provide such functionality through addons or modules.<footnote>
          <para>Additional module for Prosody server has been used as well
          when implementing Talker application. The process of installation
          includes downloading the module, adding it to the path that Prosody
          searches for modules. Then, it must be enabled in the configuration
          file. Moreover, <computeroutput>luajit</computeroutput> and
          <computeroutput>liblua5.1-bitop0</computeroutput> packages had to be
          downloaded for the module to work correctly (assuming Debian/Ubuntu
          on the server side).</para>
        </footnote> Provided that the WebSocket extension to the XMPP server
      is running on localhost, using WS to connect to the server is as simple
      as follows:</para>

      <programlisting>var ws = new WebSocket("ws://localhost:5280/xmpp-websocket/", "xmpp");
// XMPP handshake takes place here, omitting in the example
ws.send(
 "&lt;message to='lasaris@example.com' xmlns='jabber:client'&gt; \
    &lt;body&gt;Hello, lab!&lt;/body&gt; \
  &lt;/message&gt;"
);</programlisting>

      <para>Probably the most important difference compared to BOSH is that
      every WebSocket message (i.e. one chunk of incoming or outcoming
      communication - can be compared to BOSH request) can contain only one
      XMPP stanza. <citation>xmpp-over-websockets</citation> It means that the
      peer cannot send more WS messages together, even if they are available
      by the time the WS message is sent.</para>

      <para>The main drawback of using XMPP over WebSockets is still partial
      lack of support both in the web browsers (which includes WS support
      itself and the JavaScript XMPP libraries) and on the XMPP servers.
      Nevertheless, there is huge trend of implementing it at all
      sides.<footnote>
          <para>You might want to have a look at some of the current
          discussions concerning client-side (i.e. JavaScript)
          libraries:</para>

          <para><itemizedlist>
              <listitem>
                <para><ulink
                url="https://github.com/metajack/strophejs/issues/68">https://github.com/metajack/strophejs/issues/68</ulink></para>
              </listitem>

              <listitem>
                <para><ulink
                url="https://github.com/metajack/strophejs/pull/95">https://github.com/metajack/strophejs/pull/95</ulink></para>
              </listitem>

              <listitem>
                <para><ulink
                url="http://stackoverflow.com/questions/1850162/">http://stackoverflow.com/questions/1850162/</ulink></para>
              </listitem>
            </itemizedlist></para>
        </footnote></para>

      <para>TODO create diagram here (XMPP server - plugin - incoming
      connection vs xmpp server - standard connection). Probably for both BOSH
      and WS.</para>
    </sect1>

    <sect1>
      <title>Jingle - XMPP media extension<indexterm>
          <primary>Jingle</primary>
        </indexterm><indexterm>
          <primary>XEP</primary>
        </indexterm></title>

      <para>Not only can XMPP send text messages but it also supports
      transferring various multimedia streams. Audio and video above all, yet
      it is also possible to send raw binary files. All the functionality
      related to those <quote>advanced</quote> transfers is being managed by
      XMPP extension called Jingle. According to the protocol extension, the
      two parties negotiate the data stream using standard IQ stanzas
      (described in <xref linkend="chap-xmpp-stanzas" />). Then, the stream is
      established according to the prearranged entries.
      <citation>xep-0166</citation></para>

      <para>Although Jingle is relatively old and mature XMPP extension, it
      has not been used in web browsers for a long time. Web browsers had not
      supported multimedia transfers due to the troublesome bidirectional
      communication and difficult access to multimedia devices (microphone and
      webcam). Ergo Jingle has not been used in Talker application either -
      the main reason for not using Jingle in Talker application is lack of
      JavaScript libraries supporting it. There is just unofficial
      Strophe.js<indexterm>
          <primary>Strophe.js</primary>
        </indexterm> plugin for Jingle published by Michael Weibel, not very
      well maintained and relying on the WebRTC technology<indexterm>
          <primary>WebRTC</primary>
        </indexterm>.<footnote>
          <para>See <ulink
          url="http://candy-chat.github.com/candy-webrtc/">http://candy-chat.github.com/candy-webrtc/</ulink>
          and <ulink
          url="https://github.com/mweibel/strophejs-plugins/tree/jingle">https://github.com/mweibel/strophejs-plugins/tree/jingle</ulink>
          for the references.</para>
        </footnote> Therefore, Jingle is not described further in the thesis,
      it is mentioned here just as an option for the future.</para>

      <para>Anyway, C/C++ Jingle libraries seem to be quite mature and ready
      to be used in the desktop client applications. Above all, there is
      library developed by Google called libjingle<indexterm>
          <primary>libjingle</primary>
        </indexterm>, supporting multi-user audio/video/file transfers.
      <citation>libjingle</citation> Google seems to beleive that Jingle is
      the right protocol for developing multimedia client that can be used by
      everyone. They even sidelined original Google Talk VOIP protocol and
      switched to Jingle as their <quote>primary signalling protocol for voice
      calls</quote>, in Gmail, iGoogle and Orkut.
      <citation>jingle-is-the-future</citation></para>
    </sect1>

    <sect1 id="chap-interoperability-problems">
      <title>Interoperability problems</title>

      <para>Google Talk has been the biggest XMPP provider for a long time.
      Smaller XMPP networks, including Celebrio, took advantage of the
      distributed environment and interoperability within various XMPP
      domains. It seems, however, that Google starts to prevent the users
      registered at other server from contacting Google users. More precisely,
      the subscription requests (described in <xref
      linkend="chap-xmpp-subscriptions" />) from other domains are not
      delivered to Google users. <citation>google-closing-xmpp</citation> It
      is very unexpected and unpleasant for all - smaller XMPP providers,
      their users and for the Google users too, after all. Google confirmed
      that throwing the subscription requests away is an attempt to reduce the
      amount of spam delivered to Google users.
      <citation>spammy-invites</citation></para>

      <para>If Google closed its network for the people from other domains, it
      would be the second huge social network, along with Facebook, which does
      provide XMPP to its users but does not allow them to fully collaborate
      with everyone else. Unlike Facebook, Google users can still send the
      subscription requests and therefore initiate the connection (in the
      long-term meaning), but this option can be disabled in the future
      too.</para>

      <para>Fortunatelly, severals weeks later, Google announced that the
      alleged spam problems are gone and XMPP network is opened again.
      <citation>spammy-invites-update</citation> Hence, the users having their
      accounts registered at external XMPP providers can send invites
      (subscription requests) to Google users without problems.</para>
    </sect1>
  </chapter>

  <chapter id="chap-xmpp-in-javascript">
    <title>JavaScript XMPP client</title>

    <para>In this chapter, the two previous topics are connected together. The
    possibilities of bidirectional communication, necessary for receiving
    messages real-time, were mentioned in <xref linkend="chap-rtc" />. In
    simple terms, such techniques (HTTP long polling, WebSockets, ...) stand
    for the <quote>transport</quote> layer of the application, handling the
    low-level connection and transferring the messages from the server to
    client and vice versa. Above this layer, there is a <quote>real
    communication protocol</quote> definition, which would be XMPP in our
    case. It does not make any sense to divide the protocols according to the
    OSI Model<indexterm>
        <primary>OSI Model</primary>
      </indexterm> (ISO/IEC 7498-1) since everything above HTTP (including
    HTTP itself) takes place at application layer (number 7). On <xref
    linkend="fig-isoosi" />, the communication between layers is depicted for
    the case of an application initializing Jingle multimedia stream (XEP
    extension) over XMPP, using BOSH mechanism sending and receiving the
    messages via HTTP. All of the protocols have been described (or at least
    mentioned previously). XMLHTTPRequest is rather API than protocol, its
    usage should be, however, displayed as well.</para>

    <figure id="fig-isoosi">
      <title>Complexity of the communication protocols at application
      layer</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="vp/isoosi.pdf" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>It is nor simple neither easy to take care about such a broad range
    of protocols in the application, handling the communication correctly at
    all levels. Fortunately, there are several existing libraries serving the
    lower level protocols. Specifically, most of them would conceal HTTP
    requests as well as BOSH and simplifying the XMPP layer. One of the
    JavaScript libraries, used when implementing Talker application, called
    Strophe, is described in this chapter. There are also other libraries for
    creating XMPP client in web browser, for example JSJaC. However, JSJaC is
    not that popular (and thus verified) as Strophe.js and has not been used
    in Talker application. It is mentioned just as another option. It would be
    also possible to handle whole XMPP/BOSH/HTTP stack manually and parse XML
    with</para>

    <para>All along the thesis, we assume the application runs in the web
    browser. After all, the thesis title contains it. Therefore, mostly
    JavaScript libraries and tools for building a client application within a
    web browser are be mentioned in this chapter. Yet, it is certainly
    possible to implement XMPP client at the server side or as an independent
    desktop appliacation. In the end of this chapter, some server-side
    implementations are also mentioned due to the security reasons. See <xref
    linkend="chap-server-side-xmpp-client" /> for details.</para>

    <sect1>
      <title>Strophe.js - JavaScript XMPP library<indexterm>
          <primary>Strophe.js</primary>
        </indexterm></title>

      <para>Strophe.js<footnote>
          <para>Strophe.js is sometimes refered only as
          <quote>Strophe</quote>. However, Strophe is, strictly speaking, a
          name of the collection of libraries, from which only one is
          Strophe.js, the JavaScript tool described in this chapter.</para>
        </footnote> is complex but simple to use JavaScript library for
      creating XMPP client in web browser application, initially created and
      further maintained by Jack Moffitt. Since XMPP is the protocol powering
      the Talker application, Strophe.js appeared to be a proper tool for
      creating it. In fact, Strophe handles whole <quote>transport</quote>
      layer for the application, as it was described in the introduction to
      this chapter.</para>

      <para>Strophe.js is uses BOSH protocol (based on HTTP long polling) for
      sending messages and receiving the updates from the server. There is an
      unofficial project fork using WebSockets but it has not been accepted by
      the community yet. The main reason is probably unfinished standard for
      handling XMPP stanzas in WebSocket stream, currently available as a
      draft. <citation>xmpp-over-websockets</citation></para>

      <para>In the following sections, the essential topics concerning
      Strophe.js are mentioned. It mostly comprises Strophe.js basic usage and
      philosophy, including using the plugins for getting additional
      functionality beyond the library itself.</para>

      <sect2>
        <title>New connection</title>

        <para>Since XMPP client is intended to communicate with various nodes
        in the Internet, the connection represents the essence of the
        application. Strophe connects to the BOSH server through which it
        communicates with the rest of the XMPP world. Its URL is stated as
        BOSH_SERVICE variable in the following example. Setting up the
        connection is simple:</para>

        <programlisting>var BOSH_SERVICE = 'https://bind.jappix.com/',
    jid  = 'pavel@example.com',
    pass = 'mysecretpassword',
    onConnect = function(status) { /* implmementation */ };
var connection = new Strophe.Connection(BOSH_SERVICE);
connection.connect(jid, pass, onConnect);</programlisting>

        <para>Apart from the BOSH service URL, Jabber ID and password is
        passed to the connection method.</para>

        <para>The last argument stands for the callback function which is
        triggered every time the connection status is changed. The status is
        passed as an argument to the function. It must take one of
        Strophe.Status enum values, for example
        <computeroutput>Strophe.Status.CONNECTED</computeroutput> when the
        connection is established. Example onConnect callback can look like
        this:</para>

        <programlisting>onConnect = function(status) {
  if (status === Strophe.Status.CONNECTED) {
    connected();
  } else {
    console.log('Connecting status: ' + status);
  }
};</programlisting>

        <para>When the connection is established,
        <computeroutput>connected</computeroutput> function is invoked.
        Usually, this is the place the event handlers are attached to the
        connection (passed as <computeroutput>this</computeroutput> in the
        context of onConnect function). Event handlers are described in <xref
        linkend="chap-strophe-events" />.</para>
      </sect2>

      <sect2 id="strophe-attach">
        <title>Attaching to an existing connection</title>

        <para>There is one problem with the process mentioned above.
        Generally, passing confidential data to JavaScript hard-coded in the
        rendered HTML files (i.e. within
        <computeroutput>&lt;script/&gt;</computeroutput> tag) constitutes a
        security issue<indexterm>
            <primary>security</primary>
          </indexterm>. As you may have noticed, the previous example
        incorporates a password in the JavaScript snippet, which is exactly
        this kind of problem. Firstly, the page can be stored in plain text as
        a browser cache. Secondly, the web page is available for anyone within
        the browser history tool so the password can be easily tracked down.
        Last but not least, unless TLS is used, the web page traverses
        Internet unencrypted. <citation>attached-to-strophe</citation></para>

        <para>Luckily, Strophe.js comes with the possibility to attach to the
        existing connection. It basically means the initial BOSH handshake
        takes place at the server side. A connection is established and the
        server-side based XMPP client comes up with the session identifier and
        current request number (SID and RID, mentioned in <xref
        linkend="chap-bosh" />).<indexterm>
            <primary>SID</primary>
          </indexterm><indexterm>
            <primary>RID</primary>
          </indexterm> Afterwards, RID and SID are sent to the client (either
        within the initial HTML template or as a separate JSON response). RID
        and SID represent tokens which are secure enough to identify the
        client. However, unlike password, in case of being disclosed to the
        attacker, only a single session is compromised.
        <citation>xmpp-in-javascript</citation></para>

        <para>Attaching to an existing connection in the JavaScript
        application using Strophe.js is quite simple, similar to initializing
        a new connection: <citation>xmpp-in-javascript</citation>
        <programlisting>var connection = new Strophe.Connection(BOSH_SERVICE);
connection.attach(jid, sid, rid, onConnect);</programlisting></para>
      </sect2>

      <sect2 id="chap-strophe-events">
        <title>Event handling</title>

        <para>Both JavaScript and XMPP are typical fields of using
        asynchronous processing of incoming events. The idea is simple.
        Generally, we specify the actions we are interested in and attach the
        event handlers to each of them. Event handler<indexterm>
            <primary>event handler</primary>
          </indexterm>, function or method, is invoked as soon as the
        specified action occurs. The event handlers, defered functions, are
        called callbacks<indexterm>
            <primary>callback</primary>
          </indexterm>. Not only Strophe but all other asynchronous libraries
        (event-based or request/response) in JavaScript are based on
        callbacks, for example popular jQuery AJAX functions.<footnote>
            <para>http://api.jquery.com/jQuery.ajax/</para>
          </footnote></para>

        <para>When the idea of callback is clear, applying them to Strophe.js
        event handling is simple, see the example below. The first parameter
        is the callback itself (its name or anonymous function implemented on
        site). The <quote>areas of concern</quote> are specified as the
        remaining five parameters. The example callback here triggers every
        time the chat message comes, i.e.
        <computeroutput>message</computeroutput> stanza with attribute
        <computeroutput>type='chat'</computeroutput>. The parameters specified
        as null means that any value of that place is processed by the
        handler. So, the message sender, which can be specified by the
        next-to-last argument, can be anyone:</para>

        <programlisting>connection.addHandler(onChatMessage, null, 'message', 'chat', null,  null);</programlisting>

        <para>The callback function receives the incoming stanza object in
        Strophe-specific pre-parsed format. Then, the object can be queried
        (with jQuery or plain JavaScript selectors), such as at the example
        below:</para>

        <programlisting>onChatMessage = function(msg) {
  var messageBody = msg.getElementsByTagName('body');
  console.log("Message text: " + messageBody);
  return true;
}</programlisting>

        <para>The last line in the function is common pattern in Strophe.js
        the developer must be aware of. Each handler must return
        <computeroutput>true</computeroutput> (or any other value which
        evaluates to <computeroutput>true</computeroutput>) to stay bound to
        the event. If <computeroutput>false</computeroutput> is returned, the
        handler is unattached and it is not triggered anymore.
        <citation>xmpp-in-javascript</citation> So
        <computeroutput>false</computeroutput> return values are proper for
        disposable callbacks, used only once.</para>
      </sect2>

      <sect2>
        <title>Stanza builders</title>

        <para>Whole XMPP protocol is represented by XML elements called
        stanzas, transferred between a client and a server. There are various
        approaches to create XML document structure in JavaScript. Using
        jQuery is the most common way to do so. jQuery object, created by
        jQuery <computeroutput>$()</computeroutput> function, represents XML
        structure tree which can be extended using methods like
        <computeroutput>append()</computeroutput>,
        <computeroutput>wrap()</computeroutput> and
        <computeroutput>after()</computeroutput>.
        <citation>jquery-api</citation></para>

        <para>Strophe.js comes up with completely independent XML creator,
        however inspired by jQuery. <citation>xmpp-in-javascript</citation>
        The functionality is to be found within
        <computeroutput>Strophe.Builder</computeroutput> object. It allows the
        library user to create XML elements such as follows:
        <citation>strophe-api</citation><programlisting>$iq({to: 'tomas', from: 'pavel', type: 'get', id: '1'})
    .c('query', {xmlns: 'strophe:example'})
    .c('example')
    .toString()</programlisting>The previous example code creates IQ stanza
        and the following snippet represents a result:<programlisting>&lt;iq to='tomas' from='pavel' type='get' id='1'&gt;
  &lt;query xmlns='strophe:example'&gt;
    &lt;example/&gt;
  &lt;/query&gt;
&lt;/iq&gt;</programlisting>Bijection between the two pieces of code is
        obvious. The only catch could be not yet defined
        <computeroutput>$iq()</computeroutput> function. Similarly as jQuery,
        Strophe.js provides shorthand functions
        <computeroutput>$msg()</computeroutput>,
        <computeroutput>$pres()</computeroutput>, and
        <computeroutput>$iq()</computeroutput> for creating all three kinds of
        stanzas, along with <computeroutput>$build()</computeroutput> function
        for making any kind of element. Therefore, creating presence stanza
        and sending it using Strophe.js can look as simple as the following
        example:</para>

        <programlisting>this.send($pres().tree());</programlisting>
      </sect2>

      <sect2>
        <title>Logger</title>

        <para>Strophe.js does not conceal information about its operation. It
        contains several logger methods, divided by log level, mostly used by
        the library itself (it however can be used by the user code as well).
        Logging functionality is inserted in the main Strophe object itself.
        Calling the logger from the library methods is thus simplier, however
        it can hardly be replaced by another logger (all at once) defined by
        the user. All logger methods point to the ultimate log() method, which
        just returns by default. The intention of the library authors is
        providing this method to be overridden by custom user code. So is done
        in the Talker application, as described in <xref
        linkend="chap-talker" />.</para>
      </sect2>
    </sect1>

    <sect1 id="chap-strophe-plugins">
      <title>Strophe plugins</title>

      <para>XMPP has been designed to be extensible (even by the protocol
      name) by various XEP extensions. Strophe.js follows the same direction
      and provides a simple way for the plugins to be added. And fortunately,
      there is not just the possibility to create the plugin, there are plenty
      existing extensions available publicly at GitHub. In this section,
      general way how to use the pulgins is described as well as brief
      overview of several plugins used in Talker application.</para>

      <para>Each Strophe.js plugin is contained in separate JavaScript file,
      included to the application which uses it. The common name convention
      for plugin file is <computeroutput>strophe.myplugin.js</computeroutput>.
      <citation>xmpp-in-javascript</citation> Whole plugin functionality is
      packed to JavaScript object and passed to Strophe as follows:</para>

      <programlisting>Strophe.addConnectionPlugin('myplugin',
{
  // plugin methods and properties

  init: function(connection) {
    // init body
  },

  exampleMethod: function() { /* ... */ }
});</programlisting>

      <para>Among all plugin object properties and methods,
      <computeroutput>init()</computeroutput> is explicitly quoted. That's
      because <computeroutput>init()</computeroutput> method is run as the
      plugin setup automatically by Strophe, after the new connection object
      has been created (which is passed to the method as the only parameter).
      The plugin can save the connection object for later use.
      <citation>xmpp-in-javascript</citation> When the plugin is initialized,
      any method (such as exampleMethod() from the example above) can be
      invoked using the plugin name property of the connection object, as
      follows:</para>

      <programlisting>connection.myplugin.exampleMethod();</programlisting>

      <para>In the Talker application, several Strophe plugins are used.
      Particularly, the application uses Roster plugin, which provides easier
      handling of the user contact list (XMPP Roster).<indexterm>
          <primary>XMPP</primary>

          <secondary>roster</secondary>
        </indexterm> The basic use cases comprise retrieving the roster from
      the server by calling
      <computeroutput>connection.roster.get(onRoster)</computeroutput>,
      usually as soon as the Strophe connection is established. The parameter
      represents callback function invoked when the server responds and the
      contact list is fetched. Of course, the contact list is no static
      structure and it gets changed as the contacts log in and out. All
      incoming changes are captured by the plugin and processed by the handler
      method, if it has been set up. For example, the following line of code
      sets up <computeroutput>presenceListener</computeroutput> function as a
      callback which is triggered any time the contact list is changed. The
      structure of method parameters is exactly the same as in case of
      ordinary Strophe handlers.</para>

      <programlisting>connection.roster.registerCallback(presenceListener, null, 'presence', null, null,  null);</programlisting>
    </sect1>

    <sect1 id="chap-server-side-xmpp-client">
      <title>Server-side implementations</title>

      <para>Connection attachment, as described in <xref
      linkend="strophe-attach" />, is used in Talker application. Apart from
      the security advantages and the possibility of boosting performance by
      pre-creating the connections, there are also some drawbacks in this
      approach. The most important is a need of an XMPP client (or a
      connection manager) implemented in the server-side language,
      alternatively running Strophe itself in the server-side JavaScript
      environment.</para>

      <para>There are several available solutions. For example, Python XMPP
      connection manager called Punjab<footnote>
          <para>https://github.com/twonds/punjab</para>
        </footnote> is well-suited for <quote>pre-creating</quote> BOSH
      connections. Speaking of PHP (as it is the language Celebrio is powered
      by), there is JAXL<footnote>
          <para>https://github.com/abhinavsingh/JAXL</para>
        </footnote> library which has been used in this project. Anyway, it is
      not very steady tool. I have found two bugs in this library, not
      mentioning poor documentation. One minor bug has already been accepted
      by the library author to the official branch,<footnote>
          <para>https://github.com/abhinavsingh/JAXL/pull/30</para>
        </footnote> the other is still being opened by the time of finishing
      this thesis.<footnote>
          <para>https://github.com/abhinavsingh/JAXL/issues/32</para>
        </footnote>Although the latter might not be a real issue, it still
      prevents from successful BOSH connection establishment.</para>
    </sect1>
  </chapter>

  <chapter id="chap-talker">
    <title>Talker - IM client in web browser</title>

    <para>As people use computers and the Internet more and more, they do not
    avoid interaction with others. On the contrary, communication and sharing
    represents essential part of current web systems. The social networks
    provide mostly the way to communicate with other people and they are used
    by millions. The same rules are valid for Celebrio, smart and simple
    application imitating the interface of operating system. Therefore,
    application Talker has been designed and implemented to serve in Celebrio
    as real-time communicator or instant messenger client.</para>

    <para>In this chapter, Talker application is described in depth. There are
    the requirements listed, both functional and non-functional. Further on,
    the used technologies are mentioned and compared to possible
    substitutions. Some of the technologies, are described in individual
    dedicated chapters, such as Strophe.js in <xref
    linkend="chap-xmpp-in-javascript" /> so that only the parts specific to
    Talker are mentioned. Ultimately, several sections are dedicated to the
    implementation and testing. Source codes of the application are packed as
    the thesis supplement, they are however unlikely to run without Celebrio
    which was the application built for.</para>

    <sect1>
      <title>Analysis</title>

      <para>Firstly, this section describes the application analysis, i.e.
      what the requirements are. It includes both the non-functional
      requirements (such as the platform the application must run or the
      system it has to cooperate with) and the probable usage by the
      customers. After the requirements are clear, it must be decided how to
      implement the desired functionality. That is where design takes place.
      Application design springs from the analysis and it just further
      decomposes and clarifies the way it will be implemented. The design part
      is crucial because the sooner possible glitches are unveiled and fixed
      the lower the cost is. The last thing which has to be considered and
      decided is the <quote>stack</quote> of proper technologies to be used,
      with regard to the both non-functional requirements and the design
      complexity.</para>

      <sect2>
        <title>Value proposition</title>

        <para>The first step when creating a successful application (or even a
        whole ecosystem of application such as Celebrio is) should start by
        considering the added customer (or more precisely user) value. Value
        proposition mainly contemplates the possible market, the users and the
        benefits they would have from using our application, i.e. Talker.
        <citation>value-proposition</citation> Our target market is
        well-defined and quite easy to interview: the elderly people. More
        than a half of the elderly use (or are willing to use) the real-time
        communication tool, comprising both text chat and video calls. They
        prefer it to be interoperable so they can speak to the people not
        using directly the same software tool as well.</para>

        <para>Talker offers the benefit of running within Celebrio, the
        <quote>operating system</quote> designed specifically for the elderly.
        The compatibility is limitless within XMPP network. Unlike many
        communication tools, it provides text chat and video calling bundled
        together so the user just uses it as a <quote>dialogue</quote>
        application, no matter which way she feels like communicating at the
        moment.</para>
      </sect2>

      <sect2>
        <title>Use cases</title>

        <para>The use case analysis springs from two information sources. The
        first one is based on author's own opinion and experience with online
        communication tools. The other part is supported by user interviews
        and market research. In other words, the potential customers said what
        their probable use cases would look like. However, there is no
        quantitative data analysis on this topic.</para>

        <figure id="talker-uc">
          <title>Talker use case diagram</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/talker-uc.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>As displayed at <xref linkend="talker-uc" />, Talker use case
        analysis is quite simple. There are two actors operating the system,
        Celebrio user and remote XMPP server. The former uses all GUI
        application components, i.e. she can display the contact list with
        current contact present statuses, enter the text chat (which includes
        sending and receiving new messages) and set up a video call. A contact
        list, the first application screen, is further described in <xref
        linkend="chap-contact-list" />. When any of the contact is clicked at,
        communication view is displayed so the user can read the incoming
        messages, send a new message or start a video call. Several
        application screenshots are pictured in <xref
        linkend="appendix-screenshots" />.</para>

        <para>There is one more actor displayed at <xref
        linkend="talker-uc" />. It is remote XMPP server, communicating with
        the application indirectly through established connection. When a new
        message appears at the server, it is pushed to the application and
        handled it as an incoming message. Every new message, received or
        sent, is appended to the <quote>chat history</quote>, as usual in
        similar IM clients.</para>
      </sect2>

      <sect2 id="sect-choosing-tech">
        <title>Choosing technologies</title>

        <para>The use cases and value proposition imply some technologies and
        tools that are obvious to be used and also some constraints. At the
        lowest level, Talker is part of web application and it must run in the
        web browser environment. With respect to interactivity and real-time
        behaviour, it must be powered by <emphasis>JavaScript</emphasis>.
        There are other possibilities such as Adobe Flash<indexterm>
            <primary>Flash</primary>
          </indexterm> or browser plugins, they however do not play well with
        various environments.</para>

        <para>XMPP has been chosen as the communication protocol for sending
        the messages. It is opened, mature and interoperable technology,
        facilitating just plugging in the new part of world-wide network. XMPP
        is described in <xref linkend="chap-xmpp" /> and JavaScript XMPP
        framework in <xref linkend="chap-xmpp-in-javascript" />. Such
        nontrivial application, as Talker is, deserves fine client-side
        framework so the connections, states, contact lists and all messages
        are not only stored in DOM but also managed by JavaScript itself. In
        the last years, there are a lot of MVC<footnote>
            <para>MVC stands for Model - View - Controller, common three-tier
            architecture. Model is responsible for data layer, View stands for
            presentation layer. The function of controller varies from one
            implementation to another, but it is mostly responsible for
            dispatching the user actions and controlling application flow, for
            example redirecting.</para>
          </footnote> JavaScript frameworks. When implementing the
        application, I have tried Backbone, Angular, Knockout and Ember - all
        modern MVC JavaScript frameworks. After short period of testing, I
        chose Ember as the best one. Framework overview, various advantages
        and also some pitfalls are mentioned in <xref
        linkend="chap-ember" />.</para>

        <para>The last important field to be covered are the video calls. On
        no account did I consider to implement it from scratch. Anyway, there
        are several handy tools and frameworks which could have been used.
        After all, I decided to use OpenTok, video call library described in
        <xref linkend="chap-opentok" />, mostly for its wide compatibility. It
        even supports WebRTC in its newest version, which is considered to be
        the future of media applications on web.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Application architecture</title>

      <para>As mentioned in the previous section, Talker is not trivial
      application which could be served by several inline scripts manipulating
      the DOM. It has to handle states, keep track of all simultaneous chats
      and dispatch all messages to appropriate contacts. Those reasons led to
      semi-modular architecture, pictured at <xref
      linkend="fig-talker-modules" />. Modules inside the grey package
      represent those I directly implemented, the outside ones are the used
      libraries and third party modules, however necessary to run the
      application.</para>

      <figure id="fig-talker-modules">
        <title>Application modules structure</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="vp/components-talker.pdf" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The main application logic is placed inside
      <computeroutput>App</computeroutput> module. It is implemented as
      <computeroutput>Ember.Application</computeroutput> object and it serves
      as namespace for the rest of the application. Using namespace to wrap
      the whole application is good practice so the global namespace (i.e.
      window object) is not polluted. Within the namespace, other Ember-based
      classes are separated into four parts according to the MVC structure,
      i.e. models, views and controllers. The last part is router, responsible
      for handling the application state.</para>

      <sect2>
        <title>Models</title>

        <para>Talker is supposed to handle data: keep the information about
        the contact list, update it as the contacts sign in and out, keep
        track of the message lists corresponding to individual contacts. All
        mentioned data manipulation is achieved with models. Model hierarchy
        is displayed at <xref linkend="fig-models" />. The main two entities,
        <computeroutput>Contact</computeroutput> and
        <computeroutput>Message</computeroutput>, are quite self-explaining.
        It should be mentioned that messages are stored directly as a property
        list of each contact. Potential contact removal would erase its
        messages as well. Class<footnote>
            <para>When speaking about classes and displaying them at the class
            diagrams, one should be aware of the fact there are no real
            language-based classes in JavaScript. However, Ember provides a
            convenient way to imitate the class behaviour with
            <computeroutput>Ember.Object.extend</computeroutput> method,
            further described in the next section.</para>
          </footnote> <computeroutput>Person</computeroutput> encapsulates the
        properties common for the contacts and the user operating the
        application. In other words, information about the current user,
        logged in to the application, is stored in an instance of that
        class.</para>

        <figure id="fig-models">
          <title>Structure of application models</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/cd-app-models.pdf" />
            </imageobject>
          </mediaobject>
        </figure>
      </sect2>

      <sect2>
        <title>Views and controllers</title>

        <para>All Ember-related problematics is described in section <xref
        linkend="chap-ember" />, only the structure is mentioned here. As the
        user traverses the application, various controllers manage the states.
        The structure of controllers bijectively corresponds to the views
        hierarchy (i.e. almost every view has its respective controller and
        vice versa). Only the former is displayed, see <xref
        linkend="fig-controllers" />. The main view, contact list, is handled
        by <computeroutput>ContactsController</computeroutput> instance. When
        the user enters the conversation, ConversationController takes over
        the command. TextController and VideoController (with their respective
        views) are present within the conversation. Calling one or another
        depends on whether the user interacts with the text part (chat) or the
        video call.</para>

        <figure id="fig-controllers">
          <title>Application views/controllers structure</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/cd-app-controllers.pdf" />
            </imageobject>
          </mediaobject>
        </figure>
      </sect2>

      <sect2>
        <title>Adapters</title>

        <para>There is a lot of application logic not related to the data
        itself, but comprising connection establishing, managing and
        triggering correct handlers when any new data comes from the server.
        As Jon Cairns fittingly notes, models should not contain the
        unnecessary application logic not directly related to them.
        <citation>fat-model-skinny-controller</citation> This pieces of code
        are divided into two <quote>adapter</quote> classes.
        <computeroutput>StropheAdapter</computeroutput> is responsible for
        creating, keeping up and reacting to the XMPP connection with BOSH
        server. In other words, it mostly handles the text messages.
        <computeroutput>OpenTokAdapter</computeroutput> uses OpenTok library
        to keep track of the video calls. Video adapter object is assigned to
        every contact because it keeps the state information (session) which
        is different for each contact. On the other hand, StropheAdapter is
        created and initialized just once for whole application since it does
        not contain any contact-specific data. The class structure is
        displayed at <xref linkend="fig-adapters" />.</para>

        <figure id="fig-adapters">
          <title>Connection of the application and adapters</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/cd-adapters.pdf" />
            </imageobject>
          </mediaobject>
        </figure>
      </sect2>
    </sect1>

    <sect1 id="chap-ember">
      <title>Ember.js - JavaScript MVC framework</title>

      <para>Talker is purely client-side-based application, implemented in
      JavaScript and running in web browser. As it is mentioned in the
      technology overview in <xref linkend="sect-choosing-tech" />, Talker
      implements MVC structure on the client side, in the form of Ember MVC
      objects. In this section, JavaScript MVC is analysed overally at first,
      then some features specific to Ember which were used in the
      implementation are described.</para>

      <sect2>
        <title>Client-side MVC</title>

        <para>First of all, it should be clarified why it is necessary to do
        MVC in JavaScript. Most of the web technologies running on the server
        and powering web applications use some kind of MVC<indexterm>
            <primary>MVC</primary>
          </indexterm>, accross all programming languages. It is Rails for
        Ruby; Zend, Nette or Symphony for PHP; Django for Python; Spring MVC
        or simple servlets with JSPs in Java; ASP.NET MVC for C#/.NET, etc. It
        appears that three-tier architecture helps the developers to organize
        the code and the frameworks can do a lot of job automatically.</para>

        <para>In the years, the approach to web application development
        changes a bit. As the clients performance increases, interactivity and
        quick response becomes the most desired benchmark. And here comes
        JavaScript, which can manage whole application at the client side,
        only synchronizing data with a server using AJAX requests. It seems
        this trend of <emphasis>thick client</emphasis> will be stronger and
        stronger in the next years and the server is going to be transformed
        only to the proxy in front of database system.
        <citation>yehuda-talk</citation><citation>new-dev-era</citation></para>

        <para>It is obvious that many tasks previously a server was
        responsible for are moved to the client, to JavaScript. Above all,
        JavaScript application handles user actions (such as clicking a button
        or even typing to an input), rendering HTML snippets (templates) and
        storing the <quote>temporary</quote> data. Storing the data has become
        more tricky, because the JavaScript application works as a first level
        cache which processes all changes but synchronizes with the server
        only occasionally. Simple example: let there be an input for the user
        name, bound to the JavaScript model object representing a user.
        Whenever a new letter appears in the input, JavaScript updates its
        model object (still on the client side). No sooner has whole username
        been entered (either submitted or after a delay) when JavaScript
        synchronizes it with the server. Whole process schema is displayed at
        <xref linkend="fig-js-mvc-input" />.</para>

        <figure id="fig-js-mvc-input">
          <title>Example client-handled input, bound to JavaScript
          model</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/js-mvc-input.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The main advantage of such approach is definitely the swiftness.
        Input changes numbered 1, 2 and 3 are processed immediately at the
        client. If the browser ran in the offline mode, submitting would store
        the data to the local storage eventually. Other very important
        benefit, especially for the application developer, is separation of
        concerns between individual tiers. The result is much better organized
        and thus better maintainable than monolithic blend of code containing
        all aspects of an application at one place.</para>

        <para>In modern client-side JavaScript MVC frameworks, JavaScript is
        also responsible for rendering HTML. This topic is set aside to
        separate section in <xref linkend="sect-html-rendering" />.</para>
      </sect2>

      <sect2>
        <title>Comparsion to other frameworks</title>

        <para>Ember.js is not the only available JavaScript MVC framework. In
        fact, there are plenty of similar frameworks, each of them providing
        slightly different set of tools and asserting slightly different
        philosophy. I have chosen Ember for Talker for several reasons. The
        facts in this section may be a little subjective as they are mostly
        just opinions of mine, as author of this thesis and Talker
        application. There is actually not much comparison but more the
        features specific for Ember are described and explained.</para>

        <para>First of all, Ember provides automatic bindings. There are
        automatic bindings between object properties, so that all computed
        properties are automatically updated when the <quote>raw</quote>
        properties, which they are based on, change their values.
        <citation>ember-in-action</citation> The following snippet of code
        from Talker <computeroutput>Message</computeroutput> object represents
        such situation: <computeroutput>fromName</computeroutput> attribute
        represents the contact name and it is based on the contact JID, stored
        in <computeroutput>from</computeroutput> attribute:</para>

        <programlisting>App.Message = Ember.Object.extend({
    from : null,
    fromName : function() {
        /* implementation */
    }.property('from')
});</programlisting>

        <para>Bindings are really valuable when
        <computeroutput>fromName</computeroutput> property value has already
        been rendered in the template. There is no
        <computeroutput>render()</computeroutput> function (as it is in
        Backbone, for instance) to render the template; templates are rendered
        automatically and updated automatically as well, as the underlying
        data changes.</para>

        <para>There is a lot of additional work Ember does. It follows the
        <quote>convention over configuration</quote> rule to the maximum
        extent, above all other MVC frameworks. For example, when one keeps to
        the official naming conventions, the framework creates the objects
        which are necessary and has not been defined, such as missing
        controller.</para>

        <para>Ember.js uses templating engine Handlebars, which provides very
        clean and convenient way to create presentation layer of the
        application. In my opinion, using dedicated templating engine makes
        the code much more cleaner than using HTML attributes, as for example
        Knockout.js does. Templating is described in detail in <xref
        linkend="sect-html-rendering" />.</para>

        <para>To sum it up, Ember.js is modern and powerful tool doing a lot
        of job that programmer does not have to take care about. On the other
        hand, the learning curve of Ember is told to be one of the steepest
        and it is quite difficult to make the <emphasis>second</emphasis>
        step, after reading the basic tutorials and examples. Fortunatelly,
        there is quite active community working on screencasts<footnote>
            <para><ulink
            url="http://emberwatch.com/">http://emberwatch.com/</ulink></para>
          </footnote>, documentation and actively answering question on
        Twitter and Stackoverflow.</para>
      </sect2>

      <sect2 id="sect-ember-controllers">
        <title>Controllers</title>

        <para>Application controllers are responsible for storing the current
        state and mediating the communication between the views and models.
        <citation>ember-howto</citation> In Ember (and thus in Talker as well)
        controllers also represent collections of model objects.</para>

        <para>The first function, processing the user actions from the view,
        is represented by <computeroutput>processMessage</computeroutput>
        method in <computeroutput>TextController</computeroutput>. The
        following snippet is shortened part from Talker source code:</para>

        <programlisting>App.TextController = Ember.ObjectController.extend({

    processMessage : function(messageText) {

        var message = App.Message.create({ ... });

        message.send();
        this.get('content.messages').pushObject(message);
    }

});</programlisting>

        <para>The method <computeroutput>processMessage</computeroutput> is
        called from the view object when the message input is submitted. The
        view just grabs the data from input and sends it to the controller,
        which creates new <computeroutput>Message</computeroutput> object,
        sends the message and finally updates the list of messages for the
        current contact, accessible via
        <computeroutput>this.get('content')</computeroutput>. Adding
        <computeroutput>.messages</computeroutput> to the
        <quote>selector</quote> points the getter directly to the array of
        messages.<footnote>
            <para>Acutally, the method contains a lot more code such as
            argument check and return values. They have been omitted in this
            example for clarity and shortness.</para>
          </footnote></para>

        <para>Another example of controller from Talker is not
        <computeroutput>ObjectController</computeroutput> as in previous
        example, but <computeroutput>ArrayController</computeroutput>. It
        represents the collection of contacts, displayed in the main
        application view:</para>

        <programlisting>App.contactsController = Ember.ArrayController.create({

    content:[],

    pair : function () {
        var content = this.get('content');
        var result = [];
        for (ii = 0; ii &lt; content.length; ii += 2) {
            result.pushObject({
                "first" : content[ii],
                "second" : content[ii + 1] ? content[ii + 1] : null
            });
        }
        return result;
    }.property('content.@each')
});</programlisting>

        <para>The contacts are stored in the
        <computeroutput>content</computeroutput> attribute, which is Ember
        convention for naming the actual data set within the
        <computeroutput>ArrayController</computeroutput>. As it is necessary
        to render the contacts as pairs in the two-row-view, there is
        <computeroutput>pair</computeroutput> method returning the content
        reformated as the array of pairs. Notice that the function is property
        of <computeroutput>content.@each</computeroutput>, which means that
        any update, insert or delete of the content array forces to
        recalculate pairs as well.</para>
      </sect2>

      <sect2 id="sect-html-rendering">
        <title>Rendering HTML</title>

        <para>Thick JavaScript client is responsible not only for manipulating
        the data but also for rendering it to the HTML page. Ember is shipped
        with Handlebars<indexterm>
            <primary>Handlebars</primary>
          </indexterm> - a lightweight templating engine. The application is
        decomposed to the separate views; in case of Talker it is a contact
        list, the conversation, which consists of another two parts - text
        chat and video. The structure basically corresponds with the
        controller tree at <xref linkend="fig-controllers" />. Additionally,
        text chat contains theoretically unlimited number of view, each of
        them for a single message, either sent or received.</para>

        <para>There are two important parts of the view: the view object
        itself and its template. To describe the philosophy of presentation
        layer, <computeroutput>VideoView</computeroutput> is further examined
        here, as an example:</para>

        <programlisting>App.VideoView = Ember.View.extend({
    templateName: 'video',

    buttonLabel : function() {
        return this.get('controller.content.isActive') ? m.stop : m.start;
    }.property("controller.content.isActive")
});</programlisting>

        <para>There are two properties in the view object,
        <computeroutput>templateName</computeroutput> and
        <computeroutput>buttonLabel</computeroutput>. The former just
        determines the name of template connected to this view. The latter is
        common method returning one of <computeroutput>stop</computeroutput>
        or <computeroutput>start</computeroutput> messages, according to the
        value of property <computeroutput>isActive</computeroutput>, located
        in the <computeroutput>controller.content</computeroutput> object,
        pointing to the contact the user is currently talking to. The other
        important part is the template itself, inserted directly in HTML
        page:<footnote>
            <para>Handlebars templates must be compiled by Ember to JavaScript
            code to be ready to be used. It is possible to let Ember compile
            the templates in the browser or precompile the templates on the
            server. However, there is very poor support for doing so in PHP.
            Therefore, templates are rendered in HTML page and compiled in the
            browser while developing the application. For production, it is
            recommended to precompile them using dedicated Node.js module:
            <ulink
            url="http://handlebarsjs.com/precompilation.html">http://handlebarsjs.com/precompilation.html</ulink>.</para>
          </footnote></para>

        <programlisting>&lt;script type="text/x-handlebars" data-template-name="video"&gt;

    &lt;div class="content_margin" &gt;
        &lt;div id="video"&gt;&lt;!-- video of me comes here --&gt;&lt;/div&gt;
        &lt;div id="stream"&gt;&lt;!-- video of the contact comes here --&gt;&lt;/div&gt;
        &lt;div id="message"&gt;{{stateMessage}}&lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="button_wrapper_video"&gt;
        &lt;button {{action toggleCall target="controller"}} type="submit"&gt;
            {{view.buttonLabel}}
        &lt;/button&gt;
    &lt;/div&gt;

&lt;/script&gt;</programlisting>

        <para>The template is inserted in script element, declaring itself as
        a handlebars template. The only attribute
        <computeroutput>data-template-name</computeroutput> identifies the
        snippet and connects it to the view object, which specified the same
        value in the <computeroutput>templateName</computeroutput> attribute,
        as shown above. The template can contain any HTML, along with the
        variables and expressions, both enclosed with the double braces,
        sometimes called moustaches. In the example of video template, there
        is <computeroutput>stateMessage</computeroutput> variable queried,
        which is looked up in the object bound to the template. The object is
        provided by router (described in <xref linkend="sect-routing" />). In
        this case, it would be the current contact the user is talking
        to.</para>

        <para>The second handlebars expression in the template is action.
        Actions are usually bound to the active elements, such as buttons.
        When the button is clicked, the action is triggered. Ember finds the
        controller responsible for the current state, which would be an
        instance of <computeroutput>VideoController</computeroutput> in this
        case, and calls the method
        <computeroutput>toggleCall</computeroutput>, specified in the template
        expression. Actions can be placed both in the controllers the views,
        according to the each of whose nature.</para>

        <para>Handlebars templates can transform almost any data stored in
        JavaScript to HTML code so the rendered template corresponds exactly
        to the application state. It is possible to add classes according to
        the values of the object properties. In the following snippet, there
        is message template, rendered individually for each message in the
        conversation. The class is assigned to the wrapping div element
        according to <computeroutput>isFromMe</computeroutput> property. If it
        is true, <computeroutput>from_me</computeroutput> class attribute is
        added, <computeroutput>to_me</computeroutput> otherwise. Class
        <computeroutput>message</computeroutput> is added independently of the
        properties and it is always present so the block can be styled as
        message with custom CSS.</para>

        <programlisting>&lt;script type="text/x-handlebars" data-template-name="message"&gt;
    &lt;div {{bindAttr class="isFromMe:from_me:to_me :message"}}&gt;
        &lt;span class="from"&gt;{{fromName}}:&lt;/span&gt;
        &lt;span class="text"&gt;{{text}}&lt;/span&gt;
    &lt;/div&gt;
&lt;/script&gt;</programlisting>

        <para>The last two things to be mentioned about templates are
        iterating and nesting. Have a look at the following example from the
        main contact list view (altered a bit):</para>

        <programlisting>&lt;script type="text/x-handlebars" data-template-name="contact-list"&gt;
    {{#each App.contactsController.pair}}
        &lt;div class="pair_wrapper"&gt;
            {{view App.ContactView contentBinding="first"}}
            {{view App.ContactView contentBinding="second" }}
        &lt;/div&gt;
    {{/each}}   
&lt;/script&gt;</programlisting>

        <para>When the template is rendered, Ember iterates over the
        collection of contacts, accessed with
        <computeroutput>pair</computeroutput> method (it was mentioned in
        <xref linkend="sect-ember-controllers" />). Then, framework takes each
        contact from the pair and instantiates
        <computeroutput>ContactView</computeroutput> for it, passing it as a
        current object for the view and rendering the template exactly in the
        place the view expression is stated. Therefore, the list of contacts
        is rendered, grouped by two inside
        <computeroutput>pair_wrapper</computeroutput> blocks.</para>
      </sect2>

      <sect2 id="sect-routing">
        <title>Routing</title>

        <para>Despite HTTP is stateless protocol, it is common habit to build
        stateful web applications. The states are simulated by various web
        pages and the transitions are carried out clicking on the links. All
        changes are simultaneously displayed in URL bar.</para>

        <para>The problem is that JavaScript application cannot change the web
        page, leave one and continue at other. JavaScript would lost its
        context and whole MVC structure would serve to no purpose. Therefore,
        most of the JavaScript applications using MVC frameworks run at single
        web page, no matter how many states they contain. In Ember.js, there
        is special object called <emphasis>Router</emphasis><indexterm>
            <primary>router</primary>
          </indexterm>, responsible for transitions between states,
        dispatching of events and rendering correct templates.<footnote>
            <para>Ember router API changed a lot since the application was
            implemented (it is less than a year, but still). Further in this
            section, the old version of API is described since it is the
            version used in Talker application. Updating Talker to the newest
            Ember.js version with new router is one of the possible future
            tasks.</para>
          </footnote></para>

        <para>Router contains several states, ordered in a tree structure,
        according to the flow of possible user actions. The routes can be
        nested. The first aspect of router is mapping the states to URLs.
        Every time the transition takes place, router changes the context
        (basically renders different template) and it changes URL as well.
        Since JavaScript can change only URL fragment router does exactly so.
        And vice versa, when the user types specific URL in the URL bar, the
        application lets the router to choose the matching state and set the
        context in a similar way.</para>

        <programlisting>App.Router = Ember.Router.extend({

    root: Ember.Route.extend({

        goToContactList : Ember.State.transitionTo('contacts'),
        goToConversation : Ember.State.transitionTo('conversation.index'),

        index : Ember.Route.extend({
            route:'/',
            redirectsTo:"contacts"
        }),

        contacts : Ember.Route.extend({
            route:'/contacts'
        }),

        conversation : Ember.Route.extend({
            route:'/conversation/:contact_id'
            index : Ember.Route.extend({
                route:'/'
            })
        })
    })
});</programlisting>

        <para>Handling the application links is the second responsibility of
        router. In the example above, there are two link destinations, named
        by <computeroutput>goTo*</computeroutput> labels. When any element is
        marked with Handlebars <computeroutput>{{action
        goTo*}}</computeroutput>, it is transformed into a link leading to the
        corresponding router state. And the router handles the event by simple
        transitioning to one of existing states.</para>

        <para>Let's have a look at one of the routes in more detail. As
        mentioned before, router is responsible for creating unique URL for
        every application state. That usually means serializing the
        application state to URL when the transition is carried out via link.
        In the other case, when the URL is typed into URL bar directly, it has
        to deserialize it and establish correct application state.</para>

        <programlisting>conversation : Ember.Route.extend({

    route : '/conversation/:contact_id',

    connectOutlets : function (router, contact) {
        // binds current contact to the conversationController 
        // so the text/video view can access it
        router.get('applicationController')
              .connectOutlet('conversation', contact);
    },
    deserialize : function (router, params) {
        return App.contactsController.find(function(item) {
            return item.id == params.contact_id;
        });
    },
    serialize : function (router, context) {
        return context ? { contact_id : context.get('id') } : {};
    }
})</programlisting>

        <para>There are two methods providing such functionality,
        <computeroutput>serialize</computeroutput> and
        <computeroutput>deserialize</computeroutput>. The former picks the
        unique identifier for current context (contact object) and returns it
        as <computeroutput>contact_id</computeroutput>. This parameter is used
        in the route
        <computeroutput>'/conversation/:contact_id'</computeroutput> as a
        dynamic segment, so that actual route would be
        <computeroutput>'/conversation/42'</computeroutput> for example.
        Deserializing works in exactly opposite way. Ember prepares the URL
        segment for the router so it is passed as object containing the map of
        dynamic segments, which would be <computeroutput>{ contact_id : '42'
        }</computeroutput> in our (example) case. The only job
        <computeroutput>deserialize</computeroutput> must do is to find the
        appropriate object (contact with ID 42) and return it as the current
        context object.</para>

        <para>The last remarkable aspect of router is choosing the appropriate
        templates and connecting them together. Basically,
        <computeroutput>connectOutlets</computeroutput> method tells main
        application controller to <quote>include</quote> the controller
        responsible for current state, which would be
        <computeroutput>ConversationController</computeroutput> instance in
        the example above. This is importand when rendering the templates.
        First, main application template is rendered. Then, Ember looks into
        the template for <computeroutput>{{outlet}}</computeroutput> tag and
        inserts the conversation template exactly to the place it is found.
        The last thing, appropriate contact object is passed as the context
        for the conversation controller (and thus the template as well).
        Everything described in this paragraph is deduced from one line
        implementation of <computeroutput>connectOutlets</computeroutput>
        method in the example above.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Initializing the connection</title>

      <para>When the user clicks at Talker icon in the Celebrio main menu, a
      request is sent to the server which renders HTML page and sends it along
      with all necessary assets, such as JavaScript files and style sheets.
      When the page is loaded, Talker starts running. First of all, the
      connection to remote BOSH server must be established so that the
      application can communicate with the rest of the world. There are two
      options to do it: creating a brand new connection or using the existing
      one, i.e. attaching to the connection as it is described in <xref
      linkend="strophe-attach" />.</para>

      <para>As JavaScript files are loaded,
      <computeroutput>App</computeroutput> object is defined by Ember firstly
      - whole MVC structure described in <xref linkend="chap-ember" />. Then,
      new <computeroutput>StropheAdapter</computeroutput> object is created
      and it attempts to establish the connection with BOSH server
      immediately. Strophe adapter supports both creating a new connection and
      letting server to create one. The initialization code basically checks
      whether the password has been provided to the client code. If yes, BOSH
      authentication takes place, as displayed at <xref
      linkend="fig-conn-establish" />. When the password is not provided,
      JavaScript client sends an authentication request to the server, which
      should establish the connection and return JID, SID and RID so the
      client can attach to the connection and use it for further
      communication. The workflow is depicted at <xref
      linkend="fig-conn-attach" />. In both cases, the authentication
      handshake follows the SASL authentication protocol defined by XEP-0206.
      <citation>xep-0206</citation></para>

      <figure id="fig-conn-establish">
        <title>Establishing a new BOSH connection from JavaScript</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="vp/conn-establish.pdf" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure id="fig-conn-attach">
        <title>Establishing a new BOSH connection using server side XMPP
        client</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="vp/conn-attach.pdf" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>It is recommended not to send a password to the client, for
      obvious security reasons. Therefore, Talker is set to use server-side
      connection establishment by default. On the other hand, PHP
      implementations of XMPP clients are not that matured and certain
      problems appeared, as mentioned in <xref
      linkend="chap-server-side-xmpp-client" />.</para>
    </sect1>

    <sect1>
      <title>Processing events</title>

      <para>Talker works as a typical asynchronous application. The
      application mostly consists of many callbacks (event listeners) attached
      to different events and awaiting to be triggered within the event loop.
      <citation>async-javascript</citation> It is common pattern in JavaScript
      applications nowadays. <citation>js-definitive-guide</citation> Talker
      does expect the events to come either from the user (traversing the
      application, sending a message, ...) or from the network (response from
      BOSH server, incoming message, ...). Basically, almost everything in
      Talker is intended to be either declarative (Ember object patterns) or
      event-based (Strophe events).</para>

      <para>The first kind of events are those incoming from the network. As
      it was mentioned in <xref linkend="chap-strophe-events" />, Strophe is
      set up with the event handlers attached to various event types. There is
      not even one synchronous call between the application and the server so
      that every response is handled with custom callback asynchronously. All
      callbacks are defined as methods of
      <computeroutput>StropheAdapter.prototype</computeroutput> object so that
      they are shared by all <computeroutput>StropheAdapter</computeroutput>
      instances. <citation>js-enlightnment</citation></para>

      <para>Incoming chat messages are handled by
      <computeroutput>chatMessage</computeroutput> method. The message is
      passed to the method from Strophe library in form of
      <computeroutput>Element</computeroutput> object. The method parses the
      message, constructs the Ember model
      <computeroutput>Message</computeroutput> object and tries to assign the
      message to a contact (the recipient). When the recipient is know (so she
      is present in the the user contact list), new message is appended to the
      list of messages. Ember automatically updates the view so the message
      appears in the list immediately.</para>

      <programlisting>var message = App.Message.create({
    to : msg.getAttribute('to'),
    from : Strophe.getBareJidFromJid(msg.getAttribute('from')),
    type : msg.getAttribute('type')
});

var contact = App.contactsController.find(function(item) {
    return item.jid == message.from;
});

contact.get('messages').pushObject(message);</programlisting>

      <para>The user actions are handled mostly by Ember itself. For example
      sending a new message is managed by the controller (described in <xref
      linkend="sect-ember-controllers" />), which just calls adapter function
      which actually sends the prepared message object. It is one of the
      design drawbacks of the application, that the there is two-way awareness
      between the adapter and controllers (somethimes controller calls
      adapter, sometimes the adapter actively calls controller). This design
      was chosen for its simplicity and it appeared to be sufficient for the
      application of Talker's size.</para>

      <sect2>
        <title>Notifications<indexterm>
            <primary>notifications</primary>
          </indexterm></title>

        <para>Talker is only a part of bigger system - Celebrio. The user has
        to find out when a new message arrives. Therefore, simple mechanism of
        notifications has been developed and used accross the system, not only
        in Talker. When a new chat message arrives, the application triggers
        the built-in mechanism and the notification is propagated to the main
        Celebrio frame using <computeroutput>postMessage</computeroutput>
        API.<footnote>
            <para><ulink
            url="https://developer.mozilla.org/en-US/docs/DOM/window.postMessage">https://developer.mozilla.org/en-US/docs/DOM/window.postMessage</ulink></para>
          </footnote> Since notifications are not specific only to Talker and
        they were not developed as a part of the application, they are not
        described further here.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Logger</title>

      <para>Although JavaScript is very popular language, at least in web
      applications, there is not common way to log messages. There are two
      possible reasons. Firstly, JavaScript runs in the web browser and
      frequent AJAX requests would be necessary to log everything what
      happens. Secondly, web browser is kind of <quote>hostile</quote>
      environment, so the system developer cannot rely on the message
      truthfulness at all. Anyway, it is useful to have some information
      logged, at least in the development mode, locally to the browser
      console.<footnote>
          <para>All current browsers have console.log method implemented,
          which outputs any message from JavaScript code to the browser
          console, accessible to anyone using the browser. The main advantage
          is the fact that console is hidden from the ordinary users, yet it
          can easily be accessed by anyone debugging the application or
          reporting a bug. See API for details: <ulink
          url="https://developer.mozilla.org/en/docs/DOM/console.log">https://developer.mozilla.org/en/docs/DOM/console.log</ulink>.</para>
        </footnote></para>

      <para>The main problem with common frequently used
      <computeroutput>console.log</computeroutput> method is the impossibility
      of hiding certain kind of messages. In Talker, there are seven different
      kinds of logs: those related to messages, video, subscriptions,
      notifications etc. It is impossible to have the output uncluttered
      without constant commenting and uncommenting
      <computeroutput>console.log()</computeroutput> calls.</para>

      <para>In order to solve this trouble, logging library Log4js<indexterm>
          <primary>Log4js</primary>
        </indexterm> has been used in the application. It allows to create
      various loggers (with various appenders). Each logger has its own log
      level set so it outputs only the messages tagged by that level, or
      higher. Actually, the logger usage is very similar to well known log4j,
      including formating layouts. There is AJAX appender available in the
      library so it is possible to send the messages to the server to be
      stored. This might be useful to log error messages not reproducible in
      the development environment.</para>

      <sect2>
        <title>Setup</title>

        <para>The logger (with console appender) is set up as follows:</para>

        <programlisting>Log4js.getLogger("message")
      .setLevel(Log4js.Level.INFO)
      .setAppenders([new Log4js.BrowserConsoleAppender()]);</programlisting>

        <para>Originally, the library does not allow chaining the methods so a
        local variable must be created to set up the logger (or getLogger
        method must be called multiple times). I believe method chaining is
        sensible pattern so I reimplemented several methods in the library to
        support it. Unfortunatelly, the project is not hosted on GitHub so it
        is quite difficult to offer the changes back to the community.</para>
      </sect2>

      <sect2>
        <title>Logging</title>

        <para>Logging a message is also quite easy, it might look as the
        following example (cut out of
        <computeroutput>onConnect</computeroutput> method):</para>

        <programlisting>App.log.logger.info('Strophe is connected as ' + App.me.jid);
App.log.logger.debug(this);</programlisting>

        <para>Two notes should be mentioned about the code. Firstly, all
        logger which have been set up are accessible via
        <computeroutput>App.log</computeroutput> object. It is a wrapper so
        the used logging library can be changed (and it was changed several
        times during the development). As long as the logger objects implement
        common logging methods (such as <computeroutput>info</computeroutput>
        and <computeroutput>debug</computeroutput>), the application will
        work.</para>

        <para>The second thing is logging complex objects such as
        <computeroutput>this</computeroutput>, pointing to the
        <computeroutput>Strophe.connection</computeroutput> in the example
        call. Log4js does not provide any layout which would not transform the
        value to string - [object Object] in our case. This is not very useful
        - the developer usually knows there is a object and he just wants the
        possibility to inspect it. Therefore, I enhanced the library again in
        order to log complex objects. First of all, the logger outputs a text
        message saying complex value is about to be logged. Then, the complex
        value is logged individually without being cast to string. Therefore,
        it is possible to access it interactively in the console, fold and
        unfold the nested properties and carry out other inspections. Logging
        object from the example above thus looks as follows (arrows within the
        object symbolize the property can be inspected):</para>

        <programlisting>INFO - Strophe is connected as pavel.smolka@jappix.com
DEBUG - [object Object]
Strophe.Connection {
 &gt; adapter: StropheAdapter
 &gt; addHandlers: Array[0]
 ...
}</programlisting>
      </sect2>
    </sect1>

    <sect1 id="chap-contact-list">
      <title>Contact list</title>

      <para>The list of contacts is essential part of every instant messaging
      application. The same applies to Talker, with little modification
      compared to classical IM clients. Talker has been designed and
      implemented as the part of Celebrio - comprehensive <quote>operating
      system</quote>. The contact list is not managed by Talker itself, it
      servers to other applications as well. On the other hand, the user can
      connect existing third party XMPP account to Celebrio, with its own
      contact list (roster). It is crucial to deal with the contacts
      duplication and appropriate matching one to another.</para>

      <sect2>
        <title>Fetching Celebrio contact list</title>

        <para>As mentioned in the previous paragraph, the contact list base
        comes from the server-side database. Celebrio asks the user for adding
        her contacts in People application, another part of the system. All
        contacts are stored in a relational database and available through the
        system, in all applications. One of the properties of the contact
        entity is JID. For the needs of Talker, the contacts are filtered on
        the server so that only those which have JID filled are returned as
        the user contact list.</para>

        <para>Since Talker is JavaScript application, the contacts are passed
        to JavaScript in JSON format. To avoid an extra request (and thus a
        delay), contact list is rendered by PHP to the
        <computeroutput>&lt;script/&gt;</computeroutput> element in the
        server-side processed template. Then, when the Ember application is
        initialized, the array of plain JavaScript objects is transformed to
        the content of <computeroutput>ArrayController</computeroutput>,
        specifically <computeroutput>App.contactsController</computeroutput>.
        After that, the application can easily manage rendering the contact
        list within Handlebars template and keeping it up-to-date.</para>

        <para>Ember class <computeroutput>Contact</computeroutput> is one of
        the most voluminous objects in the application. Every
        <computeroutput>Contact</computeroutput> object contains both the
        <quote>static</quote> properties from the server (such as contact name
        or avatar picture) and the dynamic information about current state in
        the application. The latter category includes the information whether
        the contact is online or not, its presence status (DND, Away, ...) and
        also all the messages related to the contact.</para>

        <para>Within whole Celebrio system, there is a rule that the contacts
        the user has not added to her contact list (in the People application)
        does not affect the user in any way. In fact, all messages, updates or
        invites from unknown contacts are processed by the application, but
        they are thrown away and not displayed to the user. There is an easy
        possibility to extend the application to be able to communicate with
        the contacts that have not been added yet. However, it would break the
        system philosophy and making such decision is not up to the thesis
        author.</para>
      </sect2>

      <sect2>
        <title>Matching the entries from XMPP roster</title>

        <para>The contact list retrieved from Celebrio backend, as it was
        described in the previous section, is only underlying material for
        building the contact list. The other part is XMPP roster<indexterm>
            <primary>XMPP</primary>

            <secondary>roster</secondary>
          </indexterm> (contact list), stored at the XMPP server. The roster
        can possibly contain different contacts from internal Celebrio contact
        list, because it can be accessed from other XMPP clients as
        well.</para>

        <para>When the application is connected, fetching a roster from XMPP
        server is one of the first steps. One of Strophe.js plugins (plugins
        were generally described in <xref linkend="chap-strophe-plugins" />),
        called characteristically Roster, provides convenient API for this - a
        callback function is passed to
        <computeroutput>roster.get</computeroutput> method and executed when
        the roster is fetched.</para>

        <para>The callback does basically two things, as displayed at <xref
        linkend="fig-roster-fetch" />. The retrieved contacts (those from XMPP
        roster) are matched to existing contacts retrieved from Celebrio
        server. Contacts present only in the roster are just logged, the
        application does not work with them. In other words, the appropriate
        record in <computeroutput>contactsController</computeroutput> array is
        found and match to every XMPP contact retrieved in the roster.</para>

        <figure id="fig-roster-fetch">
          <title>Matching XMPP roster and Celebrio contact list</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/roster-fetch.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The second part (left side of the picture) of matching contacts
        works from the opposite direction. Application processes all contacts
        that has been retrieved from the server and which are not in XMPP
        roster. Then, it sends subscription request, which consists of several
        steps, but it simply means adding the contact to the XMPP
        roster.</para>
      </sect2>

      <sect2>
        <title>Presence and online statuses</title>

        <para>One of the biggest advantages of real-time communication tools
        is the fact that one can see whether his contacts are currently
        available (i.e. online, logged in) or not. In terms of XMPP and
        Talker, we speak about <emphasis>presence</emphasis><indexterm>
            <primary>presence</primary>
          </indexterm>. Strophe does not provide convenient way to work with
        presence but Roster plugin does.<footnote>
            <para>It is the same Roster plugin which handles roster retrieval
            and processing, mentioned in the previous section.</para>
          </footnote></para>

        <para>Presence is processed in way usual to Strophe: the developer
        provide a callback to a certain topic, which is triggered when
        anything related to that topic happens. The process of binding the
        callback is described in <xref linkend="chap-strophe-plugins" />. When
        the callback is bound, Strophe watches over the presence changes sent
        as presence stanzas from server and hands them over to the assigned
        callback - <computeroutput>onPresenceChange</computeroutput> method
        where the presence change is processed.</para>

        <para>The callback function recieves two parameters. The first one
        contains the list of all contacts, the second parameter represents
        just the information about the contact whose presence has changed.
        This is a bit tricky because the callback is triggered even if only
        the presence of the currently logged user changes - in this case the
        second parameter (changed) is undefined.</para>

        <para>The presence is processed in two ways. Firstly, there is basic
        telling online from offline status. The other part is optional online
        status specifying the availability (away, DND, ...), contained in
        <computeroutput>&lt;show&gt;</computeroutput> element of XMPP message.
        <citation>rfc-3921</citation> The online status is processed as well
        and the current value is stored for each contact. Unfortunatelly, the
        graphic design for showing statuses has not been proposed yet so it it
        not displayed within the application, yet ready to be.</para>

        <para>There is one more glitch about online statuses. XMPP makes it
        possible for one to be logged in simultaneously from several devices.
        In such case, each session (called resource in XMPP) should state its
        priority. By changing the priority appropriately, it is possible to
        keep the client running at home and yet receive the messages at work
        by being logged there in with higher priority. In case the contact is
        logged in at several places (i.e. several pieces of presence
        information are fetched from the server), Talker finds the resource
        with highest priority and processes its online status.</para>

        <para>Another possible approach would be sorting the online statuses
        from the most desirable (i.e. online would be the first, then away,
        and so for) and looking for the <quote>best</quote> one, regardless of
        the priority. It could actually more correspond to the real state of
        matters because some clients (such as Google Talk client) set always
        the highest priority. However, I decided to keep the rules XMPP
        protocol sets.</para>
      </sect2>

      <sect2>
        <title>Subscriptions</title>

        <para>Subscribing in XMPP basically addressses adding the contacts to
        the contact list and asking them for the same. Due to the simplicity
        of the application, Talker performs subscriptions automatically. When
        the new contact (i.e. new contact added in Celebrio system) is found,
        the subscription request is sent when Talker starts and loads the
        contact list. In the opposite direction, when the subscription request
        is received, the application tries to find the appropriate contact and
        subscribe too. If no such contact is found, information is logged and
        nothing happens.</para>

        <para>This approach has one big advantage: the user does not have to
        respond to the subscription requests and she does not need to send own
        requests either. Yet, there is also one disadvantage, basically the
        same thing from the opposite point of view. The user cannot fully
        control her contact list - for example refuse subscription request
        from the contact in roster. We decided for this trade off to make the
        application as simple as possible.</para>
      </sect2>
    </sect1>

    <sect1 id="chap-video-calling">
      <title>Video calling</title>

      <para>TODO: Video framework, flash fallback</para>

      <sect2>
        <title>Using OpenTok library</title>

        <para>TODO: OpenTok library, Native implementation in Android</para>

        <para>TODO: WS in OpenTok</para>
      </sect2>

      <sect2>
        <title>Implementation</title>

        <para>TODO</para>

        <figure>
          <title>Video call states</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="vp/video-calls.pdf" />
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Testing</title>

      <para>Every application is tested during the development. Traversing the
      application manually is common way of testing, especially in case of web
      applications. It is definitely the easiest but also not repeatable and
      thus difficult to scale in large projects. Therefore, automatic tests
      are often used. There are three kinds of tests concerning web
      applications. The most widespread kind of tests are unit tests
      concerning the server-side code. Testing server-side code brings the
      benefit of predictable and easily modifiable runtime environment.
      However, Talker is client-side application and therefore server-side
      unit testing is not an option. The other two types of tests, both
      related to Talker, are JavaScript unit tests and Selenium tests, both
      described below.</para>

      <para>JavaScript unit testing<indexterm>
          <primary>unit testing</primary>
        </indexterm> is relatively new technique, definitely younger than
      classic JUnit tests in Java or PHPUnit in PHP. Earlier, the JavaScript
      consisted of several action listeners bound to the HTML elements on web
      page. However, hardly did real application logic move to JavaScript when
      the application code grew bigger. Therefore, it must to be tested
      automatically.</para>

      <para>There are several available solutions for unit testing in
      JavaScript. Some solutions cover whole testing <quote>stack</quote>,
      such as Jasmine or QUnit. On the other hand, there are tools which
      separate the problem of testing (setting up the environment and running
      tests) from assertion, which is responsible for injecting the functions
      which help with checking whether the tested method behaves correctly and
      return correct values. I believe the separation of concerns is good
      pattern overall so I have used the tools from the second group:
      Mocha<indexterm>
          <primary>Mocha</primary>
        </indexterm> and Intern<indexterm>
          <primary>Intern</primary>
        </indexterm> testing frameworks, both using Chai<indexterm>
          <primary>Chai</primary>
        </indexterm> as the assertion library.</para>

      <para>JavaScript is specific by not having strictly defined the runtime
      environment. Usually, client-side JavaScript runs in web browser
      interpreter. However, there are also many tools running with Node.js,
      JavaScript server-side platform and runtime environment. Since Talker is
      web-based application, it is crucial to have it tested in web browser
      environment. All three solutions described below perform the automatic
      tests with web browser environment.</para>

      <sect2>
        <title>Chai assertion library</title>

        <para>Before the unit testing frameworks can be described, another
        part of testing must be mentioned. It is assertion, i.e. checking
        whether the code resulted to the expected values. Both Intern and
        Mocha, testing frameworks described later on, use assertion library
        Chai. It provides convenient and easily readable way to check various
        conditions.</para>

        <para>There are two assertion styles which can be used with Chai:
        behavior-driven development (BDD style) and test-driven (TDD). They
        differ only by syntax, their expression power is equal. TDD style
        looks more similar to JUnit or PHPUnit:
        <citation>chai-tdd</citation></para>

        <programlisting>assert.include([ 1, 2, 3 ], 3, 'array contains value');
assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');</programlisting>

        <para>On the other hand, BDD provides easy-to-read word chaining,
        resulting to a sentence. The following example (BDD) equals the
        previous one (TDD), only the used style differs:
        <citation>chai-bdd</citation></para>

        <programlisting>expect([1,2,3]).to.include(3);
expect({ tea: { green: 'matcha' }})
    .to.have.deep.property('green.tea', 'matcha');</programlisting>
      </sect2>

      <sect2>
        <title>Unit testing with Intern framework</title>

        <para>Intern is a tool for creating, running and managing JavaScript
        unit tests, all with minimal need to set up another third party tools
        and environments. Intern is not yet available as npm<footnote>
            <para>Node.js package</para>
          </footnote> package <citation>intern-blog</citation> so it has to be
        installed manually. After the installation, a configuration file must
        be set up to tell the framework where the tests are and how the
        testing environment should look like.</para>

        <para>Similarly as with Chai, the tests can be implemented in two
        syntax ways: TDD and BDD. The following examples are actual tests
        implemented for Talker application, running with Intern, using BDD
        style. The overall test structure uses Dojo (library Intern depends
        on, providing define method) and it look as follows:</para>

        <programlisting>define([
  /* load dependencies */
], function (bdd, expect) {
  with (bdd) {

    /* test suite */
    describe('StropheAdapter', function () {
  
      /* before each test */
      beforeEach(function() {
        adapter = new StropheAdapter();
        send = adapter.connection.send;
      });

      /* inner test suite = set of tests */
      describe('#constructor', function () {

        /* test itself, with description */
        it('should do something...', function () {
          /* perform test, make assertions */
        });
      });
    });
  }
});</programlisting>

        <para>First, there are dependencies defined so the framework loads
        them before the test is executed. Almost all JS files included in the
        application are defined here to emulate the environment of the
        application as precisely as possible. The next statement tells BDD
        style is going to be used. Later on, actual test suites with tests are
        listed. Each suite can mention
        <computeroutput>before</computeroutput>,
        <computeroutput>beforeEach</computeroutput>,
        <computeroutput>after</computeroutput> and
        <computeroutput>afterEach</computeroutput> functions to be run,
        similarly as other testing frameworks allow. A test itself consists of
        a description label. This label should describe the test aim and hence
        identify it. Inside the test, any code can be executed as well as
        assertions can be carried out.</para>

        <para>JavaScript differs from common programming languages in the way
        the asynchronous code is executed. JavaScript does not provide
        multithreading by default <citation>js-definitive-guide</citation>.
        Hence, the pattern of passing a callback to the asynchronous operation
        is used instead. Unfortunatelly, it is nontrivial task to test
        asynchronous doce in JavaScript. Intern provides convenient way to do
        so using promises pattern. The following example tests that
        <computeroutput>start</computeroutput> method connects the application
        to XMPP server in 10 seconds, using Chai assertion to check it.</para>

        <programlisting>it('should connect and call onConnection callback', function () {
    var dfd = this.async(10000);
    adapter.start(dfd.rejectOnError(function (status) {
        if (!(status === Strophe.Status.ATTACHED 
                || status === Strophe.Status.CONNECTED)) {
            return;
        }

        expect(adapter.connection.connected).to.be.true;
        // explicitly resolve the test since 
        // it was successful to this point
        dfd.resolve();
    }));
});</programlisting>

        <para>The callback is hand over to start method to be triggered every
        time the connection status changes. This means it is also triggered if
        Strophe only performs the authentication or even if the connection
        fails! Therefore, the promise is resolved (so the test succeeds) only
        if the correct status is passed as an argument.</para>

        <para>It has to be admitted that the previous test is not real unit
        test, mocking all surrounding objects the function interacts with.
        Considering that the goal of testing is making sure the implemented
        methods work as expected, being implemented in this way is the easiest
        and most straightforward way to achieve it. Mocking the libraries and
        network requests would require substantial architecture changes in the
        application, leading to inappropriate complexity and problems for
        anyone to work with it <quote>out of the box</quote>.</para>
      </sect2>

      <sect2>
        <title>Mocha unit tests</title>

        <para>Mocha<indexterm>
            <primary>Mocha</primary>
          </indexterm> is another framework for creating unit tests in
        JavaScript. The structure of tests is similar to Intern, Mocha also
        supports BDD style with <computeroutput>describe</computeroutput> and
        <computeroutput>it</computeroutput> keywords. What is different is the
        way Mocha tests are executed and dependencies are loaded. Mocha is
        more lightweight than Intern, it is just Node package, not including
        any configuration files and environment administration.</para>

        <para>The easiest way to run Mocha is from command line:
        <computeroutput>mocha test-file.js</computeroutput>. However, to be
        able to use Chai to do assertions, each test file must declare it with
        Node <computeroutput>require</computeroutput> function. The unit test
        implemented with mocha then looks as the following example - similar
        to Intern test:</para>

        <programlisting>var expect = require('chai').expect;

describe('StropheAdapter', function(){
    describe('#constructor', function(){
        it('should do something...', function () {
          /* perform test, make assertions */
        });
    })
});</programlisting>
      </sect2>

      <sect2>
        <title>JsTestDriver<indexterm>
            <primary>JsTestDriver</primary>
          </indexterm> framework</title>

        <para>Running Mocha tests in console with Node brings one huge
        disadvantage. There is no easy option to load custom JavaScript files
        which are necessary to perform the test, unless they are packed as npm
        packages. Therefore, I used another tool called JS Test Driver to wrap
        Mocha tests, load dependencies before executing them and also run them
        in the browser environment.</para>

        <para>JS Test Driver (JSTD) is a Java library allowing the developers
        to run the tests in certain environment, according to the specified
        configuration file. Although it has not originally been intended to be
        used with Mocha, there is an adapter aviailable which bridges this
        imperfection. Furthermore, JSTD can be easily run from PHPStorm or
        WebStorm IDEs (there is a plugin in the IDE especially for
        JSTD).</para>

        <para>There is a configuration file for JSTD test suite, specifying
        the scrpits to be loaded and test files to be executed, similarly as
        Intern does. The structure is self-explaining:</para>

        <programlisting>load:
  - "lib/mocha.js"
  - "lib/chai.js"
  - ".../strophe_adapter.js"
test:
  - "test-file.js"</programlisting>

        <para>Mocha and Chai have to be loaded explicitly. Moreover, Mocha and
        Chai must be set up manually in each test file:</para>

        <programlisting>mocha.setup('bdd');
expect = chai.expect;</programlisting>

        <para>Although JSTD looks like worthwhile tool, I had serious problems
        with keeping it running. Nondeterministic behavior, when the same test
        (simple test without side effects, network dependencies and so on)
        sometimes passes and sometimes results in infinite loop never ending
        the process, makes JSTD almost impossible to be used.</para>
      </sect2>

      <sect2>
        <title>Selenium tests<indexterm>
            <primary>Selenium</primary>
          </indexterm></title>

        <para></para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title>Conclusion</title>

    <para>TODO: conclusion</para>
  </chapter>

  <bibliography>
    <biblioentry>
      <abbrev>xmpp-the-definitive-guide</abbrev>

      <authorgroup>
        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Kevin</firstname>

          <surname>Smith</surname>
        </author>

        <author>
          <firstname>Remko</firstname>

          <surname>Tronçon</surname>
        </author>
      </authorgroup>

      <title>XMPP: The Definitive Guide</title>

      <subtitle>Building Real-Time Applications with Jabber
      Technologies</subtitle>

      <publisher>
        <publishername>Sebastopol: O'Reilly</publishername>
      </publisher>

      <pubdate>2009</pubdate>

      <isbn>978-0-596-52126-4</isbn>

      <pagenums>310 (7, 13, 14, 16, )</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>definitive-guide-to-ws</abbrev>

      <authorgroup>
        <author>
          <firstname>Vanessa</firstname>

          <surname>Wang</surname>
        </author>

        <author>
          <firstname>Frank</firstname>

          <surname>Salim</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Moskovits</surname>
        </author>
      </authorgroup>

      <title>The Definitive Guide to HTML5 WebSocket</title>

      <subtitle>Build real-time web applications with HTML5</subtitle>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2012</pubdate>

      <isbn>978-1430247401</isbn>

      <pagenums>210 (140, 156, )</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>definitive-guide-to-html5</abbrev>

      <authorgroup>
        <author>
          <firstname>Adam</firstname>

          <surname>Freeman</surname>
        </author>
      </authorgroup>

      <title>The Definitive Guide to HTML5 - TODO cite from page 873
      multimedia chapter</title>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2011</pubdate>

      <isbn>978-1-4302-3960-4</isbn>

      <pagenums>1080 (880)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>js-definitive-guide</abbrev>

      <authorgroup>
        <author>
          <firstname>David</firstname>

          <surname>Flanagan</surname>
        </author>
      </authorgroup>

      <title>JavaScript: The Definitive Guide</title>

      <publisher>
        <publishername>O'Reilly Media</publishername>
      </publisher>

      <pubdate>2011</pubdate>

      <isbn>978-0-596-80552-4</isbn>

      <pagenums>1100 (320, 322, 333)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>js-enlightnment</abbrev>

      <authorgroup>
        <author>
          <firstname>Cody</firstname>

          <surname>Lindley</surname>
        </author>
      </authorgroup>

      <title>JavaScript Enlightenment</title>

      <publisher>
        <publishername>O'Reilly Media</publishername>
      </publisher>

      <pubdate>2013</pubdate>

      <isbn>978-1449342883</isbn>

      <pagenums>166 (49)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>async-javascript</abbrev>

      <authorgroup>
        <author>
          <firstname>Trevor</firstname>

          <surname>Burnham</surname>
        </author>
      </authorgroup>

      <title>Async JavaScript</title>

      <subtitle>Build More Responsive Apps with Less Code</subtitle>

      <publisher>
        <publishername>The Pragmatic Programmers</publishername>
      </publisher>

      <pubdate>2012</pubdate>

      <isbn>978-1-93778-527-7</isbn>

      <pagenums>104 (3)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>realtime-web-apps</abbrev>

      <authorgroup>
        <author>
          <firstname>Jason</firstname>

          <surname>Lengstorf</surname>
        </author>

        <author>
          <firstname>Phil</firstname>

          <surname>Leggetter</surname>
        </author>
      </authorgroup>

      <title>Realtime Web Apps</title>

      <subtitle>HTML5 WebSocket, Pusher, And The Web's Next Big
      Thing</subtitle>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2013</pubdate>

      <isbn>978-1430246206</isbn>

      <pagenums>400</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>pro-html5-programming</abbrev>

      <authorgroup>
        <author>
          <firstname>Peter</firstname>

          <surname>Lubbers</surname>
        </author>

        <author>
          <firstname>Frank</firstname>

          <surname>Salim</surname>
        </author>

        <author>
          <firstname>Brian</firstname>

          <surname>Albers</surname>
        </author>
      </authorgroup>

      <title>Pro HTML5 Programming</title>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2011</pubdate>

      <isbn>978-1-4302-3864-5</isbn>

      <pagenums>352 (165, ...)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>xmpp-in-javascript</abbrev>

      <authorgroup>
        <author>
          <firstname>Jack</firstname>

          <surname>Moffitt</surname>
        </author>
      </authorgroup>

      <title>Professional XMPP Programming with JavaScript and jQuery</title>

      <publisher>
        <publishername>John Wiley &amp; Sons</publishername>
      </publisher>

      <pubdate>2010</pubdate>

      <isbn>978-0470540718</isbn>

      <pagenums>432 (58, 380, 402)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>ember-in-action</abbrev>

      <authorgroup>
        <author>
          <firstname>Joachim</firstname>

          <othername>Haagen</othername>

          <surname>Skeie</surname>
        </author>
      </authorgroup>

      <title>Ember.js in Action</title>

      <publisher>
        <publishername>Manning Publications</publishername>
      </publisher>

      <pubdate>2013</pubdate>

      <isbn>978-1617291456</isbn>

      <pagenums>325 (21)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>ember-howto</abbrev>

      <authorgroup>
        <author>
          <firstname>Marc</firstname>

          <surname>Bodmer</surname>
        </author>
      </authorgroup>

      <title>Ember.js Application Development How-to</title>

      <publisher>
        <publishername>Packt Publishing</publishername>
      </publisher>

      <pubdate>2013</pubdate>

      <isbn>978-1-78216-338-1</isbn>

      <pagenums>40 (16)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>value-proposition</abbrev>

      <authorgroup>
        <author>
          <firstname>Cindy</firstname>

          <surname>Barnes</surname>
        </author>

        <author>
          <firstname>Helen</firstname>

          <surname>Blake</surname>
        </author>

        <author>
          <firstname>David</firstname>

          <surname>Pinder</surname>
        </author>
      </authorgroup>

      <title>Creating and Delivering Your Value Proposition: Managing Customer
      Experience for Profit</title>

      <publisher>
        <publishername>Kogan Page Publishers</publishername>
      </publisher>

      <pubdate>2009</pubdate>

      <isbn>978-0749458591</isbn>

      <pagenums>232</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>internet-usage</abbrev>

      <author>
        <surname>Miniwatts Marketing Group</surname>
      </author>

      <title>Internet Users in the World - 2012 Q2</title>

      <publisher>
        <publishername>Internet World Stats</publishername>
      </publisher>

      <pubdate>2/17/2013 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.internetworldstats.com/stats.htm">http://www.internetworldstats.com/stats.htm</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>facebook-usage</abbrev>

      <author>
        <firstname>Drew</firstname>

        <surname>Olanoff</surname>
      </author>

      <title>Facebook Announces Monthly Active Users Were At 1.01 Billion As
      Of September 30th</title>

      <publisher>
        <publishername>TechCrunch</publishername>
      </publisher>

      <pubdate>10/23/2012 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://techcrunch.com/2012/10/23/facebook-announces-monthly-active-users-were-at-1-01-billion-as-of-september-30th/">http://techcrunch.com/2012/10/23/facebook-announces-monthly-active-users-were-at-1-01-billion-as-of-september-30th/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ria</abbrev>

      <author>
        <firstname>James</firstname>

        <surname>Ward</surname>
      </author>

      <title>What is a Rich Internet Application?</title>

      <pubdate>10/17/2007 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.jamesward.com/2007/10/17/what-is-a-rich-internet-application/">http://www.jamesward.com/2007/10/17/what-is-a-rich-internet-application/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>celebrio-system</abbrev>

      <authorgroup>
        <author>
          <firstname>Pavol</firstname>

          <surname>Donko</surname>
        </author>

        <author>
          <firstname>Petr</firstname>

          <surname>Kunc</surname>
        </author>

        <author>
          <firstname>Martin</firstname>

          <surname>Novák</surname>
        </author>

        <author>
          <firstname>Pavel</firstname>

          <surname>Smolka</surname>
        </author>

        <author>
          <firstname>Jan</firstname>

          <surname>Volmut</surname>
        </author>
      </authorgroup>

      <title>Celebrio System</title>

      <pubdate>2013 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.celebriosoftware.com/celebrio-system">http://www.celebriosoftware.com/celebrio-system</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>elderly-questionnaires</abbrev>

      <authorgroup>
        <author>
          <firstname>Pavel</firstname>

          <surname>Smolka</surname>
        </author>

        <author>
          <firstname>Martin</firstname>

          <surname>Novák</surname>
        </author>
      </authorgroup>

      <title>Elderly people and the computers</title>

      <pubdate>2/11/2013 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://infogr.am/Seniori-a-pocitace">http://infogr.am/Seniori-a-pocitace</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>aol-trademarks</abbrev>

      <authorgroup>
        <author>
          <surname>AOL Inc.</surname>
        </author>
      </authorgroup>

      <title>AOL Trademark List</title>

      <pubdate>3/15/2011 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://legal.aol.com/trademarks/">http://legal.aol.com/trademarks/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xmpp-history</abbrev>

      <authorgroup>
        <author>
          <surname>The XMPP Standards Foundation</surname>
        </author>
      </authorgroup>

      <title>History of XMPP</title>

      <pubdate>1/27/2010 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://legal.aol.com/trademarks/">http://xmpp.org/about-xmpp/history/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>gtalk</abbrev>

      <authorgroup>
        <author>
          <surname>Google Developers</surname>
        </author>
      </authorgroup>

      <title>Google Talk Developer Documentation</title>

      <pubdate>3/23/2012 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://developers.google.com/talk/talk_developers_home">https://developers.google.com/talk/talk_developers_home</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>fb-chat</abbrev>

      <authorgroup>
        <author>
          <surname>Facebook Developers</surname>
        </author>
      </authorgroup>

      <title>Facebook Chat API</title>

      <pubdate>2/12/2013 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://legal.aol.com/trademarks/">http://xmpp.org/about-xmpp/history/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>brian-stats-tweet</abbrev>

      <authorgroup>
        <author>
          <surname>Staatss, B. (Brianstaats)</surname>
        </author>
      </authorgroup>

      <title><quote>If you have to customize 1/5 of a reusable component, its
      likely better to write it from scratch @trek at
      #embercamp</quote></title>

      <pubdate>2/15/2013 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>Tweet</releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>fb-erlang</abbrev>

      <author>
        <firstname>Eugene</firstname>

        <surname>Letuchy</surname>
      </author>

      <title>Facebook Chat</title>

      <pubdate>5/14/2008 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://www.facebook.com/note.php?note_id=14218138919">https://www.facebook.com/note.php?note_id=14218138919</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>skype-license</abbrev>

      <author>
        <firstname>Allen</firstname>

        <surname>Smith</surname>
      </author>

      <title>Does SkypeKit work on Android?</title>

      <subtitle>Forum post</subtitle>

      <pubdate>8/7/2012 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://devforum.skype.com/t5/SkypeKit-FAQs/Does-SkypeKit-work-on-Android/m-p/16490/thread-id/78">http://devforum.skype.com/t5/SkypeKit-FAQs/Does-SkypeKit-work-on-Android/m-p/16490/thread-id/78</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>skype-uri</abbrev>

      <author>
        <surname>Microsoft</surname>
      </author>

      <title>Skype URIs</title>

      <pubdate>2013 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://dev.skype.com/skype-uri">http://dev.skype.com/skype-uri</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-http</abbrev>

      <authorgroup>
        <author>
          <firstname>Roy</firstname>

          <othername>Thomas</othername>

          <surname>Fielding</surname>
        </author>

        <author>
          <firstname>James</firstname>

          <surname>Gettis</surname>
        </author>

        <author>
          <firstname>Jeffrey</firstname>

          <surname>Mogul</surname>
        </author>

        <author>
          <firstname>Henrik</firstname>

          <surname>Frystyk</surname>
        </author>

        <author>
          <firstname>Larry</firstname>

          <surname>Masinter</surname>
        </author>

        <author>
          <firstname>Paul</firstname>

          <surname>Leach</surname>
        </author>

        <author>
          <firstname>Tim</firstname>

          <surname>Berners-Lee</surname>
        </author>
      </authorgroup>

      <title>Hypertext Transfer Protocol -- HTTP/1.1</title>

      <subtitle>Request for Comments: 2616</subtitle>

      <pubdate>6/1999 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http://www.w3.org/Protocols/rfc2616/rfc2616.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>apache-core-features</abbrev>

      <author>
        <surname>The Apache Software Foundation</surname>
      </author>

      <title>Apache Core Features</title>

      <pubdate>2013 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://httpd.apache.org/docs/2.2/mod/core.html">http://httpd.apache.org/docs/2.2/mod/core.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-bidirectional-http</abbrev>

      <authorgroup>
        <author>
          <firstname>Salvatore</firstname>

          <surname>Loreto</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Stefano</firstname>

          <surname>Salsano</surname>
        </author>

        <author>
          <firstname>Greg</firstname>

          <surname>Wilkins</surname>
        </author>
      </authorgroup>

      <title>Known Issues and Best Practices for the Use of Long Polling and
      Streaming in Bidirectional HTTP</title>

      <subtitle>Request for Comments: 6202</subtitle>

      <pubdate>4/2011 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.ietf.org/rfc/rfc6202.txt">http://www.ietf.org/rfc/rfc6202.txt</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-ws</abbrev>

      <authorgroup>
        <author>
          <firstname>Ian</firstname>

          <surname>Fette</surname>
        </author>

        <author>
          <firstname>Alexey</firstname>

          <surname>Melnikov</surname>
        </author>
      </authorgroup>

      <title>The WebSocket Protocol</title>

      <subtitle>Request for Comments: 6455</subtitle>

      <pubdate>12/2011 [retrieved 2/24/2013]</pubdate>

      <publisher>
        <publishername>Internet Engineering Task Force (IETF)</publishername>
      </publisher>

      <issn>2070-1721</issn>

      <releaseinfo>from <ulink
      url="http://tools.ietf.org/html/rfc6455">http://tools.ietf.org/html/rfc6455</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-proxy</abbrev>

      <author>
        <firstname>Peter</firstname>

        <surname>Lubbers</surname>
      </author>

      <title>How HTML5 Web Sockets Interact With Proxy Servers</title>

      <subtitle>Request for Comments: 6455</subtitle>

      <pubdate>3/16/2011 [retrieved 2/24/2013]</pubdate>

      <publisher>
        <publishername>InfoQ</publishername>
      </publisher>

      <issn>2070-1721</issn>

      <releaseinfo>from <ulink
      url="http://tools.ietf.org/html/rfc6455">http://tools.ietf.org/html/rfc6455</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-api</abbrev>

      <author>
        <firstname>Ian</firstname>

        <surname>Hickson</surname>
      </author>

      <title>The WebSocket API</title>

      <subtitle>Editor's Draft</subtitle>

      <pubdate>2/9/2013 [retrieved 2/24/2013]</pubdate>

      <publisher>
        <publishername>W3C</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://dev.w3.org/html5/websockets/">http://dev.w3.org/html5/websockets/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>mozilla-ws</abbrev>

      <author>
        <surname>Mozilla Developers</surname>
      </author>

      <title>WebSockets</title>

      <pubdate>2/4/2013 [retrieved 2/25/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://developer.mozilla.org/en-US/docs/WebSockets">https://developer.mozilla.org/en-US/docs/WebSockets</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-html5rocks</abbrev>

      <authorgroup>
        <author>
          <firstname>Malte</firstname>

          <surname>Ubl</surname>
        </author>

        <author>
          <firstname>Eiji</firstname>

          <surname>Kitamura</surname>
        </author>
      </authorgroup>

      <title>Introducing WebSockets: Bringing Sockets to the Web</title>

      <pubdate>2/13/2012 [retrieved 2/25/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.html5rocks.com/en/tutorials/websockets/basics/">http://www.html5rocks.com/en/tutorials/websockets/basics/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-iana</abbrev>

      <author>
        <surname>IANA</surname>
      </author>

      <title>WebSocket Protocol Registries</title>

      <pubdate>11/13/2012 [retrieved 2/25/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.iana.org/assignments/websocket/websocket.xml">http://www.iana.org/assignments/websocket/websocket.xml</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-caniuse</abbrev>

      <author>
        <surname>StatCounter GlobalStats</surname>
      </author>

      <title>Can I use Web Sockets?</title>

      <pubdate>2/2013 [retrieved 3/3/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://caniuse.com/websockets">http://caniuse.com/websockets</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ie-statistics</abbrev>

      <author>
        <surname>Terabyte Media</surname>
      </author>

      <title>Web Browser Usage Statistics</title>

      <pubdate>12/2012 [retrieved 3/3/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.statowl.com/web_browser_usage_by_version.php?limit%5B%5D=ie">http://www.statowl.com/web_browser_usage_by_version.php?limit%5B%5D=ie</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0124</abbrev>

      <authorgroup>
        <author>
          <firstname>Ian</firstname>

          <surname>Paterson</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Dave</firstname>

          <surname>Smith</surname>
        </author>

        <author>
          <firstname>Jack</firstname>

          <surname>Moffit</surname>
        </author>
      </authorgroup>

      <title>XEP-0124: Bidirectional-streams Over Synchronous HTTP
      (BOSH)</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2010 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0124.html">http://xmpp.org/extensions/xep-0124.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0025</abbrev>

      <authorgroup>
        <author>
          <firstname>Joe</firstname>

          <surname>Hildebrand</surname>
        </author>

        <author>
          <firstname>Craig</firstname>

          <surname>Kaes</surname>
        </author>

        <author>
          <firstname>David</firstname>

          <surname>Waite</surname>
        </author>
      </authorgroup>

      <title>XEP-0025: Jabber HTTP Polling</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2009 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0025.html">http://xmpp.org/extensions/xep-0025.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0206</abbrev>

      <authorgroup>
        <author>
          <firstname>Ian</firstname>

          <surname>Paterson</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>
      </authorgroup>

      <title>XEP-0206: XMPP Over BOSH</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2010 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0206.html">http://xmpp.org/extensions/xep-0206.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>setting-up-bosh</abbrev>

      <author>
        <surname>Prosody</surname>
      </author>

      <title>Setting up a BOSH server</title>

      <pubdate>[retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://prosody.im/doc/setting_up_bosh">http://prosody.im/doc/setting_up_bosh</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xmpp-over-websockets</abbrev>

      <author>
        <firstname>Jack</firstname>

        <surname>Moffit</surname>
      </author>

      <title>An XMPP Sub-protocol for WebSocket</title>

      <pubdate>2/25/2013 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://datatracker.ietf.org/doc/draft-moffitt-xmpp-over-websocket/">http://datatracker.ietf.org/doc/draft-moffitt-xmpp-over-websocket/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>google-closing-xmpp</abbrev>

      <author>
        <firstname>John</firstname>

        <surname>Sullivan</surname>
      </author>

      <title>Google backslides on federated instant messaging, on
      purpose?</title>

      <pubdate>3/15/2013 [retrieved 3/31/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://www.fsf.org/blogs/sysadmin/google-backslides-on-federated-instant-messaging-on-purpose">https://www.fsf.org/blogs/sysadmin/google-backslides-on-federated-instant-messaging-on-purpose</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>spammy-invites</abbrev>

      <author>
        <firstname>Per</firstname>

        <surname>Gustafsson</surname>
      </author>

      <title>Spammy invites</title>

      <pubdate>2/13/2013 [retrieved 3/31/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://mail.jabber.org/pipermail/operators/2013-February/001571.html">http://mail.jabber.org/pipermail/operators/2013-February/001571.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0166</abbrev>

      <authorgroup>
        <author>
          <firstname>Scott</firstname>

          <surname>Ludwig</surname>
        </author>

        <author>
          <firstname>Joe</firstname>

          <surname>Beda</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Robert</firstname>

          <surname>McQueen</surname>
        </author>

        <author>
          <firstname>Sean</firstname>

          <surname>Egan</surname>
        </author>

        <author>
          <firstname>Joe</firstname>

          <surname>Hildebrand</surname>
        </author>
      </authorgroup>

      <title>XEP-0166: Jingle</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2009 [retrieved 3/31/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0166.html">http://xmpp.org/extensions/xep-0166.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>libjingle</abbrev>

      <author>
        <surname>Google Developers</surname>
      </author>

      <title>About libjingle</title>

      <pubdate>3/23/2012 [retrieved 3/31/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://developers.google.com/talk/libjingle/">https://developers.google.com/talk/libjingle/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>jingle-is-the-future</abbrev>

      <author>
        <firstname>Dave</firstname>

        <surname>Cridland</surname>
      </author>

      <title>Google: <quote>The Future is Jingle</quote></title>

      <pubdate>6/23/2011 [retrieved 3/31/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/2011/06/the-future-is-jingle/">http://xmpp.org/2011/06/the-future-is-jingle/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>flash-bundled-with-chrome</abbrev>

      <author>
        <firstname>Robin</firstname>

        <surname>Wauters</surname>
      </author>

      <title>Flash Player To Come Bundled With Google Chrome, New Browser
      Plugin API Coming</title>

      <publisher>
        <publishername>TechCrunch</publishername>
      </publisher>

      <pubdate>3/30/2010 [retrieved 4/5/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://techcrunch.com/2010/03/30/flash-player-to-come-bundled-with-google-chrome-new-browser-plugin-api-coming/">http://techcrunch.com/2010/03/30/flash-player-to-come-bundled-with-google-chrome-new-browser-plugin-api-coming/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>android-flash-support</abbrev>

      <author>
        <firstname>Geoff</firstname>

        <surname>Wauters</surname>
      </author>

      <title>Adobe Flash for Android: Gone with barely a whimper</title>

      <publisher>
        <publishername>Digital Trends</publishername>
      </publisher>

      <pubdate>8/17/2012 [retrieved 4/5/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.digitaltrends.com/mobile/adobe-flash-for-android-gone-with-barely-a-whimper/">http://www.digitaltrends.com/mobile/adobe-flash-for-android-gone-with-barely-a-whimper/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>iphone-flash-support</abbrev>

      <author>
        <surname>Apple Support Team</surname>
      </author>

      <title>Does the iPhone support Flash?</title>

      <pubdate>2007 [retrieved 4/5/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.iphonefaq.org/archives/9730">http://www.iphonefaq.org/archives/9730</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>signalr</abbrev>

      <author>
        <firstname>Damian</firstname>

        <surname>Edwards</surname>
      </author>

      <title>SignalR FAQ</title>

      <publisher>
        <publishername>GitHub</publishername>
      </publisher>

      <pubdate>9/7/2012 [retrieved 4/5/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://github.com/SignalR/SignalR/wiki/Faq">https://github.com/SignalR/SignalR/wiki/Faq</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>sse-api</abbrev>

      <author>
        <firstname>Ian</firstname>

        <surname>Hickson</surname>
      </author>

      <title>Server-Sent Events</title>

      <subtitle>Editor's Draft</subtitle>

      <pubdate>3/29/2013 [retrieved 4/5/2013]</pubdate>

      <publisher>
        <publishername>W3C</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://dev.w3.org/html5/eventsource/">http://dev.w3.org/html5/eventsource/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>sse-multiline</abbrev>

      <author>
        <firstname>Remy</firstname>

        <surname>Sharp</surname>
      </author>

      <title>Server-Sent Events</title>

      <subtitle>Editor's Draft</subtitle>

      <pubdate>1/24/2012 [retrieved 4/5/2013]</pubdate>

      <publisher>
        <publishername>HTML5Doctor</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://html5doctor.com/server-sent-events/">http://html5doctor.com/server-sent-events/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>bayeux</abbrev>

      <authorgroup>
        <author>
          <firstname>Alex</firstname>

          <surname>Russell</surname>
        </author>

        <author>
          <firstname>Greg</firstname>

          <surname>Wilkins</surname>
        </author>

        <author>
          <firstname>David</firstname>

          <surname>Davis</surname>
        </author>

        <author>
          <firstname>Mark</firstname>

          <surname>Nesbitt</surname>
        </author>
      </authorgroup>

      <title>The Bayeux Specification</title>

      <pubdate>2007 [retrieved 4/5/2013]</pubdate>

      <publisher>
        <publishername>The Dojo Foundation</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://svn.cometd.org/trunk/bayeux/bayeux.html">http://svn.cometd.org/trunk/bayeux/bayeux.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-signaling</abbrev>

      <author>
        <firstname>Sam</firstname>

        <surname>Dutton</surname>
      </author>

      <title>Getting Started with WebRTC</title>

      <pubdate>7/23/2012 [retrieved 4/6/2013]</pubdate>

      <publisher>
        <publishername>HTML5 Rocks</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://www.html5rocks.com/en/tutorials/webrtc/basics/">http://www.html5rocks.com/en/tutorials/webrtc/basics/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-rfc</abbrev>

      <authorgroup>
        <author>
          <firstname>Adam</firstname>

          <surname>Bergkvist</surname>
        </author>

        <author>
          <firstname>Daniel</firstname>

          <surname>Burnett</surname>
        </author>

        <author>
          <firstname>Cullen</firstname>

          <surname>Jennings</surname>
        </author>

        <author>
          <firstname>Anant</firstname>

          <surname>Narayanan</surname>
        </author>
      </authorgroup>

      <title>WebRTC 1.0: Real-time Communication Between Browsers</title>

      <subtitle>Editor's Draft</subtitle>

      <pubdate>3/22/2013 [retrieved 4/6/2013]</pubdate>

      <publisher>
        <publishername>W3C</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://dev.w3.org/2011/webrtc/editor/webrtc.html">http://dev.w3.org/2011/webrtc/editor/webrtc.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ice</abbrev>

      <authorgroup>
        <author>
          <firstname>Jonathan</firstname>

          <surname>Rosenberg</surname>
        </author>

        <author>
          <firstname>Ari</firstname>

          <surname>Keranen</surname>
        </author>

        <author>
          <firstname>Bruce</firstname>

          <surname>Lowekamp</surname>
        </author>

        <author>
          <firstname>Adam</firstname>

          <surname>Roach</surname>
        </author>
      </authorgroup>

      <title>TCP Candidates with Interactive Connectivity Establishment
      (ICE)</title>

      <pubdate>5/18/2012 [retrieved 4/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://tools.ietf.org/html/draft-ietf-mmusic-ice-tcp-16">http://tools.ietf.org/html/draft-ietf-mmusic-ice-tcp-16</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-interop</abbrev>

      <authorgroup>
        <author>
          <firstname>Maire</firstname>

          <surname>Reavy</surname>
        </author>

        <author>
          <firstname>Serge</firstname>

          <surname>Lachapelle</surname>
        </author>
      </authorgroup>

      <title>Hello Firefox, this is Chrome calling!</title>

      <pubdate>2/4/2013 [retrieved 4/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://blog.chromium.org/2013/02/hello-firefox-this-is-chrome-calling.html">http://blog.chromium.org/2013/02/hello-firefox-this-is-chrome-calling.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-ericsson</abbrev>

      <authorgroup>
        <author>
          <firstname>Stefan</firstname>

          <surname>Alund</surname>
        </author>
      </authorgroup>

      <title>Bowser – The World’s First WebRTC-Enabled Mobile Browser</title>

      <pubdate>10/19/2012 [retrieved 4/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://labs.ericsson.com/blog/bowser-the-world-s-first-webrtc-enabled-mobile-browser">https://labs.ericsson.com/blog/bowser-the-world-s-first-webrtc-enabled-mobile-browser</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-ms</abbrev>

      <authorgroup>
        <author>
          <firstname>Bernard</firstname>

          <surname>Aboba</surname>
        </author>

        <author>
          <firstname>Martin</firstname>

          <surname>Thomson</surname>
        </author>
      </authorgroup>

      <title>Customizable, Ubiquitous Real Time Communication over the Web
      (CU-RTC-Web)</title>

      <pubdate>8/9/2012 [retrieved 4/6/2013]</pubdate>

      <publisher>
        <publishername>Microsoft</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://html5labs.interoperabilitybridges.com/cu-rtc-web/cu-rtc-web.htm">http://html5labs.interoperabilitybridges.com/cu-rtc-web/cu-rtc-web.htm</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc-skype</abbrev>

      <authorgroup>
        <author>
          <firstname>Janko</firstname>

          <surname>Roettgers</surname>
        </author>
      </authorgroup>

      <title>Scoop: Microsoft bets on WebRTC for Skype’s browser
      future</title>

      <pubdate>6/26/2012 [retrieved 4/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://gigaom.com/2012/06/26/skype-webrtc-web-client/">http://gigaom.com/2012/06/26/skype-webrtc-web-client/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>webrtc4all</abbrev>

      <authorgroup>
        <author>
          <surname>Doubango Telecom</surname>
        </author>
      </authorgroup>

      <title>webrtc4all</title>

      <pubdate>2012 [retrieved 4/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://code.google.com/p/webrtc4all/">https://code.google.com/p/webrtc4all/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>jquery-api</abbrev>

      <authorgroup>
        <author>
          <surname>The jQuery Foundation</surname>
        </author>
      </authorgroup>

      <title>jQuery API Documentation</title>

      <pubdate>2013 [retrieved 4/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://api.jquery.com/append/">http://api.jquery.com/append/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>strophe-api</abbrev>

      <authorgroup>
        <author>
          <firstname>Jack</firstname>

          <surname>Moffitt</surname>
        </author>
      </authorgroup>

      <title>Strophe.js API Documentation</title>

      <pubdate>2013 [retrieved 4/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://strophe.im/strophejs/doc/1.0.2/files2/strophe-js.html">http://strophe.im/strophejs/doc/1.0.2/files2/strophe-js.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>attached-to-strophe</abbrev>

      <authorgroup>
        <author>
          <firstname>Jack</firstname>

          <surname>Moffitt</surname>
        </author>
      </authorgroup>

      <title>Getting Attached To Strophe</title>

      <pubdate>8/3/2008 [retrieved 4/15/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://metajack.im/2008/10/03/getting-attached-to-strophe/">http://metajack.im/2008/10/03/getting-attached-to-strophe/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>fat-model-skinny-controller</abbrev>

      <authorgroup>
        <author>
          <firstname>Jon</firstname>

          <surname>Cairns</surname>
        </author>
      </authorgroup>

      <title><quote>Fat model, skinny controller</quote> is a load of
      rubbish</title>

      <pubdate>4/11/2013 [retrieved 4/21/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://joncairns.com/2013/04/fat-model-skinny-controller-is-a-load-of-rubbish/">http://joncairns.com/2013/04/fat-model-skinny-controller-is-a-load-of-rubbish/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>yehuda-talk</abbrev>

      <authorgroup>
        <author>
          <firstname>Yehuda</firstname>

          <surname>Katz</surname>
        </author>
      </authorgroup>

      <title>Building Web Applications with Ember.js</title>

      <pubdate>4/13/2013 [retrieved 4/26/2013]</pubdate>

      <publisher>
        <publishername>YouTube</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://www.youtube.com/watch?v=u6RFyVN9sNg">http://www.youtube.com/watch?v=u6RFyVN9sNg</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>new-dev-era</abbrev>

      <authorgroup>
        <author>
          <firstname>Tarek</firstname>

          <surname>Ziadé</surname>
        </author>
      </authorgroup>

      <title>A new development era (essay)</title>

      <pubdate>1/25/2013 [retrieved 4/26/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://blog.ziade.org/2013/01/25/a-new-development-era-essay/">http://blog.ziade.org/2013/01/25/a-new-development-era-essay/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-3921</abbrev>

      <authorgroup>
        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>
      </authorgroup>

      <title>Extensible Messaging and Presence Protocol (XMPP): Instant
      Messaging and Presence</title>

      <pubdate>2004 [retrieved 5/4/2013]</pubdate>

      <publisher>
        <publishername>Jabber Software Foundation</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://xmpp.org/rfcs/rfc3921.html">http://xmpp.org/rfcs/rfc3921.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>intern-blog</abbrev>

      <authorgroup>
        <author>
          <firstname>Paul</firstname>

          <surname>Bouchon</surname>
        </author>
      </authorgroup>

      <title>Meet your newest Intern</title>

      <pubdate>5/1/2013 [retrieved 5/4/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.sitepen.com/blog/2013/05/01/intern-javascript-testing/">http://www.sitepen.com/blog/2013/05/01/intern-javascript-testing/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>chai-tdd</abbrev>

      <authorgroup>
        <author>
          <firstname>Jake</firstname>

          <surname>Luer</surname>
        </author>
      </authorgroup>

      <title>Chai API - TDD</title>

      <pubdate>2013 [retrieved 5/4/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://chaijs.com/api/assert/">http://chaijs.com/api/assert/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>chai-bdd</abbrev>

      <authorgroup>
        <author>
          <firstname>Jake</firstname>

          <surname>Luer</surname>
        </author>
      </authorgroup>

      <title>Chai API - BDD</title>

      <pubdate>2013 [retrieved 5/4/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://chaijs.com/api/bdd/">http://chaijs.com/api/bdd/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>spammy-invites-update</abbrev>

      <authorgroup>
        <author>
          <firstname>Per</firstname>

          <surname>Gustafsson</surname>
        </author>
      </authorgroup>

      <title>Update on spammy invites</title>

      <pubdate>5/4/2013 [retrieved 5/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://mail.jabber.org/pipermail/operators/2013-April/001672.html">http://mail.jabber.org/pipermail/operators/2013-April/001672.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>opentok-pricing</abbrev>

      <authorgroup>
        <author>
          <surname>TokBox Inc.</surname>
        </author>
      </authorgroup>

      <title>OpenTok pricing</title>

      <pubdate>2013 [retrieved 5/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.tokbox.com/pricing">http://www.tokbox.com/pricing</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>opentok-server-side-lib</abbrev>

      <authorgroup>
        <author>
          <surname>TokBox Inc.</surname>
        </author>
      </authorgroup>

      <title>OpenTok server-side libraries reference</title>

      <pubdate>2013 [retrieved 5/6/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.tokbox.com/opentok/docs/server/server_side_libraries.html">http://www.tokbox.com/opentok/docs/server/server_side_libraries.html</ulink></releaseinfo>
    </biblioentry>
  </bibliography>

  <index></index>

  <appendix id="appendix-screenshots">
    <title>Screenshots of the application</title>

    <para>Some screenshots from Celebrio Talker</para>
  </appendix>
</book>
