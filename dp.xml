<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!--[
<!ENTITY % fithesis SYSTEM "http://www.fi.muni.cz/~xpavlov/fithesis.mod">
%fithesis;
]>
-->
<book lang="en">
  <bookinfo>
    <title>Real-time Communication in Web Browser</title>

    <subtitle>Master thesis</subtitle>

    <author>
      <firstname>Pavel</firstname>

      <surname>Smolka</surname>

      <fi:woman
      xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">false</fi:woman>

      <fi:faculty
      xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">fi</fi:faculty>

      <fi:advisor xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">doc.
      RNDr. Tomáš Pitner, Ph.D.</fi:advisor>
    </author>

    <fi:thanks xmlns:fi="http://www.fi.muni.cz/~xpavlov/fithesis">Thanks to
    everyone... TODO: Petr Kunc (help with OpenTok &amp; RealTime
    communication,</fi:thanks>

    <pubdate>2013</pubdate>

    <abstract>
      <para>TODO</para>
    </abstract>

    <keywordset>
      <keyword>XMPP</keyword>

      <keyword>real-time communication</keyword>

      <keyword>RTC</keyword>

      <keyword>Celebrio</keyword>

      <keyword>web browser</keyword>

      <keyword>HTTP</keyword>

      <keyword>Comet</keyword>

      <keyword>JavaScript</keyword>

      <keyword>TODO</keyword>
    </keywordset>
  </bookinfo>

  <toc></toc>

  <chapter id="uvod">
    <title>Introduction</title>

    <para>Millions, billions, trillions. That many and even more messages are
    exchanged every day between various people over the world. The Internet
    created brand new way to communicate and collaborate, even if you are
    located on the opposite parts of the world. Since the times of Alexander
    Graham Bell, the accesibility to the communication devices and their
    simplicity incredibly enhanced. Nowadays, almost 2.5 billion people over
    the world have access to the Internet and therefore they are able to use
    almost limitless communication possibilities it provides.
    <citation>internet-usage</citation></para>

    <para>However, the manner of Internet usage essentially changed during the
    first decade of 21st century. Using the Internet and using the web browser
    became almost synonyms. People use the web browser as the primary platform
    to do every single task on the Internet. Sometimes it's not even possible
    to use the other internet services without visiting certain web page in
    the web browser and performing the authentication there.<footnote>
        <para>Two examples of such behavior. Wi-fi network in the Student
        Agency coaches forces the user to visit the entry page in the web
        browser. The second example, very well known to the students of the
        Faculty of Informatics at Masaryk University, is the faculty wireless
        network called wlan_fi. Every user has to open the web browser and log
        in with her credentials. It's not possible just to open the terminal
        or e-mail client and start working online.</para>
      </footnote> Considering the mentioned fact, web browsers became also the
    basic platform for the communication tools. Even though the purpose of the
    world wide web and HTTP protocol was completely different at first
    (displaying single documents connected via hypertext links), it appeared
    that there is the need of common rich applications running withing web
    browser - rich internet application sprung up. <citation>ria</citation> So
    popular social networks are built on top of the web browser platform and
    they are used by more than billion people over the world.
    <citation>facebook-usage</citation> And the main reason why the social
    networks are so popular is the real-time stream of news and messages from
    the other people. By the beginning of the year 2013, I would say that
    static web is dead - users prefer interactivity.</para>

    <para>This thesis embraces the topic of real-time applications in web
    browsers, especially the text communication tools and the technologies
    being used to develop them. It also describes the problem of
    <quote>inter-process</quote> communication between various web pages which
    need to cooperate and exchange information as quickly as possible.
    Finally, the possibilities of multimedia content transfer (audio and
    video) and the current options of capturing multimedia directly from the
    web browser are described as well.</para>

    <para>As mentioned above, the web browser became one of the most popular
    platforms. Celebrio, simple software for the elderly simulating the
    operating system interface, is typical example of rich internet
    application. <citation>celebrio-system</citation> All the topics mentioned
    in the previous paragraph appeared to be very important in the system.
    When interviewing the elderly people in the Czech Republic, it appeared
    that almost 90 % of the elderly computer users use the real-time
    communication (RTC) applications, mostly Skype.
    <citation>elderly-questionnaires</citation> Interaction with their loved
    ones is the most desired benefit they expect from the computer. Therefore,
    creating real-time application, text messenger supporting video calling,
    became not only programming challenge but also a business goal.</para>

    <para>Considering the fact the people like real-time communication (not
    only direct messaging but also real-time cooperation, simultaneous
    document editing or playing multiplayer games) while using web browser
    brings us the question what the currently available solutions are. There
    are <quote>big players</quote> providing their own services as
    closed-source, without the possibility to use them. To name the most
    important, it's Google Talk web browser client and Facebook chat, using
    XMPP protocol. <citation>gtalk</citation><citation>fb-chat</citation> Even
    though Facebook chat service is not pure XMPP server implementation (the
    message and presence engine is proprietary system of Facebook implemented
    mostly in C++ and Erlang), they provide the possibility to connect to the
    <quote>world of Facebook Chat</quote> via XMPP as proxy.
    <citation>fb-erlang</citation> Combination of the facts that XMPP is open
    technology with open-sourced client and server implementations
    <citation>xmpp-history</citation> and the big internet companies also use
    it persuaded us to use it in our communication application too. XMPP
    itself and its usage in web applications is described in <xref
    linkend="chap-xmpp" />.</para>

    <para>Since the web browser was designed to perform simple
    requests/response interaction, it is not a typical platform for building
    real-time application. Thus, there is a need for an extra layer enhancing
    or even completely replacing the common way HTTP communicates. Within the
    scope of this thesis, namely the WebSockets and HTTP long polling
    approaches are used. The two of them and basic infromation about several
    others are covered in <xref linkend="chap-rtc" />.</para>

    <para>There are many existing real-time chat-based applications over the
    Internet we could have used. However, none of them suited our needs
    perfectly. Celebrio has very specific graphical user interface (GUI) and
    there is a need to integrate both text-based chat and video calling. Just
    to mention, there is commercial chat module Cometchat<footnote>
        <para>http://www.cometchat.com/</para>
      </footnote> or even open project Jappix.<footnote>
        <para>https://project.jappix.com/</para>
      </footnote> Video calling web browser applications are provided for
    example by TokBox Inc.<footnote>
        <para>http://www.tokbox.com/</para>
      </footnote> Nevertheless, following the rule that <quote>If you have to
    customize 1/5 of a reusable component, its likely better to write it from
    scratch</quote>, <citation>brian-stats-tweet</citation> just very generic
    existing libraries (Strophe.js) and APIs (OpenTok) were used for
    implementing brand new application called <emphasis>Celebrio
    Talker</emphasis>. The general approaches when building web browser based
    chat application are mentioned in <xref
    linkend="chap-xmpp-in-javascript" />. Within the programming part of the
    thesis, the real-time text chat application, video calling application and
    simple <quote>inter-process</quote> communication tool for Celebrio has
    been implemented. Celebrio Talker application itself, its architecture and
    the specific procedures used to create it are described in <xref
    linkend="chap-talker" />.</para>

    <para>It has been said that Skype<footnote>
        <para>http://www.skype.com/</para>
      </footnote> is the most favorite communication tool among the target
    audience. If it had been implemented, the existing customer base could be
    used and converted to our messaging application. However, there is one big
    pitfall in this approach. Skype license strictly prohibits incorporating
    their software into mobile devices. <citation>skype-license</citation>
    They support only prompting the official Skype client to be opened via
    Skype URI, which is insufficient for Celebrio since the messaging client
    has to be built in the system, with the corresponding user interface.
    <citation>skype-uri</citation></para>

    <para>Finally, there are several notes about <quote>inter-process
    communication</quote> between different applications running separately in
    various browser frames, tabs or even windows. <xref
    linkend="chap-inter-process" /> covers this topic and describes the issues
    we came accross when implementing such functionality for Celebrio, where
    every application runs in separate iframe.</para>
  </chapter>

  <chapter id="chap-rtc">
    <title>Bidirectional communication</title>

    <para>The very essence of every instant messaging is the bidirectional
    stream where both sides can immediately <emphasis>push</emphasis> new data
    and the other side (or more other sides, respectively) is promptly
    notified without the need to perform any manual <emphasis>pull</emphasis>
    (update) action<indexterm>
        <primary>pull &amp; push communication</primary>
      </indexterm>.<footnote>
        <para>In this thesis, this behaviour is commonly refered as RTC. The
        <quote>real-time part</quote> relates mostly to the server part since
        the application running in the web browser can perform the AJAX
        request on background anytime and the server receives the request
        instantly. Before AJAX became the essential part of every web app,
        ifram</para>
      </footnote> Such use case requires appropriate transport layer on top
    which the application can send the messages via any other protocol. When
    using HTTP, there is a TCP connection opened by the client (web browser)
    through which the data is sent. However, according to the HTTP protocol,
    the communication is strictly initiated by the client - HTTP is a
    request/response protocol. <citation>rfc-http</citation> When the client
    needs still up-to-date information, it must poll the server as frequently
    as possible. Such approach takes a lot of bandwidth and generates
    purposeless overhead on the server. So, when one wants to avoid that
    drawbacks and still make the web browser application to communicate in
    both directions, HTTP protocol must be hacked somehow or another
    communication channel has to be used. This chapter covers both - reshaping
    HTTP in <xref linkend="chap-http-requests" /> and brand new approach in
    <xref linkend="chap-ws" />, bypassing HTTP at all. Unfortunatelly, every
    approach brings also some disadvantages.</para>

    <sect1 id="chap-http-requests">
      <title>Using HTTP requests</title>

      <para>Historicaly the first approach, for a very long time the only one,
      is hacking HTTP to achieve RTC. The idea is very simple, depicted in
      TODO figure. Generally, the client sends an extra request and it is not
      awaiting the response immediately. Instead, the server keeps the request
      for some time. There are several techniques to achieve such behaviour,
      in general called <emphasis>Comet</emphasis><indexterm>
          <primary>Comet</primary>
        </indexterm>.</para>

      <para>There is one common misunderstanding about long-lived HTTP
      requests. Since HTTP 1.1 (acutally implemented even before, but not
      covered in the RFC specification), there is a possibility for the client
      to claim persistent TCP connection to the server declaring
      <computeroutput>Connection: Keep-Alive</computeroutput> in the request
      header.<indexterm>
          <primary>HTTP</primary>

          <secondary>Keep-Alive</secondary>
        </indexterm> Actually, all connections are considered persistent
      unless declared otherwise. <citation>rfc-http</citation> Even though the
      default timeout after which the server closes the connection is only a
      few seconds, <citation>apache-core-features</citation> the persistent
      TCP connection is very useful for delivering various resources
      (stylesheets, scripts, images, etc.) to the client without the
      unnecessary overhead of creating multiple streams. However, every single
      transmission within the TCP connection has to be in form of separate
      HTTP request/response, always initiated by the client. On no account is
      the server allowed to push any data without respective request from the
      client. Therefore, such TCP connection is of no use for RTC. TODO
      figure.</para>

      <sect2 id="chap-http-long-polling">
        <title>HTTP long polling<indexterm>
            <primary>HTTP</primary>

            <secondary>long polling</secondary>
          </indexterm></title>

        <para>The essence of HTTP long polling springs from the idea of
        prolonging the time span between two poll requests. In traditional
        <quote>short polling</quote>, a client sends regular requests to the
        server and each request attempts to <quote>pull</quote> the available
        data. If no data is available, an empty reponse is sent.
        <citation>rfc-bidirectional-http</citation> That generates unnecessary
        overhead for both client and server.</para>

        <para>On the contrary, long polling tries to reduce this load. After
        receiving the request, the server does not answer immediately and
        holds the connection. When the server receives (or even makes up by
        oneself) new data, it carries out the response with the respective
        content. As soon the client obtains the response, it usually issues a
        new request immediately so the process can repeat endlessly. If no
        data appears on the server for certain amount of time, it usually
        responds with empty data field just to renew the connection.</para>

        <para>One of the main drawbacks of long polling is header overhead.
        Every chunk of data in RTC applications is usually very short, for
        example some text message of minimal length. However, each update is
        served by full HTTP request/response with the header easily reaching
        800 characters. <citation>pro-html5-programming</citation> In case the
        payload is a message 20 characters long, the header constitutes 4000%
        overhead!<indexterm>
            <primary>HTTP</primary>

            <secondary>header overhead</secondary>
          </indexterm> This drawback has even bigger impact as the number of
        clients increases. <xref linkend="fig-http-overhead" /> shows the
        comparsion of 1000 (A), 10000 (B) and 100000 (C) clients polling the
        server every second with the message 20 characters long, both using
        classic HTTP requests and WebSockets technology (mentioned in <xref
        linkend="chap-ws" />).
        <citation>pro-html5-programming</citation></para>

        <figure id="fig-http-overhead">
          <title>Comparison of the unnecessary network overhead between the
          HTTP polling and using WebSockets
          <citation>pro-html5-programming</citation></title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="img/http-overhead.png" width="420pt" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Furthermore, in case the server just received the data and sent
        the response to the client, there is a <quote>blind window</quote>
        when the server cannot notify the client. Whole push system is blocked
        until the response is received by the client, processed and new
        request is delivered back to the server. Considering also the possible
        packet loss and required retransmission in TCP protocol, the delay can
        be even longer than double bandwidth latency.
        <citation>rfc-bidirectional-http</citation></para>
      </sect2>

      <sect2 id="chap-http-streaming">
        <title>HTTP streaming<indexterm>
            <primary>HTTP</primary>

            <secondary>streaming</secondary>
          </indexterm></title>

        <para>HTTP streaming is slightly different method than long polling,
        although they are confused one with the other very often. What is
        mutual for both of the approaches is the client initializing the
        communication with HTTP request. The server also sends the update as
        the part of the HTTP response. The main difference is that once the
        server initializes the response and sends the data, it does not
        terminate the response and keeps the HTTP connection opened.
        Meanwhile, the client listens to the response stream and reads the
        data pushed from the server. When any new data springs up on the
        server side, it is concatenated to the one existing response stream.
        <citation>rfc-bidirectional-http</citation> See the schema on TODO
        figure.</para>

        <para>It is very important not to confuse HTTP streaming with the
        <quote>persistent</quote> HTTP requests. As said at the beginning of
        this chapter, declaring <computeroutput>Connection:
        Keep-Alive</computeroutput> does not allow the server to issue
        multiple responses to a single request. Such behaviour would be
        serious violation of HTTP protocol. Instead, the server can declare
        <computeroutput>Transfer-Encoding: chunked</computeroutput><indexterm>
            <primary>HTTP</primary>

            <secondary>chunked response</secondary>
          </indexterm> status in the response header and send the response
        split into separate pieces, as show below (chunk of zero length stands
        for the end of the response):
        <citation>rfc-bidirectional-http</citation></para>

        <programlisting>HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

0</programlisting>

        <para>The main drawback of HTTP streaming can be generally called
        buffering. There is no requirement for both the client and any
        intermediary (proxies, gateways, etc.) to handle the incoming data
        until whole response is sent. Therefore, all parts of the response
        could be kept by the proxy and the messages (single HTTP response
        chunks) are not delivered to the client until whole response is sent.
        Similarly, when the response consists of JavaScript statements, the
        browser does not have to execute them before whole response is
        obtained (yet, most of the browsers execute it immediately). In such
        cases, HTTP streaming will not work.
        <citation>rfc-bidirectional-http</citation></para>
      </sect2>
    </sect1>

    <sect1 id="chap-ws">
      <title>WebSockets</title>

      <para>Although the World Wide Web with HTTP request/response schema has
      never been intended to server as RTC platform, the contemporary
      applications require such functionality and the developers started to
      bend the protocol in the undesirable way. Most of the patterns described
      in <xref linkend="chap-http-streaming" /> do their jobs and one can
      achieve sufficient two-way communication, but there are certain
      performance issues and drawbacks which make them difficult to use. At
      least, those techniques carry HTTP header overhead which is unnecessary
      for standard bidirectional streams. Therefore, brand new standard for
      creating full-duplex communication channels between the web browser and
      the server has been created. The technology is called
      <emphasis>WebSockets</emphasis><indexterm>
          <primary>WebSocket</primary>
        </indexterm> (sometimes shortened as WS) and it stands for a
      communication protocol layered over TCP along with the browser API for
      web developers. Anyway, not even WebSockets are allowed to access wider
      network, the connection possibilities are limited only to the dedicated
      WS servers (usually HTTP servers with additional module for WS support
      attached). <citation>js-definitive-guide</citation></para>

      <para>Similarly as in HTTP, there is an unencrypted version of
      WebSockets working directly on top of TCP connection. The simpliest way
      to recognize such connection is WebSocket URI<indexterm>
          <primary>WebSocket</primary>

          <secondary>URI</secondary>
        </indexterm> beginning with <computeroutput>ws://</computeroutput>. It
      should not be used on account of two reasons. The first one, quite
      obvious, is security - the communication can be captured during the
      transmission. Transparent proxy servers are the second reason. If an
      unencrypted WebSocket connection is used, the browser is unaware of the
      transparent proxy and as a result, the WebSocket connection is most
      likely to fail.
      <citation>ws-proxy</citation><citation>definitive-guide-to-ws</citation>
      As opposite, there is a secure way how to use WebSockets. WebSockets
      Secure (WSS)<indexterm>
          <primary>WebSocket</primary>

          <secondary>Secure</secondary>
        </indexterm> protocol is standard WS wrapped in TLS tunnel, similarly
      as HTTP can be transmitted over TLS layer. When using WSS, the URI
      begins with <computeroutput>wss://</computeroutput> and it uses port 443
      by default. <citation>definitive-guide-to-ws</citation></para>

      <sect2>
        <title>Handshake<indexterm>
            <primary>WebSocket</primary>

            <secondary>handshake</secondary>
          </indexterm></title>

        <para>Alike any other multilateral protocol WebSockets need to perform
        a handshake before actual transmission can take place. During the
        handshake, the connection is established and both peers acknowledge
        the properties of the communication.</para>

        <para>Since WebSockets emerged as HTTP supplement, the handshake is
        initialized by HTTP request<footnote>
            <para>According to RFC6455, the protocol is designed to work over
            HTTP ports 80 and 443 as well to support HTTP proxies. However,
            the design is not limited to HTTP and the future implementations
            can use simplier handshake over a dedicated port.
            <citation>rfc-ws</citation></para>
          </footnote> initialized by the client. The client sends the request
        as follows: <citation>rfc-ws</citation></para>

        <programlisting>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13</programlisting>

        <para>Let us have a look what each of the lines means. The first two
        lines are obvious, they represent typical HTTP GET request. Specifying
        <computeroutput>Host</computeroutput> is important for the server to
        be able to handle multiple virtual hosts on single IP address. The
        following two lines, <computeroutput>Upgrade:
        websocket</computeroutput> and <computeroutput>Connection:
        Upgrade</computeroutput>, are the most important. The client informs
        the server about the desire to use WS. The rest of the request stands
        for additional information for the server to be able to respond
        correctly - RFC 6455 describes them in detail.</para>

        <para>The server should send HTTP response looking similar as this
        example: <citation>rfc-ws</citation></para>

        <programlisting>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</programlisting>

        <para>Number 101 on the first line of the response stands for HTTP
        status code <computeroutput>Switching Protocols</computeroutput>,
        <citation>rfc-http</citation> which means the server supports
        WebSockets and the connection can be established. Any status code
        other than 101 indicates that the WebSocket handshake has not
        completed and that the semantics of HTTP still apply.
        <citation>rfc-ws</citation></para>

        <para><computeroutput>Sec-WebSocket-Key</computeroutput> is random
        secret issued by the client and added to the initial
        protocol-switching request. The server is supposed to concatenate the
        secret with Globally Unique Identifier (GUID)<indexterm>
            <primary>GUID</primary>
          </indexterm> "258EAFA5-E914-47DA- 95CA-C5AB0DC85B11" and hash the
        result with SHA-1 algorithm. The resultis returned as
        <computeroutput>Sec-WebSocket-Accept</computeroutput> header field,
        base64-encoded. <citation>rfc-ws</citation> However, there seems to be
        a security issue here. If the initial request is not sent over
        encrypted HTTP connection (HTTPS), it can be caught by a third party.
        Since the server does not authenticate in any way and the algorithm
        does not contain any server secret, the third party attacker could
        fake the response and pretend to be the server.</para>
      </sect2>

      <sect2>
        <title>Frames and masking</title>

        <para>All the data sent via WebSockets protocol is chunked into
        frames<indexterm>
            <primary>frames</primary>
          </indexterm>, working similarly as TCP frames. All the transmission
        features are handled by the WebSocket API and the transmission is
        transparent for the application layer above (for example JavaScript
        API) so that that every message appears in the same state as it was
        sent.</para>

        <para>There are several special features concerning WS frames, one of
        the interesting is masking<indexterm>
            <primary>masking</primary>
          </indexterm>. The payload data of every frame sent from the client
        is XORed by the masking key of 32-bit size. The purpose of masking is
        to prevent any third party from picking any part of the payload and
        reading it. The other goal might be distinguishing the server stream
        from the client stream instantly since client-to-server frames always
        <emphasis>must</emphasis> be masked and server-to-client frames
        <emphasis>must not</emphasis> be masked under any circumstances. In
        addition, WS peers have to use masking even if the communication is
        running on top of TLS layer so the <quote>encryption</quote> function
        is pointless. <citation>rfc-ws</citation> The security function of
        masking is also questionable because the masking key is included in
        the frame header. The only reason is preventing from random
        cross-protocol attacks.
        <citation>pro-html5-programming</citation></para>
      </sect2>

      <sect2>
        <title>JavaScript API<indexterm>
            <primary>WebSocket</primary>

            <secondary>API</secondary>
          </indexterm></title>

        <para>Since WebSocket technology is intended to be used particularly
        from the browser applications, there is need of an API web developers
        can use. The most widespread programming language of web browser
        client applications is JavaScript and so is the WebSocket API created
        for. The API consists of one relatively simple JavaScript interface
        called <computeroutput>WebSocket</computeroutput>,<footnote>
            <para>In the older versions of some browsers, the interface was
            called differently due to the immaturity of the technology. For
            instance, Firefox from version 6 to 10 supports WebSockets only as
            <computeroutput>MozWebSocket</computeroutput>. Interesting fact is
            that Firefox 4 and 5 provides
            <computeroutput>WebSocket</computeroutput> interface as it is,
            just implementing different WebSocket protocol version. Since
            Firefox 11.0, current (RFC 6455) WS protocol version is accessible
            via interface <computeroutput>WebSocket</computeroutput>.
            <citation>mozilla-ws</citation></para>
          </footnote> <citation>ws-api</citation> placed as the property of
        <computeroutput>window</computeroutput> object.<footnote>
            <para>Properties of window are accessible in JavaScript directly.
            Simple test <computeroutput>window.WebSocket ===
            WebSocket</computeroutput> returning
            <computeroutput>true</computeroutput> proves it.</para>
          </footnote> It wraps the WebSocket client functionality performed by
        the user agent (web browser). Using the API is very simple - the
        object, which handles all the WS functionality, is created by calling
        <computeroutput>WebSocket()</computeroutput> constructor:
        <citation>ws-html5rocks</citation></para>

        <programlisting>var connection = new WebSocket(
        'ws://html5rocks.websocket.org/echo', 
        ['soap', 'xmpp']
);</programlisting>

        <para>The first (mandatory) argument stands for the WebSocket URI the
        client attempts to connect to. It can either begin with
        <type>ws://</type> prefix or <type>wss://</type>, depending whether
        TLS layer is used or not. The second parameter is optional - specific
        WS subprotocols can be demanded there. Since there are only a few
        subprotocols recorded by IANA registry, it is of a little use so far.
        <citation>ws-iana</citation></para>

        <para><computeroutput>WebSocket</computeroutput> interface provides at
        least four event handlers, to each of them a custom callback can be
        attached. <citation>ws-api</citation> Those are
        <computeroutput>onopen</computeroutput>,
        <computeroutput>onmessage</computeroutput>,
        <computeroutput>onerror</computeroutput> and
        <computeroutput>onclose</computeroutput>. The names are quite
        self-explanatory, they serve as the event listeners watching the
        incoming activity - anytime the websocket obtains a message, its
        status changes or an error occurs, the respective callback is fired.
        The callback registration can look as follows:</para>

        <programlisting>connection.onmessage = function (message) {
  console.log('We got a message: ' + message.data);
};</programlisting>

        <para>In addition, there is a property
        <computeroutput>readyState</computeroutput> (it would be
        <computeroutput>connection.readyState</computeroutput> in the previous
        example) keeping current WebSocket status all the time. The status can
        be retrieved by testing the property against one of the
        <computeroutput>WebSocket</computeroutput> property constants
        <computeroutput>CONNECTING</computeroutput>,
        <computeroutput>OPEN</computeroutput>,
        <computeroutput>CLOSING</computeroutput> or
        <computeroutput>CLOSED</computeroutput>.</para>

        <para>Sending the data to the server is also quite straightforward.
        Either <computeroutput>DOMString</computeroutput>,
        <computeroutput>ArrayBuffer</computeroutput>,
        <computeroutput>ArrayBufferView</computeroutput> or
        <computeroutput>Blob</computeroutput> can be sent via
        <computeroutput>send()</computeroutput> method. See the examples
        below: <citation>ws-html5rocks</citation></para>

        <programlisting>// Sending String
connection.send('string message');

// Sending canvas ImageData as ArrayBuffer
var img = canvas_context.getImageData(0, 0, 400, 320);
var binary = new Uint8Array(img.data.length);
for (var i = 0; i &lt; img.data.length; i++) {
  binary[i] = img.data[i];
}
connection.send(binary.buffer);

// Sending file as Blob
var file = document.querySelector('input[type="file"]').files[0];
connection.send(file);</programlisting>

        <para>To sum it up, using WebSockets became a very simple and elegant
        way to provide real-time communication channel between web browser and
        WS server. The main drawback of WS is lack of support not only in the
        older versions of web browsers but also in the mobile platform
        browsers. Currently less than 60 % of users can make use of WebSocket
        full support. <citation>ws-caniuse</citation> Particularly, all
        versions of Internet Explorer below 10 (which means more than 98 % of
        IE users in November 2012) <citation>ie-statistics</citation> does not
        implement WebSockets JavaScript API. There are two favourable aspects
        in favour of WebSockets. Firstly, more and more web browsers add
        JavaScript API to support WebSockets. Secondly, the ratio of clients
        who use old version of the web browser without WS support tends to
        diminish. Anyway, if the real-time functionality constitutes the
        application core functionality, there is a strong need to offer
        fallback technology that every browser supports - usually represented
        by HTTP long polling or streaming mechanism, described in <xref
        linkend="chap-http-requests" />.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Existing RTC frameworks</title>

      <para>TODO</para>

      <para>Actually, there are other options such as using various browser
      plugins (e.g. Adobe Flash) to provide the base layer for TCP
      connections, but such tools has not been used within this thesis and are
      not further dealt with.</para>

      <para>Describe other approaches to RTC in WB than XMPP. Tell why we
      didn't use them (or that we used - OpenTok).</para>

      <para>Mention:</para>

      <para>Bayeux: http://svn.cometd.org/trunk/bayeux/bayeux.html</para>

      <para>OpenTok</para>

      <para>SignalR (.NET)</para>

      <para>WebRTC (http://www.webrtc.org/)</para>

      <para>Google hangouts API</para>
    </sect1>
  </chapter>

  <chapter id="chap-xmpp">
    <title>Extensible Messaging and Presence Protocol</title>

    <para>Extensible Messaging and Presence Protocol (XMPP) technologies were
    invented by Jeremie Miller in 1998.
    <citation>xmpp-the-definitive-guide</citation> It is one of the most
    widespread technologies for instant messaging (IM),<footnote>
        <para>Acutally, the IM client or even the techology itself is
        sometimes called <quote>Instant Messenger</quote>. This term is
        registered as a trademark by AOL company.
        <citation>aol-trademarks</citation></para>
      </footnote> i.e. exchanging the text or multimedia data between several
    endpoints. The <quote>native</quote> implementation of XMPP works right on
    top of TCP protocol: XMPP endpoint (called client as it represents the
    first actor in client-server architecture) opens long-lived TCP
    connection. Then, both the client and the server negotiate and open XML
    streams so there is one stream in each direction.
    <citation>xmpp-the-definitive-guide</citation> When the connection is
    established, both client and server can push any changes as XML elements
    to the stream and the other side obtains them immediately. Usual XMPP
    clients are standalone applications able to open TCP connection and listen
    to the stream opened by the server.</para>

    <para>XMPP stands for communication protocol handling not only sending and
    receiving the messages, but also presence notification, contact list
    (roster) management and others. The architecture is distributed and
    decentralized. There is no central or top level XMPP server. Anyone can
    run XMPP server, very similarly as HTTP or FTP server. Identification and
    recognition on the network is also similar - XMPP relies on Domain Name
    System (DNS) so that every server is identified via string domain name
    with arbitrary subdomain level (e.g. xmpp.example.com or just
    example.org). <citation>xmpp-the-definitive-guide</citation></para>

    <para>The user names have the same structure as e-mail addresses so the
    user name is followed by at sign and the server domain name. This rule
    also guarantees that every XMPP user is registered at the certain server.
    If there is any message or notification for the given user, her
    <quote>home</quote> server is looked up first, the message is transferred
    to that server first and then, the respective server (that the user
    belongs to) is responsible for delivering the message to the user or
    saving it until the user logs in. Therefore, two possible connection types
    take place in XMPP. Client-to-server communication is the first one, when
    the clients can talk only to their <quote>home</quote> server. Then,
    server-to-server communication is designed for delivering the messages to
    the users at different domains. When two servers are exchanging any data,
    direct connection to the target server is established. This approach is
    dissimilar to the way SMTP servers exchange e-mail messages. It helps to
    prevent address spoofing or spamming.
    <citation>xmpp-the-definitive-guide</citation></para>

    <para>XMPP has been chosen as the communication protocol for this thesis
    topic - Talker application. XMPP has been verified by big companies such
    as Google or Facebook. In addition, the openness of the protocol allows
    very easy connection to existing wide communication networks, using their
    server infrastructure, client software and existing user base.</para>

    <sect1>
      <title>XML Stanzas</title>

      <para>As mentioned in the introduction to this chapter, when XMPP
      connection is established, two streams are opened and both the client
      and the server can send any XML elements at any time. The meanings of
      various pieces of XML are described in this section.</para>

      <para>There are three three basic XML elements that every XMPP
      communication consists of. Those are
      <computeroutput>&lt;message/&gt;</computeroutput>,
      <computeroutput>&lt;presence/&gt;</computeroutput> and
      <computeroutput>&lt;iq/&gt;</computeroutput> (which stands for
      Info/Query), altogether called
      <computeroutput>Stanza</computeroutput><indexterm>
          <primary>stanza</primary>
        </indexterm>s. <citation>xmpp-the-definitive-guide</citation> Each
      stanza element usually contains several attributes which specify the
      exact meaning of it. The actual content is usually placed in the element
      body. Example message<indexterm>
          <primary>XMPP</primary>

          <secondary>message</secondary>
        </indexterm> stanza can look like this:</para>

      <programlisting>&lt;message from="pavel.smolka@celebrio.cz/talker"
         to="tomas.pitner@celebrio.cz"
         type="chat"&gt;
    &lt;body&gt;Hello, how are you?&lt;/body&gt;
&lt;/message&gt;</programlisting>

      <para>The attributes <computeroutput>from</computeroutput> and
      <computeroutput>to</computeroutput> stand for the sender and recipient
      of the message. Actually, the value the sender sets to the
      <computeroutput>from</computeroutput> attribute (or whether she entirely
      leaves it out) does not matter. The <quote>home</quote> XMPP server the
      sender is registered at (in this example, it would be the one running at
      <computeroutput>celebrio.cz</computeroutput>) has to set the from
      attribute according to the real user name and domain name. This is one
      of the interesting defensive mechanisms distinguishing XMPP from other
      communication protocols as SMTP.</para>

      <para>You might have noticed that <computeroutput>from</computeroutput>
      field does not contain only the XMPP address. There is a
      <emphasis>resource</emphasis><indexterm>
          <primary>XMPP</primary>

          <secondary>resource</secondary>
        </indexterm> identifier after the domain name. Since it is possible to
      connect multiple times with the same user name, the resource makes a
      difference between the sessions of the same user. In addition, it is
      useful information for other peers the user might communicate with. It
      is usual to set the resource field according to the place the user logs
      from or the device she uses.</para>

      <para>Message stanza receiving is not acknowledged so the sender has no
      information whether it has been delivered successfulIy or not. On the
      contrary, IQ stanza <indexterm>
          <primary>XMPP</primary>

          <secondary>IQ</secondary>
        </indexterm> can be used in case the sender requires the answer - it
      is usually a <emphasis>query</emphasis>. The best example is obtaining
      the contact list - in XMPP terms called
      <emphasis>Roster</emphasis><indexterm>
          <primary>XMPP</primary>

          <secondary>roster</secondary>
        </indexterm>:</para>

      <programlisting>&lt;iq id="123456789" type="get"&gt;
  &lt;query xmlns="<emphasis>jabber:iq:roster</emphasis>"/&gt;
&lt;/iq&gt;</programlisting>

      <para>Then, the server sends the result as another IQ stanza (notice
      that <computeroutput>id</computeroutput> attribute remains the same
      while the <computeroutput>type</computeroutput> attribute changed):
      <citation>xmpp-the-definitive-guide</citation></para>

      <programlisting>&lt;iq id="123456789" type="result"&gt;
  &lt;query xmlns="jabber:iq:roster"&gt;
    &lt;item jid="whiterabbit@wonderland.lit"/&gt;
    &lt;item jid="lory@wonderland.lit"/&gt;
    &lt;item jid="mouse@wonderland.lit"/&gt;
    &lt;item jid="sister@realworld.lit"/&gt;
  &lt;/query&gt;
&lt;/iq&gt;</programlisting>

      <sect2>
        <title>Subscription mechanism</title>

        <para>The third letter in the abbreviation XMPP stands for
        <emphasis>presence</emphasis><indexterm>
            <primary>XMPP</primary>

            <secondary>presence</secondary>
          </indexterm>, practically represented by sending
        <computeroutput>presence</computeroutput> stanzas. It is one of the
        important signs of real-time communication (not only in XMPP but
        overall) that the peers can see each other presence - whether the
        other side is online, alternatively whether it is available or busy.
        However this functionality is desired, it might slip to a huge privacy
        breach when anyone could see your presence status.</para>

        <para>XMPP solves the privacy problem with the subscription mechanism.
        Each user has full control over the peers who can monitor her online
        status. If anyone else wants to track the presence status, the
        subscription request must be sent. When received, the user decides
        whether the permission will be granted or not. Unfortunatelly, the
        subscription request can be blocked by the respective
        <quote>home</quote> XMPP server of the user we try to reach. To be
        tangible: there are two widely used XMPP providers -
        <computeroutput>jappix.com</computeroutput> and
        <computeroutput>gmail.com</computeroutput>. If the user of the former
        sends the subscription to another user registered at the latter, it is
        never delivered. It is one of the drawbacks of the opened protocol
        that one can never be sure that the other party co-operates.</para>
      </sect2>
    </sect1>

    <sect1 id="chap-bosh">
      <title>XMPP over BOSH</title>

      <para>Having described XMPP as communication protocol over TCP, it might
      be unclear how it is related to the thesis topic. XMPP is nice and
      mature technology and it would be nice to use it in web browser but it
      does not support communication over HTTP. Fortunately, XMPP offers many
      extensions (indeed, the first letter X stands for
      <quote>extensible</quote>) providing additional functionality. In fact,
      those are XMPP extension <emphasis>protocols</emphasis> and so they are
      called XEPs<indexterm>
          <primary>XEP</primary>
        </indexterm>.</para>

      <para>This section briefly describes one of XEP exensions called
      BOSH<indexterm>
          <primary>BOSH</primary>
        </indexterm> (XEP-0124) designed for transferring XMPP over
      HTTP.<footnote>
          <para>In fact, there are two more XEPs related to HTTP. First of
          them, XEP-0025: Jabber HTTP Polling, has been replaced by BOSH. It
          is obsolete and recommended not to be used any longer.
          <citation>xep-0025</citation> The other one is XEP-0206: XMPP Over
          BOSH. It is currently used standard but it constitutes just a
          supplement for BOSH. XEP-0206 describes mainly the session creation
          and authentication in BOSH. <citation>xep-0206</citation></para>
        </footnote> <citation>xep-0124</citation> The idea behind this
      extension is very simple: BOSH uses HTTP long polling technique
      (described in <xref linkend="chap-http-long-polling" />) to imitate
      bidirectional TCP communication necessary for XMPP. We can imagine BOSH
      (it is a protocol itself) as a middle layer protocol or wrapper protocol
      between HTTP (only capable of sending requests from client to server)
      and XMPP (understanding only the XML stanzas). BOSH requests and
      responses are subset of all conceivable HTTP requests or responses (they
      include all HTTP features such as HTTP method in request or status code
      in the response). The constraint defined by BOSH protocol restricts the
      body part to have a specific structure.</para>

      <para>Each BOSH request or response body is valid XML, which wraps up
      XMPP stanzas in special <computeroutput>&lt;body /&gt;</computeroutput>
      element. For the purposes of the protocol itself, it is also possible to
      send just the <computeroutput>body</computeroutput> element with no
      child (XMPP) nodes - for example when starting the session or reporting
      an error. So, the XMPP part of the communication is separated from BOSH
      quite well: the former is represented by payload elements inside the
      <computeroutput>body</computeroutput>, the latter consists of
      <computeroutput>body</computeroutput> attributes. Have a look at example
      of BOSH request: <citation>xep-0124</citation></para>

      <programlisting>POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 188

&lt;body rid='1249243562'
      sid='SomeSID'
      xmlns='http://jabber.org/protocol/httpbind'&gt;
  &lt;message to='contact@example.com'
           xmlns='jabber:client'&gt;
    &lt;body&gt;Good morning!&lt;/body&gt;
  &lt;/message&gt;
  &lt;message to='friend@example.com'
           xmlns='jabber:client'&gt;
    &lt;body&gt;Hey, what&amp;apos;s up?&lt;/body&gt;
  &lt;/message&gt;
&lt;/body&gt;</programlisting>

      <para>As you can see, the request header is ordinary HTTP header. So
      much for the HTTP part. The request body consists of
      <computeroutput>body</computeroutput> element which represents BOSH
      layer, along with the element attributes (plus namespace). Ultimately,
      the child nodes of the <computeroutput>body</computeroutput> represent
      two XMPP stanzas (both of message type). It is obvious that multiple
      XMPP stanzas can be transmitted via single BOSH request.</para>

      <para>BOSH protocol is an important part of the Talker application
      implemented as a programming part of the thesis. Despite it bears the
      disadvantages of HTTP bidirectional communication, as described before,
      it is the only reliable technology nowadays. There are several mature
      client-side libraries using BOSH (such as Strophe.js we used) and it is
      also easy to install, configure and run BOSH extension at the server
      side. HTTP server usually hands over the BOSH HTTP request to XMPP
      server with relevant module enabled, as described in
      <citation>setting-up-bosh</citation>. However, the server side XMPP is
      not the topic of this thesis so it is not further discussed.</para>
    </sect1>

    <sect1 id="chap-xmpp-ws">
      <title>XMPP over WebSockets</title>

      <para>Usually if the WebSockets are used, the XMPP server needs one
      extra layer, usually implemented as the server plugin, to be able to
      communicate directly with the web browser.</para>

      <para>http://blog.superfeedr.com/xmpp-over-websockets/</para>

      <para>luajit - lua jit compiler</para>

      <para>It was neccessary to install: apt balíky luajit +
      liblua5.1-bitop0</para>

      <para>TODO create diagram here (XMPP server - plugin - incoming
      connection vs xmpp server - standard connection).</para>
    </sect1>

    <sect1>
      <title>Jingle</title>

      <para>Jingle extension - multimedia.</para>

      <para>http://xmpp.org/extensions/xep-0166.html</para>
    </sect1>

    <sect1>
      <title>Pub-sub extensions</title>

      <para>Pub-sub extensions for inter-process communication.</para>

      <para>http://xmpp.org/extensions/xep-0060.html</para>
    </sect1>
  </chapter>

  <chapter id="chap-xmpp-in-javascript">
    <title>XMPP client in JavaScript</title>

    <para>Describe the tools that can be used to implement RTC in WB (and
    which were used to implement Celebrio Talker)</para>

    <para>Strophe (simple XMPP in Javascript)</para>

    <para>Strophe connecting/attaching - security issues. TODO
    programming</para>

    <para>Strophe plugins</para>

    <para>Possible server-side implementations (JAXL, XMPPHP, ...)</para>
  </chapter>

  <chapter id="chap-talker">
    <title>Talker</title>

    <para>Describe the Talker application in Celebrio.</para>

    <para>Mention what we expected from the app (value proposition)</para>

    <para>Then, application analysis, design and implmementation.</para>

    <para>Describe the architecture and used tools&amp;frameworks: JS +
    Ember.js, OpenTok, WebSockets in new OpenTok</para>

    <para>Don't forget to use UML: use case diagram, class diagram (if any),
    sequence/action diagram</para>

    <sect1>
      <title>Ember.js</title>

      <para>Describe Javascript client-side MVC frameworks overall, compare,
      tell why we used Ember</para>
    </sect1>

    <sect1>
      <title>Contact list</title>

      <para></para>
    </sect1>
  </chapter>

  <chapter id="chap-inter-process">
    <title>Inter-process Communication Framework</title>

    <para>Implement and describe framework for inter-process communication in
    Celebrio.</para>

    <para>First, the lightweight one (which we already have), then implement
    the "heavy" one, if there's enough time.</para>
  </chapter>

  <chapter>
    <title>Conclusion</title>

    <para>conclusion</para>

    <sect1>
      <title>Another part of the conclusion</title>

      <para>Another part of the conclusion... just to have subchapter
      here</para>
    </sect1>
  </chapter>

  <bibliography>
    <biblioentry>
      <abbrev>xmpp-the-definitive-guide</abbrev>

      <authorgroup>
        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Kevin</firstname>

          <surname>Smith</surname>
        </author>

        <author>
          <firstname>Remko</firstname>

          <surname>Tronçon</surname>
        </author>
      </authorgroup>

      <title>XMPP: The Definitive Guide</title>

      <subtitle>Building Real-Time Applications with Jabber
      Technologies</subtitle>

      <publisher>
        <publishername>Sebastopol: O'Reilly</publishername>
      </publisher>

      <pubdate>2009</pubdate>

      <isbn>978-0-596-52126-4</isbn>

      <pagenums>310 (7, 13, 14, 16, )</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>definitive-guide-to-ws</abbrev>

      <authorgroup>
        <author>
          <firstname>Vanessa</firstname>

          <surname>Wang</surname>
        </author>

        <author>
          <firstname>Frank</firstname>

          <surname>Salim</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Moskovits</surname>
        </author>
      </authorgroup>

      <title>The Definitive Guide to HTML5 WebSocket</title>

      <subtitle>Build real-time web applications with HTML5</subtitle>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2012</pubdate>

      <isbn>978-1430247401</isbn>

      <pagenums>210 (140, 156, )</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>definitive-guide-to-html5</abbrev>

      <authorgroup>
        <author>
          <firstname>Adam</firstname>

          <surname>Freeman</surname>
        </author>
      </authorgroup>

      <title>The Definitive Guide to HTML5 - TODO cite from page 873
      multimedia chapter</title>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2011</pubdate>

      <isbn>978-1-4302-3960-4</isbn>

      <pagenums>1080</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>js-definitive-guide</abbrev>

      <authorgroup>
        <author>
          <firstname>David</firstname>

          <surname>Flanagan</surname>
        </author>
      </authorgroup>

      <title>JavaScript: The Definitive Guide</title>

      <publisher>
        <publishername>O'Reilly Media</publishername>
      </publisher>

      <pubdate>2011</pubdate>

      <isbn>978-0-596-80552-4</isbn>

      <pagenums>1100 (333)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>async-javascript</abbrev>

      <authorgroup>
        <author>
          <firstname>Trevor</firstname>

          <surname>Burnham</surname>
        </author>
      </authorgroup>

      <title>Async JavaScript</title>

      <subtitle>Build More Responsive Apps with Less Code</subtitle>

      <publisher>
        <publishername>The Pragmatic Programmers</publishername>
      </publisher>

      <pubdate>2012</pubdate>

      <isbn>978-1-93778-527-7</isbn>

      <pagenums>104</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>realtime-web-apps</abbrev>

      <authorgroup>
        <author>
          <firstname>Jason</firstname>

          <surname>Lengstorf</surname>
        </author>

        <author>
          <firstname>Phil</firstname>

          <surname>Leggetter</surname>
        </author>
      </authorgroup>

      <title>Realtime Web Apps</title>

      <subtitle>HTML5 WebSocket, Pusher, And The Web's Next Big
      Thing</subtitle>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2013</pubdate>

      <isbn>978-1430246206</isbn>

      <pagenums>400</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>pro-html5-programming</abbrev>

      <authorgroup>
        <author>
          <firstname>Peter</firstname>

          <surname>Lubbers</surname>
        </author>

        <author>
          <firstname>Frank</firstname>

          <surname>Salim</surname>
        </author>

        <author>
          <firstname>Brian</firstname>

          <surname>Albers</surname>
        </author>
      </authorgroup>

      <title>Pro HTML5 Programming</title>

      <publisher>
        <publishername>Apress</publishername>
      </publisher>

      <pubdate>2011</pubdate>

      <isbn>978-1-4302-3864-5</isbn>

      <pagenums>352 (165, ...)</pagenums>
    </biblioentry>

    <biblioentry>
      <abbrev>internet-usage</abbrev>

      <author>
        <surname>Miniwatts Marketing Group</surname>
      </author>

      <title>Internet Users in the World - 2012 Q2</title>

      <publisher>
        <publishername>Internet World Stats</publishername>
      </publisher>

      <pubdate>2/17/2013 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.internetworldstats.com/stats.htm">http://www.internetworldstats.com/stats.htm</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>facebook-usage</abbrev>

      <author>
        <firstname>Drew</firstname>

        <surname>Olanoff</surname>
      </author>

      <title>Facebook Announces Monthly Active Users Were At 1.01 Billion As
      Of September 30th</title>

      <publisher>
        <publishername>TechCrunch</publishername>
      </publisher>

      <pubdate>10/23/2012 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://techcrunch.com/2012/10/23/facebook-announces-monthly-active-users-were-at-1-01-billion-as-of-september-30th/">http://techcrunch.com/2012/10/23/facebook-announces-monthly-active-users-were-at-1-01-billion-as-of-september-30th/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ria</abbrev>

      <author>
        <firstname>James</firstname>

        <surname>Ward</surname>
      </author>

      <title>What is a Rich Internet Application?</title>

      <pubdate>10/17/2007 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.jamesward.com/2007/10/17/what-is-a-rich-internet-application/">http://www.jamesward.com/2007/10/17/what-is-a-rich-internet-application/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>celebrio-system</abbrev>

      <authorgroup>
        <author>
          <firstname>Pavol</firstname>

          <surname>Donko</surname>
        </author>

        <author>
          <firstname>Petr</firstname>

          <surname>Kunc</surname>
        </author>

        <author>
          <firstname>Martin</firstname>

          <surname>Novák</surname>
        </author>

        <author>
          <firstname>Pavel</firstname>

          <surname>Smolka</surname>
        </author>

        <author>
          <firstname>Jan</firstname>

          <surname>Volmut</surname>
        </author>
      </authorgroup>

      <title>Celebrio System</title>

      <pubdate>2013 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.celebriosoftware.com/celebrio-system">http://www.celebriosoftware.com/celebrio-system</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>elderly-questionnaires</abbrev>

      <authorgroup>
        <author>
          <firstname>Pavel</firstname>

          <surname>Smolka</surname>
        </author>

        <author>
          <firstname>Martin</firstname>

          <surname>Novák</surname>
        </author>
      </authorgroup>

      <title>Elderly people and the computers</title>

      <pubdate>2/11/2013 [retrieved 2/19/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://infogr.am/Seniori-a-pocitace">http://infogr.am/Seniori-a-pocitace</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>aol-trademarks</abbrev>

      <authorgroup>
        <author>
          <surname>AOL Inc.</surname>
        </author>
      </authorgroup>

      <title>AOL Trademark List</title>

      <pubdate>3/15/2011 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://legal.aol.com/trademarks/">http://legal.aol.com/trademarks/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xmpp-history</abbrev>

      <authorgroup>
        <author>
          <surname>The XMPP Standards Foundation</surname>
        </author>
      </authorgroup>

      <title>History of XMPP</title>

      <pubdate>1/27/2010 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://legal.aol.com/trademarks/">http://xmpp.org/about-xmpp/history/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>gtalk</abbrev>

      <authorgroup>
        <author>
          <surname>Google Developers</surname>
        </author>
      </authorgroup>

      <title>Google Talk Developer Documentation</title>

      <pubdate>3/23/2012 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://developers.google.com/talk/talk_developers_home">https://developers.google.com/talk/talk_developers_home</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>fb-chat</abbrev>

      <authorgroup>
        <author>
          <surname>Facebook Developers</surname>
        </author>
      </authorgroup>

      <title>Facebook Chat API</title>

      <pubdate>2/12/2013 [retrieved 2/20/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://legal.aol.com/trademarks/">http://xmpp.org/about-xmpp/history/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>brian-stats-tweet</abbrev>

      <authorgroup>
        <author>
          <surname>Staatss, B. (Brianstaats)</surname>
        </author>
      </authorgroup>

      <title><quote>If you have to customize 1/5 of a reusable component, its
      likely better to write it from scratch @trek at
      #embercamp</quote></title>

      <pubdate>2/15/2013 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>Tweet</releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>fb-erlang</abbrev>

      <author>
        <firstname>Eugene</firstname>

        <surname>Letuchy</surname>
      </author>

      <title>Facebook Chat</title>

      <pubdate>5/14/2008 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://www.facebook.com/note.php?note_id=14218138919">https://www.facebook.com/note.php?note_id=14218138919</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>skype-license</abbrev>

      <author>
        <firstname>Allen</firstname>

        <surname>Smith</surname>
      </author>

      <title>Does SkypeKit work on Android?</title>

      <subtitle>Forum post</subtitle>

      <pubdate>8/7/2012 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://devforum.skype.com/t5/SkypeKit-FAQs/Does-SkypeKit-work-on-Android/m-p/16490/thread-id/78">http://devforum.skype.com/t5/SkypeKit-FAQs/Does-SkypeKit-work-on-Android/m-p/16490/thread-id/78</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>skype-uri</abbrev>

      <author>
        <surname>Microsoft</surname>
      </author>

      <title>Skype URIs</title>

      <pubdate>2013 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://dev.skype.com/skype-uri">http://dev.skype.com/skype-uri</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-http</abbrev>

      <authorgroup>
        <author>
          <firstname>Roy</firstname>

          <othername>Thomas</othername>

          <surname>Fielding</surname>
        </author>

        <author>
          <firstname>James</firstname>

          <surname>Gettis</surname>
        </author>

        <author>
          <firstname>Jeffrey</firstname>

          <surname>Mogul</surname>
        </author>

        <author>
          <firstname>Henrik</firstname>

          <surname>Frystyk</surname>
        </author>

        <author>
          <firstname>Larry</firstname>

          <surname>Masinter</surname>
        </author>

        <author>
          <firstname>Paul</firstname>

          <surname>Leach</surname>
        </author>

        <author>
          <firstname>Tim</firstname>

          <surname>Berners-Lee</surname>
        </author>
      </authorgroup>

      <title>Hypertext Transfer Protocol -- HTTP/1.1</title>

      <subtitle>Request for Comments: 2616</subtitle>

      <pubdate>6/1999 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http://www.w3.org/Protocols/rfc2616/rfc2616.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>apache-core-features</abbrev>

      <author>
        <surname>The Apache Software Foundation</surname>
      </author>

      <title>Apache Core Features</title>

      <pubdate>2013 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://httpd.apache.org/docs/2.2/mod/core.html">http://httpd.apache.org/docs/2.2/mod/core.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-bidirectional-http</abbrev>

      <authorgroup>
        <author>
          <firstname>Salvatore</firstname>

          <surname>Loreto</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Stefano</firstname>

          <surname>Salsano</surname>
        </author>

        <author>
          <firstname>Greg</firstname>

          <surname>Wilkins</surname>
        </author>
      </authorgroup>

      <title>Known Issues and Best Practices for the Use of Long Polling and
      Streaming in Bidirectional HTTP</title>

      <subtitle>Request for Comments: 6202</subtitle>

      <pubdate>4/2011 [retrieved 2/23/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.ietf.org/rfc/rfc6202.txt">http://www.ietf.org/rfc/rfc6202.txt</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>rfc-ws</abbrev>

      <authorgroup>
        <author>
          <firstname>Ian</firstname>

          <surname>Fette</surname>
        </author>

        <author>
          <firstname>Alexey</firstname>

          <surname>Melnikov</surname>
        </author>
      </authorgroup>

      <title>The WebSocket Protocol</title>

      <subtitle>Request for Comments: 6455</subtitle>

      <pubdate>12/2011 [retrieved 2/24/2013]</pubdate>

      <publisher>
        <publishername>Internet Engineering Task Force (IETF)</publishername>
      </publisher>

      <issn>2070-1721</issn>

      <releaseinfo>from <ulink
      url="http://tools.ietf.org/html/rfc6455">http://tools.ietf.org/html/rfc6455</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-proxy</abbrev>

      <author>
        <firstname>Peter</firstname>

        <surname>Lubbers</surname>
      </author>

      <title>How HTML5 Web Sockets Interact With Proxy Servers</title>

      <subtitle>Request for Comments: 6455</subtitle>

      <pubdate>3/16/2011 [retrieved 2/24/2013]</pubdate>

      <publisher>
        <publishername>InfoQ</publishername>
      </publisher>

      <issn>2070-1721</issn>

      <releaseinfo>from <ulink
      url="http://tools.ietf.org/html/rfc6455">http://tools.ietf.org/html/rfc6455</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-api</abbrev>

      <author>
        <firstname>Ian</firstname>

        <surname>Hickson</surname>
      </author>

      <title>The WebSocket API</title>

      <subtitle>Editor's Draft</subtitle>

      <pubdate>2/9/2013 [retrieved 2/24/2013]</pubdate>

      <publisher>
        <publishername>W3C</publishername>
      </publisher>

      <releaseinfo>from <ulink
      url="http://dev.w3.org/html5/websockets/">http://dev.w3.org/html5/websockets/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>mozilla-ws</abbrev>

      <author>
        <surname>Mozilla Developers</surname>
      </author>

      <title>WebSockets</title>

      <pubdate>2/4/2013 [retrieved 2/25/2013]</pubdate>

      <releaseinfo>from <ulink
      url="https://developer.mozilla.org/en-US/docs/WebSockets">https://developer.mozilla.org/en-US/docs/WebSockets</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-html5rocks</abbrev>

      <authorgroup>
        <author>
          <firstname>Malte</firstname>

          <surname>Ubl</surname>
        </author>

        <author>
          <firstname>Eiji</firstname>

          <surname>Kitamura</surname>
        </author>
      </authorgroup>

      <title>Introducing WebSockets: Bringing Sockets to the Web</title>

      <pubdate>2/13/2012 [retrieved 2/25/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.html5rocks.com/en/tutorials/websockets/basics/">http://www.html5rocks.com/en/tutorials/websockets/basics/</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-iana</abbrev>

      <author>
        <surname>IANA</surname>
      </author>

      <title>WebSocket Protocol Registries</title>

      <pubdate>11/13/2012 [retrieved 2/25/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.iana.org/assignments/websocket/websocket.xml">http://www.iana.org/assignments/websocket/websocket.xml</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ws-caniuse</abbrev>

      <author>
        <surname>StatCounter GlobalStats</surname>
      </author>

      <title>Can I use Web Sockets?</title>

      <pubdate>2/2013 [retrieved 3/3/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://caniuse.com/websockets">http://caniuse.com/websockets</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>ie-statistics</abbrev>

      <author>
        <surname>Terabyte Media</surname>
      </author>

      <title>Web Browser Usage Statistics</title>

      <pubdate>12/2012 [retrieved 3/3/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://www.statowl.com/web_browser_usage_by_version.php?limit%5B%5D=ie">http://www.statowl.com/web_browser_usage_by_version.php?limit%5B%5D=ie</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0124</abbrev>

      <authorgroup>
        <author>
          <firstname>Ian</firstname>

          <surname>Paterson</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>

        <author>
          <firstname>Dave</firstname>

          <surname>Smith</surname>
        </author>

        <author>
          <firstname>Jack</firstname>

          <surname>Moffit</surname>
        </author>
      </authorgroup>

      <title>XEP-0124: Bidirectional-streams Over Synchronous HTTP
      (BOSH)</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2010 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0124.html">http://xmpp.org/extensions/xep-0124.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0025</abbrev>

      <authorgroup>
        <author>
          <firstname>Joe</firstname>

          <surname>Hildebrand</surname>
        </author>

        <author>
          <firstname>Craig</firstname>

          <surname>Kaes</surname>
        </author>

        <author>
          <firstname>David</firstname>

          <surname>Waite</surname>
        </author>
      </authorgroup>

      <title>XEP-0025: Jabber HTTP Polling</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2009 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0025.html">http://xmpp.org/extensions/xep-0025.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>xep-0206</abbrev>

      <authorgroup>
        <author>
          <firstname>Ian</firstname>

          <surname>Paterson</surname>
        </author>

        <author>
          <firstname>Peter</firstname>

          <surname>Saint-Andre</surname>
        </author>
      </authorgroup>

      <title>XEP-0206: XMPP Over BOSH</title>

      <publisher>
        <publishername>XMPP Standards Foundation</publishername>
      </publisher>

      <pubdate>2010 [retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://xmpp.org/extensions/xep-0206.html">http://xmpp.org/extensions/xep-0206.html</ulink></releaseinfo>
    </biblioentry>

    <biblioentry>
      <abbrev>setting-up-bosh</abbrev>

      <author>
        <surname>Prosody</surname>
      </author>

      <title>Setting up a BOSH server </title>

      <pubdate>[retrieved 3/10/2013]</pubdate>

      <releaseinfo>from <ulink
      url="http://prosody.im/doc/setting_up_bosh">http://prosody.im/doc/setting_up_bosh</ulink></releaseinfo>
    </biblioentry>
  </bibliography>

  <index></index>

  <appendix id="my-appendix">
    <title>Screenshots of the application</title>

    <para>Some screenshots from Celebrio Talker</para>
  </appendix>
</book>
