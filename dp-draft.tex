\newif\ifdblatexpdf \ifx\pdfoutput\undefined \else \ifx\pdfoutput\relax \else\ifnum\pdfoutput>0 \dblatexpdftrue \fi \fi \fi
% ------------------------------------------------------------
% Autogenerated LaTeX file for books
% db2latex RELEASE: 0.8pre1
% db2latex VERSION: $Id: VERSION.xml,v 1.6 2004/01/31 12:47:11 j-devenish Exp $
% fithesis VERSION: 1.40
% ------------------------------------------------------------
\def\clsclass{rapport3}
\documentclass[draft]{fithesis}
% --------------------------------------------
% MetaFont and MetaPost logo support
% --------------------------------------------
\usepackage{mflogo}
% --------------------------------------------
% Load fithesis param 
% --------------------------------------------
\thesistitle{Real-time Communication \\* in Web Browser}
\thesissubtitle{Master's thesis}
\thesisstudent{Pavel Smolka}
\thesiswoman{false}
\thesislang{en}
\thesisyear{2013}
\thesisfaculty{fi}
\thesisadvisor{doc.
      RNDr. Tomá¹ Pitner, Ph.D.}
% --------------------------------------------
\label{idp229216}% --------------------------------------------
% Load graphicx package with pdf if needed 
% --------------------------------------------
\ifdblatexpdf
\usepackage[pdftex]{graphicx}
\pdfcompresslevel=9
\else
\usepackage{graphicx}
\fi
\usepackage{anysize}
\marginsize{3cm}{2.5cm}{3.5cm}{3.5cm}

\makeatletter
% redefine the listoffigures and listoftables so that the name of the chapter
% is printed whenever there are figures or tables from that chapter. encourage
% pagebreak prior to the name of the chapter (discourage orphans).
\let\save@@chapter\@chapter
\let\save@@l@figure\l@figure
\let\the@l@figure@leader\relax
\def\@chapter[#1]#2{\save@@chapter[{#1}]{#2}%
\addtocontents{lof}{\protect\def\the@l@figure@leader{\protect\pagebreak[0]\protect\contentsline{chapter}{\protect\numberline{\thechapter}#1}{}{\thepage}}}%
\addtocontents{lot}{\protect\def\the@l@figure@leader{\protect\pagebreak[0]\protect\contentsline{chapter}{\protect\numberline{\thechapter}#1}{}{\thepage}}}%
}
\renewcommand*\l@figure{\the@l@figure@leader\let\the@l@figure@leader\relax\save@@l@figure}
\let\l@table\l@figure
\makeatother
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
% Safeguard against long headers.
\IfFileExists{truncate.sty}{
\usepackage{truncate}
% Use an ellipsis when text would be larger than x% of the text width.
% Preserve left/right text alignment using \hfill (works for English).
\fancyhead[ol]{\truncate{0.49\textwidth}{\sl\leftmark}}
\fancyhead[er]{\truncate{0.49\textwidth}{\hfill\sl\rightmark}}
\fancyhead[el]{\truncate{0.49\textwidth}{\sl\leftmark}}
\fancyhead[or]{\truncate{0.49\textwidth}{\hfill\sl\rightmark}}
}{\typeout{WARNING: truncate.sty wasn't available and functionality was skipped.}}
\pagestyle{fancy}
% ---------------------- 
% Most Common Packages   
% ---------------------- 
\usepackage{latexsym}         
\usepackage{enumerate}         
\usepackage{fancybox}      
\usepackage{float}       
\usepackage{ragged2e}       
\usepackage{fancyvrb}         
\makeatletter\@namedef{FV@fontfamily@default}{\def\FV@FontScanPrep{}\def\FV@FontFamily{}}\makeatother
\fvset{obeytabs=true,tabsize=3}
\makeatletter
\let\dblatex@center\center\let\dblatex@endcenter\endcenter
\def\dblatex@nolistI{\leftmargin\leftmargini\topsep\z@ \parsep\parskip \itemsep\z@}
\def\center{\let\@listi\dblatex@nolistI\@listi\dblatex@center\let\@listi\@listI\@listi}
\def\endcenter{\dblatex@endcenter}
\makeatother
\usepackage{rotating}         
\usepackage{subfigure}         
\usepackage{tabularx}         
\usepackage{url}         
% --------------------------------------------
% Load hyperref package with pdf if needed 
% --------------------------------------------
\ifdblatexpdf
\usepackage[pdftex,bookmarksnumbered,colorlinks,backref,bookmarks,breaklinks,linktocpage,plainpages=false, pdfstartview=FitH, plainpages=false, pdfpagelabels, unicode]{hyperref}
\else
\usepackage[bookmarksnumbered,colorlinks,backref,bookmarks,breaklinks,linktocpage,plainpages=false, plainpages=false, pdfpagelabels]{hyperref}
\fi
% --------------------------------------------
% ----------------------------------------------
% Define a new LaTeX environment (adminipage)
% ----------------------------------------------
\newenvironment{admminipage}%
{ % this code corresponds to the \begin{adminipage} command
 \begin{Sbox}%
 \begin{minipage}%
} %done
{ % this code corresponds to the \end{adminipage} command
 \end{minipage}
 \end{Sbox}
 \fbox{\TheSbox}
} %done
% ----------------------------------------------
% Define a new LaTeX length (admlength)
% ----------------------------------------------
\newlength{\admlength}
% ----------------------------------------------
% Define a new LaTeX environment (admonition)
% With 2 parameters:
% #1 The file (e.g. note.pdf)
% #2 The caption
% ----------------------------------------------
\newenvironment{admonition}[2] 
{ % this code corresponds to the \begin{admonition} command
 \hspace{0mm}\newline\hspace*\fill\newline
 \noindent
 \setlength{\fboxsep}{5pt}
 \setlength{\admlength}{\linewidth}
 \addtolength{\admlength}{-10\fboxsep}
 \addtolength{\admlength}{-10\fboxrule}
 \admminipage{\admlength}
 {\bfseries \sc\large{#2}} \newline
 \\[1mm]
 \sffamily
 \includegraphics[width=1cm]{#1}
 \addtolength{\admlength}{-1cm}
 \addtolength{\admlength}{-20pt}
 \begin{minipage}[lt]{\admlength}
 \parskip=0.5\baselineskip \advance\parskip by 0pt plus 2pt
} %done
{ % this code corresponds to the \end{admonition} command
 \vspace{5mm} 
 \end{minipage}
 \endadmminipage
 \vspace{.5em}
 \par
}
% --------------------------------------------
% Commands to manage/style/create floats      
% figures, tables, algorithms, examples, eqn  
% --------------------------------------------
 \floatstyle{plain}
 \restylefloat{figure}
 \floatstyle{plain}
 \restylefloat{table}
 \floatstyle{plain}
 \newfloat{program}{ht}{lop}[section]
 \floatstyle{plain}
 \newfloat{example}{ht}{loe}[section]
 \floatname{example}{Example}
 \floatstyle{plain}
 \newfloat{dbequation}{ht}{loe}[section]
 \floatname{dbequation}{Equation}
 \floatstyle{boxed}
 \newfloat{algorithm}{ht}{loa}[section]
 \floatname{algorithm}{Algorithm}
\ifdblatexpdf
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\else
\DeclareGraphicsExtensions{.eps}
\fi
% --------------------------------------------
% $latex.caption.swapskip enabled for $formal.title.placement support
\newlength{\docbooktolatextempskip}
\newcommand{\captionswapskip}{\setlength{\docbooktolatextempskip}{\abovecaptionskip}\setlength{\abovecaptionskip}{\belowcaptionskip}\setlength{\belowcaptionskip}{\docbooktolatextempskip}}
% Guard against a problem with old package versions.
\makeatletter
\AtBeginDocument{
\DeclareRobustCommand\ref{\@refstar}
\DeclareRobustCommand\pageref{\@pagerefstar}
}
\makeatother
% --------------------------------------------
\makeatletter
\newcommand{\dbz}{\penalty \z@}
\newcommand{\docbooktolatexpipe}{\ensuremath{|}\dbz}
\newskip\docbooktolatexoldparskip
\newcommand{\docbooktolatexnoparskip}{\docbooktolatexoldparskip=\parskip\parskip=0pt plus 1pt}
\newcommand{\docbooktolatexrestoreparskip}{\parskip=\docbooktolatexoldparskip}
\def\cleardoublepage{\clearpage\if@twoside \ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage\if@twocolumn\hbox{}\newpage\fi\fi\fi}
\usepackage[latin2]{inputenc}
\usepackage[T1]{fontenc}

\ifx\dblatex@chaptersmark\@undefined\def\dblatex@chaptersmark#1{\markboth{\MakeUppercase{#1}}{}}\fi
\let\save@makeschapterhead\@makeschapterhead
\def\dblatex@makeschapterhead#1{\vspace*{-80pt}\save@makeschapterhead{#1}}
\def\@makeschapterhead#1{\dblatex@makeschapterhead{#1}\dblatex@chaptersmark{#1}}

\AtBeginDocument{\ifx\refname\@undefined\let\docbooktolatexbibname\bibname\def\docbooktolatexbibnamex{\bibname}\else\let\docbooktolatexbibname\refname\def\docbooktolatexbibnamex{\refname}\fi}
% Facilitate use of \cite with \label
\newcommand{\docbooktolatexbibaux}[2]{%
  \protected@write\@auxout{}{\string\global\string\@namedef{docbooktolatexcite@#1}{#2}}
}
% Provide support for bibliography `subsection' environments with titles
\newenvironment{docbooktolatexbibliography}[3]{
   \begingroup
   \let\save@@chapter\chapter
   \let\save@@section\section
   \let\save@@@mkboth\@mkboth
   \let\save@@bibname\bibname
   \let\save@@refname\refname
   \let\@mkboth\@gobbletwo
   \def\@tempa{#3}
   \def\@tempb{}
   \ifx\@tempa\@tempb
      \let\chapter\@gobbletwo
      \let\section\@gobbletwo
      \let\bibname\relax
   \else
      \let\chapter#2
      \let\section#2
      \let\bibname\@tempa
   \fi
   \let\refname\bibname
   \begin{thebibliography}{#1}
}{
   \end{thebibliography}
   \let\chapter\save@@chapter
   \let\section\save@@section
   \let\@mkboth\save@@@mkboth
   \let\bibname\save@@bibname
   \let\refname\save@@refname
   \endgroup
}

%\usepackage{cite}
%\renewcommand\citeleft{(}  % parentheses around list
%\renewcommand\citeright{)} % parentheses around list
\newcommand{\docbooktolatexcite}[2]{%
  \@ifundefined{docbooktolatexcite@#1}%
  {\cite{#1}}%
  {\def\@docbooktolatextemp{#2}\ifx\@docbooktolatextemp\@empty%
   \cite{\@nameuse{docbooktolatexcite@#1}}%
   \else\cite[#2]{\@nameuse{docbooktolatexcite@#1}}%
   \fi%
  }%
}
\newcommand{\docbooktolatexbackcite}[1]{%
  \ifx\Hy@backout\@undefined\else%
    \@ifundefined{docbooktolatexcite@#1}{%
      % emit warning?
    }{%
      \ifBR@verbose%
        \PackageInfo{backref}{back cite \string`#1\string' as \string`\@nameuse{docbooktolatexcite@#1}\string'}%
      \fi%
      \Hy@backout{\@nameuse{docbooktolatexcite@#1}}%
    }%
  \fi%
}

% --------------------------------------------
% A way to honour <footnoteref>s
% Blame j-devenish (at) users.sourceforge.net
% In any other LaTeX context, this would probably go into a style file.
\newcommand{\docbooktolatexusefootnoteref}[1]{\@ifundefined{@fn@label@#1}%
  {\hbox{\@textsuperscript{\normalfont ?}}%
    \@latex@warning{Footnote label `#1' was not defined}}%
  {\@nameuse{@fn@label@#1}}}
\newcommand{\docbooktolatexmakefootnoteref}[1]{%
  \protected@write\@auxout{}%
    {\global\string\@namedef{@fn@label@#1}{\@makefnmark}}%
  \@namedef{@fn@label@#1}{\hbox{\@textsuperscript{\normalfont ?}}}%
  }

\makeindex
% index labeling helper
\newif\ifdocbooktolatexprintindex\docbooktolatexprintindextrue
\let\dbtolatex@@theindex\theindex
\let\dbtolatex@@endtheindex\endtheindex
\@ifundefined{@openrighttrue}{\newif\if@openright}{}
\def\theindex{\relax}
\def\endtheindex{\relax}
\newenvironment{dbtolatexindex}[2]
   {
\if@openright\cleardoublepage\else\clearpage\fi
\let\dbtolatex@@indexname\indexname
\def\dbtolatex@current@indexname{#2}
\ifx\dbtolatex@current@indexname\@empty                                                                                             \def\dbtolatex@current@indexname{\dbtolatex@@indexname}
\fi
\def\dbtolatex@indexlabel{%
 \ifnum \c@secnumdepth >\m@ne \ifx\c@chapter\undefined\refstepcounter{section}\else\refstepcounter{chapter}\fi\fi%
 \label{#1}\hypertarget{#1}{\dbtolatex@current@indexname}%
 \global\docbooktolatexprintindexfalse}
\def\indexname{\ifdocbooktolatexprintindex\dbtolatex@indexlabel\else\dbtolatex@current@indexname\fi}
\dbtolatex@@theindex
   }
   {
\dbtolatex@@endtheindex\let\indexname\dbtolatex@@indexname
   }

\newlength\saveparskip \newlength\saveparindent
\newlength\tempparskip \newlength\tempparindent

\def\docbooktolatexgobble{\expandafter\@gobble}
% Prevent multiple openings of the same aux file
% (happens when backref is used with multiple bibliography environments)
\ifx\AfterBeginDocument\undefined\let\AfterBeginDocument\AtBeginDocument\fi
\AfterBeginDocument{
   \let\latex@@starttoc\@starttoc
   \def\@starttoc#1{%
      \@ifundefined{docbooktolatex@aux#1}{%
         \global\@namedef{docbooktolatex@aux#1}{}%
         \latex@@starttoc{#1}%
      }{}
   }
}
% --------------------------------------------
% Hacks for honouring row/entry/@align
% (\hspace not effective when in paragraph mode)
% Naming convention for these macros is:
% 'docbooktolatex' 'align' {alignment-type} {position-within-entry}
% where r = right, l = left, c = centre
\newcommand{\docbooktolatex@align}[2]{\protect\ifvmode#1\else\ifx\LT@@tabarray\@undefined#2\else#1\fi\fi}
\newcommand{\docbooktolatexalignll}{\docbooktolatex@align{\raggedright}{}}
\newcommand{\docbooktolatexalignlr}{\docbooktolatex@align{}{\hspace*\fill}}
\newcommand{\docbooktolatexaligncl}{\docbooktolatex@align{\centering}{\hfill}}
\newcommand{\docbooktolatexaligncr}{\docbooktolatex@align{}{\hspace*\fill}}
\newcommand{\docbooktolatexalignrl}{\protect\ifvmode\raggedleft\else\hfill\fi}
\newcommand{\docbooktolatexalignrr}{}
\ifx\captionswapskip\@undefined\newcommand{\captionswapskip}{}\fi
\makeatother
\title{\bfseries Real-time Communication \textbackslash \textbackslash * in Web Browser\\[12pt]\normalsize Master's thesis}
\author{Pavel Smolka}
% --------------------------------------------
\makeglossary
% --------------------------------------------

\setcounter{tocdepth}{4}

\setcounter{secnumdepth}{4}
\begin{document}
% --------------------------------------------
% Useing fithesis
% --------------------------------------------
\FrontMatter
\ThesisTitlePage
\begin{ThesisDeclaration}
\DeclarationText
\AdvisorName
\end{ThesisDeclaration}

% --------------------------------------------
% Thanks 
% --------------------------------------------
\begin{ThesisThanks}

Above all, I~would like to thank my colleagues from Celebrio, with whom I~have been working for a long time and who inspired me to create this thesis; especially Petr Kunc, always challenging my ideas but always being helpful. Of course, I~would also like to thank my advisor, doc. Tomá¹ Pitner, for not only providing me with valuable advice and help during the work on my thesis, but also for guiding me through the studies at the faculty.
 
I~am very thankful to my parents for bringing me up to this point in the best way parents can, and still splendidly supporting and encouraging me to do my best. Also, I~thank my nearest for having patience with me working and studying and hardly finding any time for them.
 
I~must not forget my Lasaris laboratory fellow students, revealing the world of web development to me. I~would also like to thank my English teacher, Petra Wachsmuthová, for helping me with the language part. And of course my classmates, colleagues and friends, not only for reviewing the text part of this thesis but also for discussing the technologies and the programming part as well.
 
After all, I~am grateful to the Internet community, StackOverflow members, various IRC attendants, people contributing and commenting at GitHub, Twitter and other media sources that helped me and inspired me all the time. Thank you, world!
\end{ThesisThanks}

% --------------------------------------------
% Abstract 
% --------------------------------------------
\begin{ThesisAbstract}

The thesis comprehends the topic of real-time communication in a web browser. Most of the available solutions for building real-time web applications are described and compared, with regards to security, browser support and usage difficulty. According to the theoretical results, a real-time application Talker is designed and developed, serving as text and video instant messaging client for Celebrio -- simple web-based application environment for the elderly. XMPP protocol, used in Talker in order to be interconnectible with other instant messaging clients, is also mentioned within the thesis, especially with regards to running the XMPP client in a web browser.
\end{ThesisAbstract}

% --------------------------------------------
% KeyWords 
% --------------------------------------------
\begin{ThesisKeyWords}
XMPP, real-time communication, RTC, Celebrio, web browser, HTTP, Comet, JavaScript, WebSockets, BOSH, Ember, Strophe, OpenTok, Talker, server push\end{ThesisKeyWords}

\makeatletter
\def\dbtolatex@contentsid{idp195360}
\def\dbtolatex@@contentsname{\latex@@contentsname}
\let\latex@@contentsname\contentsname
\newif\ifdocbooktolatexcontentsname\docbooktolatexcontentsnametrue
\def\dbtolatex@contentslabel{%
 \label{\dbtolatex@contentsid}\hypertarget{\dbtolatex@contentsid}{\dbtolatex@@contentsname}%
 \global\docbooktolatexcontentsnamefalse}
\def\contentsname{\ifdocbooktolatexcontentsname\dbtolatex@contentslabel\else\dbtolatex@@contentsname\fi}
\let\save@@@mkboth\@mkboth
\let\@mkboth\@gobbletwo
\tableofcontents
\let\@mkboth\save@@@mkboth
\let\contentsname\latex@@contentsname
\Hy@writebookmark{}{\dbtolatex@@contentsname}{\dbtolatex@contentsid}{0}{toc}%
\makeatother
				\MainMatter

% -------------------------------------------------------------
% Chapter Introduction 
% ------------------------------------------------------------- 	
\chapter{Introduction}
\label{uvod}\hypertarget{uvod}{}%

Millions, billions, trillions. So many and even more messages are exchanged every day between various people in the world. The Internet created a brand new way to communicate and collaborate, even if you are located on the opposite parts of the world. Since the times of Alexander Graham Bell, the accessibility to the communication devices and their simplicity have been incredibly enhanced. Nowadays, almost 2.5 billion people in the world have access to the Internet and, therefore, they are able to use almost limitless communication possibilities it provides. \docbooktolatexcite{internet-usage}{}

However, the manner of Internet usage essentially changed during the first decade of 21$^\textrm{\tiny st}$ century. Using the Internet and using the web browser became almost synonymous. People use the web browser as the primary platform to do every single task on the Internet. Sometimes it is not even possible to use the other Internet services without visiting certain web page in the web browser and performing the authentication there.\label{idp4484704}\begingroup\catcode`\#=12\footnote{
Two examples of such behavior. Wi-fi network in the Student Agency coaches forces the user to visit the entry page in the web browser. The second example, very well known to the students of the Faculty of Informatics at Masaryk University, is the faculty wireless network called wlan\_fi. Every user has to open the web browser and log in with her credentials. It is not possible just to open the terminal or e-mail client and start working online.
}\endgroup\docbooktolatexmakefootnoteref{idp4484704} Considering the mentioned fact, web browsers have become also the basic platform for the communication tools. Even though the purpose of the world wide web and HTTP protocol was completely different at first (displaying single documents connected via hypertext links), it appeared that there was a need for common rich applications running within a web browser -- a rich Internet application (RIA) sprang up. \docbooktolatexcite{ria}{} Such popular social networks are built on top of the web browser platform and they are used by more than a billion people in the world. \docbooktolatexcite{facebook-usage}{} And the main reason why the social networks are so popular is the real-time stream of news and messages from other people. At the beginning of 2013, I~would say that static web is dead -- users prefer interactivity.

As mentioned above, the web browser has become one of the most popular platforms. Celebrio, a simple software for the elderly, simulating the operating system interface, is a typical example of a rich Internet application.\label{idp3871856}\begingroup\catcode`\#=12\footnote{
{\textless}\url{http://www.celebriosoftware.com/celebrio-system}{\textgreater}
}\endgroup\docbooktolatexmakefootnoteref{idp3871856} All the topics mentioned in the previous paragraph appeared to be very important in the system. When interviewing the elderly people in the Czech Republic, it appeared that almost 90 \% of the elderly computer users use the real-time communication (RTC) applications, mostly Skype. \docbooktolatexcite{elderly-questionnaires}{} Interaction with their loved ones is the most desired benefit they expect from the computer. Therefore, creating a real-time application, a text messenger supporting video calling, has become not only a programming challenge but also a business goal.

With regard to the {``}real-time tendency{''}, this thesis embraces the topic of real-time applications in web browsers, especially the text communication tools and the technologies being used to develop them. Among the available solutions, XMPP protocol and OpenTok library (built on WebRTC) have been chosen and a real-time communication application has been designed and developed as a part of this thesis. Both text and multimedia streams are covered, as well as multimedia content transfer (audio and video).

Considering the fact that people prefer real-time communication (not only direct messaging but also real-time cooperation, simultaneous document editing or playing multiplayer games) while using a web browser brings us to the question what the currently available solutions are. There are {``}big players{''} providing their own services as closed-source, without the possibility to being used by third party developers. To name the most important ones, it is Google Talk web browser client and Facebook chat, using XMPP\index{XMPP} protocol. \docbooktolatexcite{gtalk}{}\docbooktolatexcite{fb-chat}{} Even though Facebook\index{Facebook} chat service is not a pure XMPP server implementation (the message and presence engine is a proprietary system of Facebook, implemented mostly in C++ and Erlang), they provide the possibility to connect to the {``}world of Facebook Chat{''} via XMPP as proxy. \docbooktolatexcite{fb-erlang}{} The combination of the facts that XMPP is an open technology with an open-sourced client and server implementations \docbooktolatexcite{xmpp-history}{} and the big Internet companies also use it persuaded us to use it in our communication application, too. XMPP itself and its usage in web applications is described in \hyperlink{chap-xmpp}{Chapter {\ref{chap-xmpp}}, {``}Extensible Messaging and Presence Protocol{''}}.

Nevertheless, there are also other RTC solutions not directly based in a web browser. Very popular communication platforms, XMPP (Jabber), ICQ or Windows Live Messenger have to be mentioned, all intended to run in dedicated client applications (Pidgin, ICQ, ...). All of them have been ported to a web browser in some way, in the form of applications such as Meebo (supporting ICQ and XMPP, however closed lately) or Google Talk (XMPP). There are also several voice over IP (VoIP) tools providing a video call platform, such as Skype\index{Skype}. To make this list comprehensive, Unix {``}talk{''} chat program for sending text messages has to be mentioned. However, it was superseded by previously mentioned modern systems.

Since the web browser was designed to perform simple request/response interaction, it is not a typical platform for building real-time applications. Thus, there is a need for an extra layer enhancing or even completely replacing the common way HTTP communicates. Within the scope of this thesis, primarily the WebSockets and HTTP long polling approaches are used. The two of them and basic information about several others are covered in \hyperlink{chap-rtc}{Chapter {\ref{chap-rtc}}, {``}Bidirectional communication between a web browser and a server{''}}.

There are many existing real-time chat-based applications on the Internet that could have been used. However, none of them suited our needs perfectly. Celebrio has a very specific graphical user interface (GUI) and there is a need to integrate both text-based chat and video calling. Just to mention, there is the commercial chat module Cometchat\label{idp2831776}\begingroup\catcode`\#=12\footnote{
http://www.cometchat.com/
}\endgroup\docbooktolatexmakefootnoteref{idp2831776} or even the open project Jappix.\label{idp205056}\begingroup\catcode`\#=12\footnote{
https://project.jappix.com/
}\endgroup\docbooktolatexmakefootnoteref{idp205056} Video calling web browser applications are provided for example by TokBox Inc.\label{idp226160}\begingroup\catcode`\#=12\footnote{
http://www.tokbox.com/
}\endgroup\docbooktolatexmakefootnoteref{idp226160} Nevertheless, following the rule that {``}If you have to customize 1/5 of a reusable component, its likely better to write it from scratch{''}, \docbooktolatexcite{brian-stats-tweet}{} just very generic existing libraries (Strophe.js) and APIs (OpenTok) were used for implementing a brand new application called {\em{Celebrio Talker}}. The general approaches when building web browser based chat application are mentioned in \hyperlink{chap-xmpp-in-javascript}{Chapter {\ref{chap-xmpp-in-javascript}}, {``}JavaScript XMPP client{''}}. Within the programming part of the thesis, the real-time text chat application and the video calling application for Celebrio have been implemented. Celebrio Talker application itself, its architecture and the specific procedures used to create it are described in \hyperlink{chap-talker}{Chapter {\ref{chap-talker}}, {``}Talker -- IM client in a web browser{''}}.

It has been said that Skype\index{Skype}\label{idp159168}\begingroup\catcode`\#=12\footnote{
http://www.skype.com/
}\endgroup\docbooktolatexmakefootnoteref{idp159168} is the most favorite communication tool among the target audience. If it were implemented, the existing customer base could be used and converted to our messaging application. However, there is one big pitfall in this approach. The Skype license strictly prohibits incorporating their software into mobile devices in third party applications. \docbooktolatexcite{skype-license}{} They support only prompting the official Skype client to be opened via Skype URI, which is insufficient for Celebrio since the messaging client has to be built in the system, with the corresponding user interface. \docbooktolatexcite{skype-uri}{}

% -------------------------------------------------------------
% Chapter Bidirectional communication between a web browser and a server 
% ------------------------------------------------------------- 	
\chapter{Bidirectional communication between a web browser and a server}
\label{chap-rtc}\hypertarget{chap-rtc}{}%

The very essence of every instant messaging is the bidirectional stream where both sides can immediately {\em{push}} new data and the other side (or more other sides) is promptly notified without the need to perform any manual {\em{pull}} (update) action\index{pull \& push communication}.\label{idp5459824}\begingroup\catcode`\#=12\footnote{
In this thesis, this behaviour is commonly referred as RTC. The {``}real-time part{''} relates mostly to the server part since the application running in the web browser can perform the AJAX request on background anytime and the server receives the request instantly.
}\endgroup\docbooktolatexmakefootnoteref{idp5459824} Such use case requires an appropriate transport layer on top of which the application can send messages via another protocol. When using HTTP, there is a TCP connection opened by the client (web browser) through which the data is sent. However, according to the HTTP protocol\index{HTTP}, the communication is strictly initiated by the client -- HTTP is a request/response protocol. \docbooktolatexcite{rfc-http}{} When the client continuously needs up-to-date information, it must poll the server as frequently as possible. Such approach takes a considerable amount of bandwidth and generates purposeless overhead on the server. So, when one wants to avoid those drawbacks and still make the web browser application communicate in both directions, HTTP protocol must be hacked somehow or another communication channel used. This chapter covers both -- reshaping HTTP in \hyperlink{chap-http-requests}{Section {\ref{chap-http-requests}}} and a brand new approach in \hyperlink{chap-ws}{Section {\ref{chap-ws}}}, bypassing HTTP completely. Unfortunately, every approach brings also some disadvantages. Ultimately, an overview of several higher-level solutions is to be found in \hyperlink{chap-high-level-rtc}{Section {\ref{chap-high-level-rtc}}}, most of which are based on HTTP requests or WebSockets.

% ------------------------   
% Section 
\section{Using HTTP requests}
\label{chap-http-requests}\hypertarget{chap-http-requests}{}%

Hypertext Transfer Protocol represents the most widely used protocol in web applications. It is a typical example of an application layer protocol (7th level), according to OSI Model\index{OSI Model} (ISO/IEC 7498-1). HTTP powers the Web. Along with other application layer protocols -- Simple Mail Transfer Protocol (SMTP)\index{SMTP}, File Transfer Protocol (FTP)\index{FTP} and DNS (domain name system) protocols -- HTTP constitutes the whole Internet as we know it. HTTP works as a {``}request-response{''} protocol, presuming an underlying transport layer protocol on top of which it works. The underlying transport protocol is almost always represented by Transmission Control Protocol (TCP)\index{TCP}, however, UDP can be used as well (for example in case of Simple Service Discovery Protocol (SSDP). \docbooktolatexcite{ssdp-udp}{} Nowadays, HTTP is not only used by web browser clients but also, thanks to its simplicity, by various mobile applications and Internet services, requesting new data or updating the information on a server.

HTTP is a very lightweight client-server protocol, where a client carries out a request and a server responds. The request specifies the action and a resource the action relates to, along with the protocol version. For example, the following request line represents a request fetching index.html file from the server:

\begin{Verbatim}[fontsize=\small]
GET /index.html HTTP/1.1
\end{Verbatim}

A~further request data is optional. After the initial line, custom request headers can be specified, along with an optional request body, which usually contains the request data. \docbooktolatexcite{rfc-http}{} For example, in case of POST request, updating the resource, the new resource data is contained in the request body.

HTTP response structure is similar to a request. The first initial line contains the response status code and a {``}reason phrase{''}, which identify how the request was handled. \docbooktolatexcite{rfc-http}{} Then, optional headers and message body can be listed. The following piece of code displays the response to the previous example request, resulted in success and transferring simple HTML code to the client:

\begin{Verbatim}[fontsize=\small]
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8

<html><body><p>
  This is the HTML content in response body, 
  separated by one blank line from the headers.
</p></body></html>
\end{Verbatim}

The very first approach to achieve RTC in a web browser, for a very long time the only one, is hacking HTTP. The idea is very simple. Generally, the client sends an extra request and it is not awaiting an immediate response. Instead, the server keeps the request for some time and sends the data as it comes in the response. There are several techniques to achieve such behaviour, in general called {\em{Comet}}\index{Comet}. Naive approach, consisting of ordinary HTTP requests, along with more advanced techniques of HTTP long polling and HTTP streaming are described in the following sections.
\subsection{Naive approach to real-time communication with HTTP}
\label{idp5479936}\hypertarget{idp5479936}{}%

It would be useful to keep an HTTP request opened for a bit longer time in order to perform real-time communication within an opened stream. When simple HTTP is used, however, each request corresponds to exactly one resource retrieved from a server. There is one common misunderstanding about long-lived HTTP requests. Since HTTP 1.1 (actually implemented even before, but not covered in the RFC specification), there is a possibility for the client to claim a persistent TCP\index{TCP} connection to the server, declaring {\texttt{{Connection: Keep-Alive}}} in the request header.\index{HTTP!Keep-Alive} Actually, all connections are considered persistent unless declared otherwise. \docbooktolatexcite{rfc-http}{} Even though the default timeout after which the server closes the connection lasts only several seconds, \docbooktolatexcite{apache-core-features}{} the persistent TCP connection is very useful for delivering various resources (style sheets, scripts, images, etc.) to the client without the unnecessary overhead of creating multiple streams. However, every single transmission within the TCP connection has to be in form of a separate HTTP request/response, always initiated by the client. On no account is the server allowed to push any data without a respective request from the client. Therefore, such TCP connection is of no use to RTC.

The situation is depicted in \hyperlink{fig-http-polling}{Figure {\ref{fig-http-polling}}} and \hyperlink{fig-http-polling-wrong}{Figure {\ref{fig-http-polling-wrong}}}. In the former case, a valid sequence of HTTP requests and responses is shown. Nevertheless, there is a delay between the moment the server gets (either generates or receives from a third party) the data (2) and the following request (3). Yet, it is possible to reduce the latency by shortening the polling time (the time between Response (1.1) and Request (3)), it is still a trade-off between the delay and overhead caused by frequent empty request/response pairs.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-http-polling}{}%
\begin{center}

{{\includegraphics[]{vp/http-polling}}\hypertarget{idp5498784}{}%
\label{idp5498784}
}
{{\caption[{Correct HTTP polling with delay}]{{{Correct HTTP polling with delay}}}\label{fig-http-polling}}}
\end{center}
\end{figure}

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-http-polling-wrong}{}%
\begin{center}

{{\includegraphics[]{vp/http-polling-wrong}}\hypertarget{idp5501296}{}%
\label{idp5501296}
}
{{\caption[{Forbidden HTTP response without respective request}]{{{Forbidden HTTP response without respective request}}}\label{fig-http-polling-wrong}}}
\end{center}
\end{figure}

On the other hand, \hyperlink{fig-http-polling-wrong}{Figure {\ref{fig-http-polling-wrong}}} depicts the forbidden situation of generating an HTTP response without a respective previous request. When the server gets the data (2), it is not allowed to initiate the connection and send an HTTP response without an appropriate preceding request (2.1). Even though the delay, mentioned in the previous paragraph, can be minimized in this situation, HTTP servers cannot use such a technique. To sum it up, a response (2.1) is forbidden by HTTP protocol and, therefore, this situation solution is not valid.
\subsection{HTTP long polling\index{HTTP!long polling}}
\label{chap-http-long-polling}\hypertarget{chap-http-long-polling}{}%

The essence of HTTP long polling springs from the idea of prolonging the time span between two poll requests. In traditional {``}short polling{''}, a client sends regular requests to the server and each request attempts to {``}pull{''} the available data. If no data is available, an empty response is sent. \docbooktolatexcite{rfc-bidirectional-http}{} That generates unnecessary overhead for both the client and the server.

On the contrary, long polling tries to reduce this load. After receiving the request, the server {\em{does not}} answer immediately and holds the connection opened. When the server receives (or even makes up by itself) new data, it carries out the response with the respective content, as depicted in \hyperlink{fig-http-long-polling}{Figure {\ref{fig-http-long-polling}}}.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-http-long-polling}{}%
\begin{center}

{{\includegraphics[]{vp/http-long-polling}}\hypertarget{idp5511168}{}%
\label{idp5511168}
}
{{\caption[{HTTP long polling}]{{{HTTP long polling}}}\label{fig-http-long-polling}}}
\end{center}
\end{figure}

As soon as the client obtains the response, it usually issues a new request immediately, so the process can repeat endlessly. If no data appears on the server for a certain amount of time, it usually responds with an empty data field just to renew the connection.

One of the main drawbacks of long polling is the header overhead. Every chunk of data in RTC applications is usually very short, for example a text message of minimal length. However, each update is served by a full HTTP request/response with the header easily reaching 800 characters. \docbooktolatexcite{pro-html5-programming}{} If the payload is a message 20 characters long, the header constitutes 4000\% overhead!\index{HTTP!header overhead} This drawback has an even bigger impact as the number of clients increases. \hyperlink{fig-http-overhead}{Figure {\ref{fig-http-overhead}}} shows the comparison of 1000 (A), 10000 (B) and 100000 (C) clients polling the server every second with the message 20 characters long, both using classic HTTP requests and WebSockets technology (mentioned in \hyperlink{chap-ws}{Section {\ref{chap-ws}}}). \docbooktolatexcite{pro-html5-programming}{} It is obvious that there is huge unnecessary network overhead when using HTTP polling instead of WebSockets.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-http-overhead}{}%
\begin{center}

{{\includegraphics[width=420pt]{img/http-overhead}}\hypertarget{idp5518848}{}%
\label{idp5518848}
}
{{\caption[{Comparison of network overhead (HTTP and WebSockets)}]{{{Comparison of network overhead (HTTP and WebSockets)}}}\label{fig-http-overhead}}}
\end{center}
\end{figure}

Furthermore, if the server has just received the data and sent the response to the client, there is a {``}blind window{''} when the server cannot notify the client. The whole push system is blocked until the response is received by the client, processed and a new request is delivered back to the server. Considering also the possible packet loss and required retransmission in the TCP protocol, the delay can be even longer than double bandwidth latency. \docbooktolatexcite{rfc-bidirectional-http}{}
\subsection{HTTP streaming\index{HTTP!streaming}}
\label{chap-http-streaming}\hypertarget{chap-http-streaming}{}%

HTTP streaming is a slightly different technique than long polling, although they are confused one with the other very often. What is mutual for both of the approaches is the client initializing the communication by an HTTP request. The server also sends the update as the part of the HTTP response. The main difference is that once the server initializes the response and sends the data, it does not terminate the response and keeps the HTTP connection opened. Meanwhile, the client listens to the response stream and reads the data pushed from the server. When any new data springs up on the server side, it is concatenated to the one existing response stream. \docbooktolatexcite{rfc-bidirectional-http}{} See the scheme in \hyperlink{fig-http-streaming}{Figure {\ref{fig-http-streaming}}}.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-http-streaming}{}%
\begin{center}

{{\includegraphics[]{vp/http-streaming}}\hypertarget{idp5527440}{}%
\label{idp5527440}
}
{{\caption[{HTTP streaming}]{{{HTTP streaming}}}\label{fig-http-streaming}}}
\end{center}
\end{figure}

It is very important not to confuse HTTP streaming with the {``}persistent{''} HTTP requests. As said at the beginning of this chapter, declaring {\texttt{{Connection: Keep-Alive}}} does not allow the server to issue multiple responses to a single request. Such behaviour would be serious violation of HTTP protocol. Instead, the server can declare {\texttt{{Transfer-Encoding: chunked}}}\index{HTTP!chunked response} status in the response header and send the response split into separate pieces, as shown below (chunk of zero length stands for the end of the response): \docbooktolatexcite{rfc-bidirectional-http}{}

\begin{Verbatim}[fontsize=\small]
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

0
\end{Verbatim}

The main drawback of HTTP streaming can be generally called buffering. There is no requirement for both the client and an intermediary (proxies, gateways, etc.) to handle the incoming data until the whole response is sent. Therefore, all parts of the response could be kept by the proxy and the messages (single HTTP response chunks) are not delivered to the client until the whole response is sent. Similarly, when the response consists of JavaScript statements, the browser does not have to execute them before the whole response is obtained (yet, most of the browsers execute it immediately). In such cases, HTTP streaming will not work. \docbooktolatexcite{rfc-bidirectional-http}{}

% ------------------------   
% Section 
\section{Permanent TCP streams with WebSockets\index{WebSockets}}
\label{chap-ws}\hypertarget{chap-ws}{}%

Although the World Wide Web with an HTTP request/response scheme has never been intended to serve as an RTC platform, the contemporary applications require such functionality and developers started to bend the protocol in an undesirable way. Most of the patterns described in \hyperlink{chap-http-streaming}{Section {\ref{chap-http-streaming}}} do their jobs and one can achieve sufficient two-way communication. Yet, there are certain performance issues and drawbacks which make them difficult to use. At least, those techniques carry HTTP header overhead which is unnecessary for standard bidirectional streams. Therefore, a brand new standard for creating full-duplex communication channels between a web browser and a server has been created. The technology is called {\em{WebSockets}}\index{WebSocket} (sometimes shortened as WS) and it stands for a communication protocol layered over the TCP along with a browser API for web developers. Anyway, not even WebSockets are allowed to access wider network -- their connection possibilities are limited only to the dedicated WS servers (usually HTTP servers with additional module for WS support attached). \docbooktolatexcite{js-definitive-guide}{}

Similarly as in HTTP, there is an unencrypted version of WebSockets working directly on top of TCP connection. The simplest way to recognize such a connection is WebSocket URI\index{WebSocket!URI}, beginning with {\texttt{{ws://}}}. It should not be used for two reasons. The first one, rather obvious, is security\index{security} -- the communication can be captured during the transmission. Transparent proxy servers are the second reason. If an unencrypted WebSocket connection is used, the browser is unaware of the transparent proxy and as a result, the WebSocket connection is most likely to fail. \docbooktolatexcite{ws-proxy}{}\docbooktolatexcite{definitive-guide-to-ws}{} As opposite, there is a secure way to use WebSockets. WebSockets Secure (WSS) protocol is standard WS wrapped in TLS tunnel, similarly as HTTP can be transmitted over TLS layer. When using WSS, the URI begins with {\texttt{{wss://}}} and it uses port 443 by default. \docbooktolatexcite{definitive-guide-to-ws}{}
\subsection{WebSocket handshake\index{WebSocket!handshake}}
\label{idp5546208}\hypertarget{idp5546208}{}%

WebSockets, as any other multilateral protocol, need to perform a handshake before an actual transmission can occur. During the handshake, a connection is established and both peers acknowledge the properties of the communication.

Since WebSockets emerged as an HTTP supplement, the handshake is initialized by an HTTP request\label{idp5549136}\begingroup\catcode`\#=12\footnote{
According to RFC6455, the protocol is designed to work over the HTTP port 80, as well as 443 to support HTTP proxies. However, the design is not limited to HTTP and the future implementations can use simpler handshake over a dedicated port. \docbooktolatexcite{rfc-ws}{}
}\endgroup\docbooktolatexmakefootnoteref{idp5549136} initialized by a client. The client sends the request as follows: \docbooktolatexcite{rfc-ws}{}

\begin{Verbatim}[fontsize=\small]
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: RWFzdGVyIGVnZyBmb3IgQWRh
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
\end{Verbatim}

Let us have a look at what each of the lines means. The first two lines are obvious, they represent a typical HTTP GET request. Specifying {\texttt{{Host}}} is important for the server to be able to handle multiple virtual hosts on a single IP address. The following two lines, {\texttt{{Upgrade: websocket}}} and {\texttt{{Connection: Upgrade}}}, are the most important. A~client informs a server about the desire to use WebSockets. The rest of the request stands for additional information for the server to be able to respond correctly. RFC 6455 describes the details. \docbooktolatexcite{rfc-ws}{}

The server should send an HTTP response looking similar to the following example: \docbooktolatexcite{rfc-ws}{}

\begin{Verbatim}[fontsize=\small]
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
\end{Verbatim}

The number 101 on the first line of the response stands for the HTTP status {\texttt{{Switching Protocols}}}, \docbooktolatexcite{rfc-http}{} which means the server supports WebSockets and the connection can be established. Any status code other than 101 indicates that the WebSocket handshake has not completed and the semantics of the HTTP still apply. \docbooktolatexcite{rfc-ws}{}

{\texttt{{Sec-WebSocket-Key}}} is a random secret issued by a client, base64-encoded and added to an initial protocol-switching request. A~server is supposed to concatenate the secret with Globally Unique Identifier (GUID)\index{GUID} "258EAFA5-E914-47DA- 95CA-C5AB0DC85B11" and to hash the result with SHA-1 algorithm. The result is returned as {\texttt{{Sec-WebSocket-Accept}}} header field, base64-encoded. \docbooktolatexcite{rfc-ws}{} However, a security issue here seems to be in this process. If the initial request is not sent over an encrypted HTTP connection (HTTPS), it can be caught by a third party. Since the server does not authenticate in any way and the algorithm does not contain any server secret, the third party attacker could fake the response and pretend to be the server.
\subsection{Frames and masking}
\label{idp5562272}\hypertarget{idp5562272}{}%

All the data sent via the WebSockets protocol is chunked into frames\index{frames}, working similarly to TCP frames. All transmission features are handled by the WebSocket API and the transmission is transparent for the application layer above (for example the JavaScript API) so that every message appears in the same state as it was sent. This means the message, a single portion of WS communication, can be fragmented during the transmission.

There are several special features concerning WS frames, one of the interesting ones is masking\index{masking}. The payload data of every frame sent from a client is XORed by a masking key of a 32-bit size. The purpose of masking is to prevent any third party from picking any part of the payload and reading it. The other goal might be distinguishing a server stream from a client stream instantly since client-to-server frames always {\em{must}} be masked and server-to-client frames {\em{must not}} be masked under any circumstances. In addition, WS peers have to use masking even if the communication is running on top of TLS layer so the {``}encryption{''} function is pointless. \docbooktolatexcite{rfc-ws}{} The security function of masking is also questionable because the masking key is included in a frame header. The only reason is preventing from random cross-protocol attacks. \docbooktolatexcite{pro-html5-programming}{}
\subsection{WS JavaScript API\index{WebSocket!API}}
\label{idp5569024}\hypertarget{idp5569024}{}%

Since the WebSocket technology is intended to be used particularly from browser applications, there is a need for an API web developers can use. The most widespread programming language of web browser client applications is JavaScript and so is the WebSocket API created for it. The API consists of one relatively simple JavaScript interface called {\texttt{{WebSocket}}},\label{idp5572208}\begingroup\catcode`\#=12\footnote{
In the older versions of some browsers, the interface was called differently due to the technology immaturity. For instance, Firefox from version 6 to 10 supports WebSockets only as {\texttt{{MozWebSocket}}}. An interesting fact is that Firefox 4 and 5 provides {\texttt{{WebSocket}}} interface as it is, just implementing a different WebSocket protocol version. Since Firefox 11.0, current (RFC 6455) WS protocol version is accessible via {\texttt{{WebSocket}}} interface. \docbooktolatexcite{mozilla-ws}{}
}\endgroup\docbooktolatexmakefootnoteref{idp5572208} \docbooktolatexcite{ws-api}{} placed as a property of {\texttt{{window}}} object.\label{idp5576656}\begingroup\catcode`\#=12\footnote{
Properties of {\texttt{{window}}} are accessible in JavaScript directly. Simple test {\texttt{{window.WebSocket === WebSocket}}} returning {\texttt{{true}}} proves it.
}\endgroup\docbooktolatexmakefootnoteref{idp5576656} It wraps the WebSocket client functionality performed by a user agent (i.e. a web browser). Using the API is very simple. The object, which handles all the WS functionality, is created by calling a {\texttt{{WebSocket}}} constructor: \docbooktolatexcite{ws-html5rocks}{}

\begin{Verbatim}[fontsize=\small]
var connection = new WebSocket(
        'ws://html5rocks.websocket.org/echo', 
        ['soap', 'xmpp']
);
\end{Verbatim}

The first (mandatory) argument stands for a WebSocket URI a client attempts to connect to. It can either begin with a {\texttt{{ws://}}} prefix or {\texttt{{wss://}}}, depending whether the TLS layer is to be used or not. The second parameter is optional -- specific WS subprotocols can be demanded there. Since there are only a few subprotocols recorded by IANA registry, it has been of little use so far. \docbooktolatexcite{ws-iana}{}

{\texttt{{WebSocket}}} interface provides at least four event handlers, to each of whom a custom callback can be attached. \docbooktolatexcite{ws-api}{} Those are {\texttt{{onopen}}}, {\texttt{{onmessage}}}, {\texttt{{onerror}}} and {\texttt{{onclose}}}. The names are rather self-explanatory, they serve as the event listeners watching for an incoming activity -- anytime the websocket obtains a message, its status changes or an error occurs, and the respective callback is fired. The callback registration can look as follows:

\begin{Verbatim}[fontsize=\small]
connection.onmessage = function (message) {
  console.log('We got a message: ' + message.data);
};
\end{Verbatim}

In addition, there is a property {\texttt{{readyState}}} (it would be {\texttt{{connection.readyState}}} in the previous example), keeping the current WebSocket status all the time. The status can be retrieved by testing the property against one of the {\texttt{{WebSocket}}} property constants {\texttt{{CONNECTING}}}, {\texttt{{OPEN}}}, {\texttt{{CLOSING}}} or {\texttt{{CLOSED}}}.

Sending the data to a server is also rather straightforward. Either {\texttt{{ArrayBufferView}}}, {\texttt{{DOMString}}}, {\texttt{{ArrayBuffer}}} or {\texttt{{Blob}}} can be sent via the {\texttt{{send}}} method. See the examples below: \docbooktolatexcite{ws-html5rocks}{}

\begin{Verbatim}[fontsize=\small]
// Sending a String
connection.send('string message');

// Sending the canvas ImageData as an ArrayBuffer
var img = canvas_context.getImageData(0, 0, 400, 320);
var binary = new Uint8Array(img.data.length);
for (var i = 0; i < img.data.length; i++) {
  binary[i] = img.data[i];
}
connection.send(binary.buffer);

// Sending a file as a Blob
var file = document.querySelector('input[type="file"]').files[0];
connection.send(file);
\end{Verbatim}

To sum it up, using WebSockets became a very simple and elegant way to provide a real-time communication channel between a web browser and a WS server. The main drawback of WS is lack of support not only in the older versions of web browsers but also in the mobile platform browsers. Currently, less than 60 \% of users can make use of the WebSocket full support. \docbooktolatexcite{ws-caniuse}{} Particularly, all versions of Internet Explorer below 10 (which means more than 98 \% of IE users in November 2012) \docbooktolatexcite{ie-statistics}{} do not implement the WebSockets JavaScript API. There are two favourable aspects in favour of WebSockets. Firstly, more and more web browsers add the JavaScript API to support WebSockets. Secondly, the ratio of clients who use an old version of a web browser without the WS support tends to diminish. Nevertheless, if the real-time functionality constitutes the application core functionality, there is a strong need for offering a fallback technology that every browser supports -- usually represented by the HTTP long polling or streaming mechanism, described in \hyperlink{chap-http-requests}{Section {\ref{chap-http-requests}}}.
\subsection{WebSocket API wrappers}
\label{idp5601536}\hypertarget{idp5601536}{}%

WebSockets is a powerful technology, yet there are many browsers which do not support it. In that case, when the real-time communication constitutes the core functionality, a fallback (i.e. an alternative technology used when the original is missing) must be defined to substitute the WebSockets. It might be Adobe Flash or the HTTP polling. It would be great not to have to define a fallback in every project again and again. Luckily, there are several API wrappers for this, doing this part of job for the developer automatically.

The basic use case is obvious. Using the wrapper instead of the WS API itself guarantees the developer that a fallback is used when the application runs in an environment without WebSockets. The whole process of choosing the transport technology is transparent and not necessary to be specified. As examples, however not used in Talker application, the projects Socket.IO\label{idp5603856}\begingroup\catcode`\#=12\footnote{
http://socket.io/
}\endgroup\docbooktolatexmakefootnoteref{idp5603856} and SockJS should be mentioned.\label{idp5604624}\begingroup\catcode`\#=12\footnote{
https://github.com/sockjs/sockjs-client
}\endgroup\docbooktolatexmakefootnoteref{idp5604624}

% ------------------------   
% Section 
\section{Server-sent events\index{Server-sent events}}
\label{idp5605648}\hypertarget{idp5605648}{}%

The Server-sent events (aka EventSource, from this point referred only as SSE) should in fact not be listed here but in the next section. It is a technology based on the HTTP streaming\index{HTTP!streaming}, described in \hyperlink{chap-http-streaming}{Section {\ref{chap-http-streaming}}} so it is not at the basic {``}zero{''} level. However, SSE are often compared to WebSockets so that the topic is introduced here. SSE have been standardized as part of the HTML5 standard. \docbooktolatexcite{sse-api}{} There is a very brief summary of an SSE API and its usage in this section.

As any other web technology, an SSE connection must be initialized by a client. There is a JavaScript API providing event handlers, very similar to the WS API. An event stream is opened with a constructor, pointing to a resource on a server:

\begin{Verbatim}[fontsize=\small]
var eventSource = new EventSource("sse-example.php");
\end{Verbatim}

A~script on the server, {\texttt{{sse-example.php}}} in our case, pushes the data to an opened HTTP response stream. What is important to get the SSE work, the {\texttt{{Content-Type}}} header must be set to the value {\texttt{{text/event-stream}}}. The data has to be organized in a form of {``}paragraphs{''}, separated by a blank line, where every paragraph stands for one message. Have a look at an example below:

\begin{Verbatim}[fontsize=\small]
data: This is one-line message

id: 123
event: myevent
data: Message of type "myevent" which consists of several lines
data: Another line of the event message
\end{Verbatim}

As shown above, every line in the message consists of a key and a value, separated by a colon, similar to the JSON format. When we need to transfer a multi-line message, we can repeat the key several times. \docbooktolatexcite{sse-multiline}{} Depending on the {\texttt{{event}}} entry ({\texttt{{myevent}}} in our example), the respective event handler is triggered in the JavaScript API. In this case, it would be the following event listener (if it has been attached in JavaScript before) logging the event to the console:

\begin{Verbatim}[fontsize=\small]
eventSource.addEventListener("myevent", function(e) {
    // process the event
    console.log(e);
}, false);
\end{Verbatim}

A~connection is closed either by a client by calling {\texttt{{close}}} method on the {\texttt{{EventSource}}} object or by a server (when all data is sent). However, if a server closes the connection, a client attempts to reconnect to the same resource. So, a server cannot close the connection permanently.

Server-sent events are often compared to WebSockets, though they are much less known. The support of both in the current web browsers is very similar. The only main difference is the lack of support of SSE in Internet Explorer 10, which finally provides the WebSocket API. Another difference is the fact that SSE, unlike WS, does not provide a real bidirectional stream. Only a server can publish new messages through an opened HTTP connection. A~client has to push the data to the server via another (standard) HTTP requests. Finally, there is rather a big limitation in the message format. While WebSockets provide a real TCP connection any data can be transferred through (including binary streams), SSE is restricted to the textual data in the form of key/value pairs. So, the only compelling reason to use SSE when WebSockets exist is the fact that WS communication is not so matured. There are proxies and NATs (network address translation points) which do not respect the long-lived nature of WebSockets and close them after relatively short period of time (1 minute for example). Therefore, it comes in handy to know about the SSE when working with real-time applications in a web browser.

% ------------------------   
% Section 
\section{Media streaming with a WebRTC technology\index{WebRTC}}
\label{idp5622912}\hypertarget{idp5622912}{}%

Up to here, none of the technologies mentioned was fully suited as a complete solution for a web-browser-based media communication, such as video calling. Although WebSockets are the most advanced approach, it is only a low level API providing a TCP stream. On that account, the web browser developers, with Chromium developers in the vanguard, invented a WebRTC technology. It is an API linking up a user media API (webcam, microphone) with the streaming API for sending the multimedia from a browser to the other communication node.\label{idp5625280}\begingroup\catcode`\#=12\footnote{
Apart from the video calling, the WebRTC provides an API for sending the files from one peer to another.
}\endgroup\docbooktolatexmakefootnoteref{idp5625280}

While WebSockets serve as an interconnection between a client (a web browser) and a dedicated server, which makes the technology suitable for the {``}server-based{''} protocols such as XMPP, WebRTC provides a real peer-to-peer connection\index{peer-to-peer connection}, directly between two web browsers. That makes WebRTC a perfect tool for implementing the direct media communication, such as the video calls.
\subsection{Signaling\index{WebRTC!Signaling}}
\label{idp5628400}\hypertarget{idp5628400}{}%

In fact, a server has to mediate the {``}meta data{''} in WebRTC, such as initializing a connection or negotiating the available media capabilities (such as codecs). This level of communication, exchanging the information about the connection itself, is called {\em{signaling}}\index{signaling}. WebRTC does not take care either about a layer the signaling data is transferred at, or the signaling protocol itself. It can be SIP, XMPP or any other, transferred via XMLHTTPRequest or WebSockets. What is important, signaling is not a part of a WebRTC API. The WebRTC connection itself then concerns only the peers, as shown in \hyperlink{fig-webrtc}{Figure {\ref{fig-webrtc}}}. \docbooktolatexcite{webrtc-signaling}{}

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-webrtc}{}%
\begin{center}

{{\includegraphics[width=420pt]{img/webrtc}}\hypertarget{idp5635104}{}%
\label{idp5635104}
}
{{\caption[{WebRTC communication schema}]{{{WebRTC communication schema}}}\label{fig-webrtc}}}
\end{center}
\end{figure}

\subsection{WebRTC API}
\label{idp5636608}\hypertarget{idp5636608}{}%

WebRTC provides a very high level API abstracting the media device access, a network connection and the process of encoding/decoding the media streams from a programmer. Unfortunately, the WebRTC API is still in the phase of a draft and it has not been standardized yet. \docbooktolatexcite{webrtc-rfc}{} It means that JavaScript objects are prefixed by vendor prefixes, so that there is {\texttt{{webkitRTCPeerConnection}}} instead of {\texttt{{RTCPeerConnection}}} in Chromium.

The core API object is a JavaScript object {\texttt{{RTCPeerConnection}}}. Creating one may look as follows (with a respective prefix):

\begin{Verbatim}[fontsize=\small]
var config =  {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]};
var pc = new RTCPeerConnection(config); // webkitRTCPeerConnection
\end{Verbatim}

Then, we can send all available ICE\index{ICE}\label{idp5642624}\begingroup\catcode`\#=12\footnote{
ICE stands for Interactive Connectivity Establishment
}\endgroup\docbooktolatexmakefootnoteref{idp5642624} candidates to the other peer, via a specified STUN\index{STUN} server. ICE candidate\index{ICE candidate} is basically a possible transport address for the media stream, later validated for the peer-to-peer connectivity. \docbooktolatexcite{ice}{} So, each possible connection address is sent via the previously created {\texttt{{pc}}} object. The process is still in the phase of negotiation, so the sending is up to a signaling service:

\begin{Verbatim}[fontsize=\small]
pc.onicecandidate = function (event) {
    // use existing signaling channel to send the candidate
    signalingChannel.send(JSON.stringify({ "candidate": event.candidate }));
};
\end{Verbatim}

In case the other side publishes its video stream, we set up a hook which handles it and shows it in a remote video element, stored in the {\texttt{{remoteView}}} JavaScript variable. \docbooktolatexcite{webrtc-rfc}{} In other words, the incoming URL is assigned to the {\texttt{{video}}} element as a source ({\texttt{{src}}}) attribute. The {\texttt{{src}}} attribute determines the media source bound to the element. \docbooktolatexcite{definitive-guide-to-html5}{}

\begin{Verbatim}[fontsize=\small]
pc.onaddstream = function (event) {
    remoteView.src = URL.createObjectURL(event.stream);
};
\end{Verbatim}

Sending a media stream from the local browser to the other peer is similar. First, we capture the audio and video stream from the local multimedia devices. The result, multimedia stream, is passed as an argument to the function which adds it to the {\texttt{{RTCPeerConnection}}} object {\texttt{{pc}}}. Besides, there is a common habit to add the video of self to the page as well. It is handled by the {\texttt{{selfView}}} variable, containing a reference to another video element on the page. The example below represents the described situation:

\begin{Verbatim}[fontsize=\small]
navigator.getUserMedia({"audio": true, "video": true}, function(stream) {
    selfView.src = URL.createObjectURL(stream);
    pc.addStream(stream);
});
\end{Verbatim}

Closing the connection is rather straightforward -- by invoking the {\texttt{{close}}} method on the {\texttt{{RTCPeerConnection}}} object, which has been instantiated before as {\texttt{{pc}}}.
\subsection{WebRTC in various environments}
\label{idp5658368}\hypertarget{idp5658368}{}%

WebRTC is truly a new technology, not yet adopted by many web browsers. And for those which support it, the implementation may differ since the standard has not been fully defined and finished yet. Chromium browser (i.e. Chrome and Chromium) developers were the first to add WebRTC API to their products -- in 2012. At the beginning of 2013, WebRTC API was added also to the newest Firefox builds so that Chrome and Firefox can {``}talk{''} to each other.\label{idp5660144}\begingroup\catcode`\#=12\footnote{
Note that in current Firefox version (22, nightly build by the time this thesis part is created), the user has to enable {\texttt{{media.peerconnection.enabled}}} field in {\texttt{{about:config}}} to get WebRTC run.
}\endgroup\docbooktolatexmakefootnoteref{idp5660144} \docbooktolatexcite{webrtc-interop}{} Opera browser also takes part in this initiative, yet no existing official claim of support has been released. All mentioned browsers used the same back-end implementation, hosted at {\textless}\url{http://www.webrtc.org}{\textgreater}. In theory, this back-end implementation (written in C++) can be built into any application to support WebRTC, not only a web browser.

For the web browsers which do not support WebRTC yet, several attempts have been made to add its functionality via browser plugins. It can be useful as a temporary improvement for the experienced users but one can never rely on the user having the plugin installed. The library providing WebRTC functionality for Safari, Opera, IE and older versions of Firefox is called webrtc4all. \docbooktolatexcite{webrtc4all}{} However, it is still a proprietary solution, adding another prefix ({\texttt{{w4a}}}) to the world of WebRTC JavaScript APIs.

There are also other parties which implement WebRTC in their own way, keeping to the API, more or less. One of such initiatives is Ericsson Browser (called just Browser), which claimed to be the first browser to implement WebRTC. Ericsson Browser uses a different back-end implementation but it tries to be in accordance with the official API. \docbooktolatexcite{webrtc-ericsson}{}

Microsoft came up with a different approach. Even though Internet Explorer does not support WebRTC, Microsoft invented their own API standard proposal. \docbooktolatexcite{webrtc-ms}{} It differs from the {``}official{''} API mainly in the extended possibilities to control more aspects of WebRTC communication, including low level {``}transport{''} layers. Since none of the standards has been finished yet, it is possible (and probable) that the final API definition will end up somewhere in between.

One of the logical reasons why Microsoft does want to intervene in the process of defining WebRTC API as much as possible is Skype\index{Skype}. Skype has been bought by Microsoft some time ago and, as everything nowadays, is planned to be available in the web browser. Microsoft seems to bet on WebRTC technology. \docbooktolatexcite{webrtc-skype}{} As a pleasant side-effect of Skype working on top of WebRTC, it would be finally possible to play along with Skype with other technologies. Of course, the technology barrier is the smaller one compared to licences and legal regulations, but it is another story.

% ------------------------   
% Section 
\section{Other RTC solutions}
\label{chap-high-level-rtc}\hypertarget{chap-high-level-rtc}{}%

Actually, there are several other, mostly higher-level solutions for achieving the bidirectional (and thus real-time) communication in a web browser. Some of them use the HTTP requests described above (such as Bayeux), some of them are based on WebSockets (OpenTok) or even WebRTC (OpenTok), and several of them are built completely independently, installed as web browser plugins and thus behaving as separate runtime platforms (Adobe Flash, Google Talk). And, to be precise, some of the frameworks are built on top of the others, for example OpenTok uses Adobe Flash in some cases. See the sections below to understand each of the technologies.
\subsection{Adobe Flash\index{Flash} and Microsoft Silverlight}
\label{idp5673952}\hypertarget{idp5673952}{}%

Among all, one of the most widespread technologies is Adobe Flash.\label{idp5675952}\begingroup\catcode`\#=12\footnote{
http://www.adobe.com/software/flash/about/
}\endgroup\docbooktolatexmakefootnoteref{idp5675952} Apart from the possibility to establish a bidirectional persistent TCP connection, Flash allows the developer to create almost any graphics, animations and user interface with nearly no limits.

Nevertheless, the disadvantages of Flash are significant. First, Flash is not a native part of any web browser. Until recently, it had to be installed manually as a plugin. Now, it is bundled and shipped with the Chromium-based browsers (Chrome, Chromium), but it is still an external plugin. \docbooktolatexcite{flash-bundled-with-chrome}{} Another drawback of Flash is the lack of support on mobile devices. Apple has been clear about it: iPhones and iPads have never supported Flash technology and it is not likely to change in the future. \docbooktolatexcite{iphone-flash-support}{} Android devices supported Flash at first, but later Adobe quit Google Play. \docbooktolatexcite{android-flash-support}{}

There are many other technologies similar to Adobe Flash, but they all suffer the same pain. Because they are installed as proprietary plugins, a developer can never be sure the application will run in any environment. This concerns the technologies as Microsoft Silverlight\index{Silverlight}\label{idp5680656}\begingroup\catcode`\#=12\footnote{
http://www.microsoft.com/silverlight/
}\endgroup\docbooktolatexmakefootnoteref{idp5680656} or Adobe AIR\index{AIR}\label{idp5682304}\begingroup\catcode`\#=12\footnote{
http://www.adobe.com/products/air.html
}\endgroup\docbooktolatexmakefootnoteref{idp5682304} (even though AIR has been intended to be browser-independent platform).

To sum it up, Adobe Flash is often used as a fallback for older browsers, running on non-mobile devices, which do not support WebRTC yet. It has been used as a fallback for the video calls in Talker application. However, creating a new application based on Flash (as a {\em{primary}} technology) in 2013 is not a good idea.
\subsection{OpenTok video call library}
\label{chap-opentok}\hypertarget{chap-opentok}{}%

OpenTok is a high-level video call platform for building real-time communication applications in a web browser. It allows the developer to easily set up a video call session, using an OpenTok server as a mediator. OpenTok is available as a free library for one-to-one calls. If more users were participating in one call, a payed subscription would have to be bought. \docbooktolatexcite{opentok-pricing}{}

From the technical point of view, there are two versions of the client-side OpenTok library. The first one is built on top of Adobe Flash, using it for establishing a connection with the OpenTok server and handling the media stream. The other one uses WebRTC (and it is therefore limited to the browsers which support it). Unfortunately, the two versions are not mutually compatible so it is impossible for one user to have a Flash version and for the other to use WebRTC when communicating together.

Each OpenTok session is identified by a session ID and every user who wants to join the session must hold a token generated for the session. Therefore, OpenTok contains a server-side library (SDK) for issuing and managing the session IDs and tokens, available for the most commonly used server-side languages. \docbooktolatexcite{opentok-server-side-lib}{}

OpenTok library is the tool that has been used for implementing video calls in the Talker application, hence the library API usage is described separately in \hyperlink{chap-video-calling}{Section {\ref{chap-video-calling}}}. The main advantage of OpenTok is a low entry barrier and a simple API that can be used out of the box. On the other hand, it is still a proprietary tool and every application built with OpenTok heavily relies on the third party service. Nevertheless, we have not experienced any serious problems during almost one year running OpenTok in Celebrio.
\subsection{Bayeux protocol\index{Bayeux}}
\label{idp5690048}\hypertarget{idp5690048}{}%

Bayeux is one of the higher level protocols designed specifically for the bidirectional communication between a web browser and a server, primarily intended to work on top of HTTP. The idea of communication is almost the same as in case of HTTP long polling. To transfer the messages from a server to a client, the server holds the request and responds only when there is an available message. Sending the data from a client to a server is straightforward, an ordinary HTTP request is sufficient.

Apart from HTTP requests, Bayeux defines the structure for the transmitted data, contained in the body of HTTP requests/responses. Each message has to be in form of JSON, containing structured data such as a channel name, a client ID and of course the transmitted data itself. \docbooktolatexcite{bayeux}{} Although Bayeux provides an interesting way to communicate, it has not been used in this thesis. The main reason for choosing XMPP is its better interoperability with other existing services and ability to easily communicate with the clients not running in a web browser.
\subsection{SignalR framework\index{SignalR}}
\label{idp5694384}\hypertarget{idp5694384}{}%

SignalR is a framework taking care of both a client (a web browser) and a server side of the application. SignalR is designed for the .NET platform on a server side, so the web application should be powered by the ASP.NET framework. SignalR abstracts the user from finding out which technology the web browser, in which an application runs, supports. Instead, SignalR provides an API for sending the messages and handling the incoming ones. Internally, it uses WebSockets for establishing the connection. When the WebSocket API is not available (for example in IE9, which is funny considering that SignalR is Microsoft-platform-based technology), it tries Server Sent Events and then falls back on the long polling technique. \docbooktolatexcite{signalr}{} To take it short, SignalR provides an envelope for the client-side WebSockets and HTTP long polling techniques, with ASP.NET API for handling the messages on a server.
\subsection{Real-time communication tools from Google\index{Google}}
\label{chap-google-tools}\hypertarget{chap-google-tools}{}%

There are three topics briefly mentioned in this section, all developed by Google -- Channel API, the Google Talk chat service and Google Hangouts API, all of which serve as RTC tools or even complete applications.

The first one, Google Channel API\index{Channel API}, is a tool for creating persistent connections between a browser-based client and a server. It simply wraps common Comet techniques (i.e. HTTP long polling or streaming) with convenient methods for binding the handlers to incoming events, usually messages. Nevertheless, the Channel API is part of Google App Engine and it is intended to be used only within the web applications built on it. Although it is possible to use only the client side of the Channel API in a custom web application, using only a half of the tool does not seem to be very helpful.

The other tool (more precisely standalone application) from Google is a chat service. It became natural part of Gmail, serving for quick and more informal messages than e-mail. It is a service built on XMPP protocol, not dissimilar to Talker application. Thanks to using XMPP, it is possible to connect with a Gmail account from various IM clients such as Pidgin or Miranda. Recently, Google added the support for video calls in a web browser -- originally powered by a browser plugin that had to be installed, now switching to WebRTC.

The last topic in this section is about Hangouts API. Hangouts is a platform for creating group video chat, running within a web application. Although Hangouts offer neat user experience, they can only be customised to a small extent. In other words, it is possible to add a Hangout to an arbitrary web application but its look and feel cannot be altered. This is an insurmountable problem for Celebrio Talker since it must strictly keep up with the user interface of Celebrio, the system it is built into.

Recently (on May 16, 2013), Google announced transforming {\em{Hangouts}}\index{Hangouts} to a complex real-time communication platform, incorporating the Google Talk service, previously mentioned {``}old{''} Hangouts and Google+ Messenger chat application. \docbooktolatexcite{new-hangouts}{} The new Hangouts platform is currently available either as a standalone Android/iOS application or an extension for Google Chrome, so it is not purely a technology of a web browser. On the other hand, the browser plugin allows the user to use new Hangouts at any web page, offering very simple user interface for both a text chat or a video call.

The new platform will preserve XMPP as an underlying protocol, so it will basically extend the Google Talk service. However, Google declared one important constraint. Their XMPP service will no longer support a server-to-server communication. \docbooktolatexcite{new-hangouts}{} More information about interoperability problems is to be found in \hyperlink{chap-interoperability-problems}{Section {\ref{chap-interoperability-problems}}}.

% -------------------------------------------------------------
% Chapter Extensible Messaging and Presence Protocol 
% ------------------------------------------------------------- 	
\chapter{Extensible Messaging and Presence Protocol}
\label{chap-xmpp}\hypertarget{chap-xmpp}{}%

Extensible Messaging and Presence Protocol (XMPP) technologies were invented by Jeremie Miller in 1998. \docbooktolatexcite{xmpp-the-definitive-guide}{} It is one of the most widespread technologies for instant messaging (IM),\label{idp5710960}\begingroup\catcode`\#=12\footnote{
Actually, the IM client or even the technology itself is sometimes called {``}Instant Messenger{''}. This term is registered as a trademark by AOL company. \docbooktolatexcite{aol-trademarks}{}
}\endgroup\docbooktolatexmakefootnoteref{idp5710960} i.e. exchanging the text or multimedia data between several endpoints. The {``}native{''} implementation of XMPP works right on top of the TCP protocol: XMPP endpoint (called client as it represents the first actor in the client-server architecture) opens a long-lived TCP connection. Then, both the client and the server negotiate and open XML streams, so there is one stream in each direction. \docbooktolatexcite{xmpp-the-definitive-guide}{} When the connection is established, both the client and the server can push any changes as XML elements to the stream and the other side obtains them immediately. The usual XMPP clients are standalone applications able to open a TCP connection and listen to the stream opened by the server.

XMPP stands for communication protocol handling not only sending and receiving the messages, but also presence notification, contact list (roster) management and others. The architecture is distributed and decentralized. There is no central or top level XMPP server. Anyone can run an XMPP server, very similarly as an HTTP or FTP server. Identification and recognition on the network is also similar -- XMPP relies on Domain Name System (DNS), so that every server is identified via string domain name with arbitrary subdomain level (e.g. xmpp.example.com or just example.org). \docbooktolatexcite{xmpp-the-definitive-guide}{}

The user name, called Jabber ID (or shortly as JID), has the same structure as an e-mail address so the user name is followed by {\texttt{{@}}} and the server domain name. This rule also guarantees that every XMPP user is registered on a certain server. If there is a message or notification for the particular user, her {``}home{''} server is looked up first, the message is transferred to that server and then, the respective server (that the user belongs to) is responsible for delivering the message to the user or saving it until she logs in. Therefore, two possible connection types take place in XMPP. Client-to-server communication is the first one, when the clients can talk only to their {``}home{''} server. Then, server-to-server communication is designed for delivering the messages to users at different domains. When two servers are exchanging any data, a direct connection to the target server has been established. This approach is dissimilar to the way SMTP servers exchange e-mail messages. It helps to prevent address spoofing or spamming. \docbooktolatexcite{xmpp-the-definitive-guide}{}

XMPP has been chosen as the communication protocol for this thesis topic -- Talker application. XMPP has been verified by big companies such as Google or Facebook. In addition, the openness of the protocol allows a very easy connection to existing wide communication networks, using their server infrastructure, client software and an existing user base.

% ------------------------   
% Section 
\section{XML Stanzas -- XMPP building blocks}
\label{chap-xmpp-stanzas}\hypertarget{chap-xmpp-stanzas}{}%

As mentioned in the introduction to this chapter, when an XMPP connection is established, two streams are opened and both the client and the server can send any XML elements at any time. The meanings of various pieces of XML are described in this section.

There are three basic XML elements that every XMPP communication consists of. Those are {\texttt{{\textless{}message/\textgreater{}}}}, {\texttt{{\textless{}presence/\textgreater{}}}} and {\texttt{{\textless{}iq/\textgreater{}}}} (which stands for an Info/Query), altogether called {\texttt{{Stanza}}}\index{stanza}s. \docbooktolatexcite{xmpp-the-definitive-guide}{} Each stanza element usually contains several attributes which specify the exact meaning of it. An actual content is usually placed in the element body. An example message\index{XMPP!message} stanza looks as follows:

\begin{Verbatim}[fontsize=\small]
<message from="pavel.smolka@celebrio.cz/talker"
         to="tomas.pitner@celebrio.cz"
         type="chat">
    <body>Hello, how are you?</body>
</message>
\end{Verbatim}

The attributes {\texttt{{from}}} and {\texttt{{to}}} identify a sender and a recipient of the message. Actually, the value set to the {\texttt{{from}}} attribute does not matter at all, it can even be left out. The {``}home{''} XMPP server the sender is registered at (it would be the one running at {\texttt{{celebrio.cz}}}, in the previous example) has to set the from attribute according to the real user name and the domain name. This is one of the interesting defensive mechanisms distinguishing XMPP from other communication protocols such as SMTP.

You might have noticed that the {\texttt{{from}}} field does not contain only an XMPP address. There is a {\em{resource}}\index{XMPP!resource} identifier following the domain name. Since it is possible to connect multiple times with the same user name, the resource makes a difference between the sessions of the same user. In addition, it is useful information for other peers the user might communicate with. It is usual to set the resource field according to a place the user logs from or a device she uses.

Receiving a message stanza is not acknowledged by the recipient so the sender has no information whether it has been delivered successfully or not. On the contrary, an IQ stanza can be used in case the sender requires an answer -- it usually constitutes a {\em{query}}. The best example is obtaining a contact list -- in XMPP terms called {\em{a roster}}\index{XMPP!roster}:

\begin{Verbatim}[fontsize=\small]
<iq id="123456789" type="get">
  <query xmlns="jabber:iq:roster"/>
</iq>
\end{Verbatim}

As an answer, a server sends the result as another IQ stanza (notice that the {\texttt{{id}}} attribute remains the same while the {\texttt{{type}}} attribute changed): \docbooktolatexcite{xmpp-the-definitive-guide}{}

\begin{Verbatim}[fontsize=\small]
<iq id="123456789" type="result">
  <query xmlns="jabber:iq:roster">
    <item jid="pavel@celebrio.cz"/>
    <item jid="tomas@celebrio.cz"/>
    <item jid="marek@celebrio.cz"/>
  </query>
</iq>
\end{Verbatim}
\subsection{Subscription mechanism}
\label{chap-xmpp-subscriptions}\hypertarget{chap-xmpp-subscriptions}{}%

The third letter of the abbreviation XMPP stands for the {\em{presence}}\index{XMPP!presence}, in practice represented by sending {\texttt{{presence}}} stanzas. It is one of the important signs of a real-time communication (not only in XMPP but overall) that the peers can see each other's presence -- whether the other side is online, alternatively whether it is available or busy. Even though such functionality is generally desired, it might slip to a huge privacy breach when anyone could see your presence status.

XMPP solves the potential privacy problem with a subscription\index{XMPP!subscriptions} mechanism. Each user has full control over the peers who can monitor her online status. If anyone else wants to track a presence status, a subscription request must be sent. When received, the user decides whether a permission will be granted or not. Unfortunately, the subscription request can be blocked by the respective {``}home{''} XMPP server of the user we try to reach. To be specific: there are two widely used XMPP providers -- {\texttt{{jappix.com}}} and {\texttt{{gmail.com}}}. If a user of the former sends a subscription to another user registered at the latter, it is not guaranteed it will be delivered (actually, it is not, see \hyperlink{chap-interoperability-problems}{Section {\ref{chap-interoperability-problems}}} for details). It is one of the drawbacks of an opened protocol that one can never be sure that the other party co-operates.

% ------------------------   
% Section 
\section{XMPP over BOSH}
\label{chap-bosh}\hypertarget{chap-bosh}{}%

Having described XMPP as a communication protocol over TCP, it might be unclear how it is related to the topic of this thesis. XMPP is a nice and mature technology and it would be nice to use it in a web browser, but it does not support communication over HTTP. Fortunately, XMPP offers many extensions (indeed, the first letter X stands for {``}extensible{''}) providing an additional functionality. In fact, we speak about XMPP {\em{Extension Protocols}} and thus they are called XEPs\index{XEP}.

This section briefly describes one of the XEP extensions called BOSH\index{BOSH} (XEP-0124), designed for transferring XMPP over HTTP.\label{idp5756144}\begingroup\catcode`\#=12\footnote{
In fact, there are two more XEPs related to HTTP. First of them, XEP-0025: Jabber HTTP Polling, has been replaced by BOSH. It is obsolete and recommended not to be used any longer. \docbooktolatexcite{xep-0025}{} The other one is XEP-0206: XMPP Over BOSH. It is currently used as a standard but it constitutes just a supplement for BOSH (XEP-0124). XEP-0206 describes mainly the session creation and an authentication process in BOSH. \docbooktolatexcite{xep-0206}{}
}\endgroup\docbooktolatexmakefootnoteref{idp5756144} \docbooktolatexcite{xep-0124}{} The idea behind this extension is very simple: BOSH uses an HTTP long polling technique (described in \hyperlink{chap-http-long-polling}{Section {\ref{chap-http-long-polling}}}) to imitate a bidirectional TCP communication necessary for XMPP. We can imagine BOSH (itself a protocol) as a middle layer protocol or a wrapper protocol between HTTP (only capable of sending requests from a client to a server) and XMPP (understanding only the XML stanzas). BOSH requests and responses are subset of all conceivable HTTP requests or responses (they include all HTTP features such as an HTTP method in a request or a status code in a response). The constraint defined by BOSH protocol restricts the body part to have a specific structure.

Each BOSH request or response body should be valid XML, which wraps up XMPP stanzas in a special {\texttt{{\textless{}body/\textgreater{}}}} element. For the purposes of the protocol itself, it is also possible to send just the {\texttt{{body}}} element with no child (XMPP) nodes -- for example when starting a session or reporting an error. So, the XMPP part of the communication is clearly separated from the BOSH part: the former is represented by payload elements inside the {\texttt{{body}}}, the latter consists of {\texttt{{body}}} attributes. Have a look at an example of a BOSH request: \docbooktolatexcite{xep-0124}{}
\begin{Verbatim}[fontsize=\small]
POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 188

<body rid='1249243562'
      sid='SomeSID'
      xmlns='http://jabber.org/protocol/httpbind'>
  <message to='tomp@example.com'
           xmlns='jabber:client'>
    <body>Good morning!</body>
  </message>
  <message to='pavel@example.com'
           xmlns='jabber:client'>
    <body>Hey, what&apos;s up?</body>
  </message>
</body>
\end{Verbatim}
 As you can see, the request header is an ordinary HTTP header. So much for the HTTP part. The request body consists of a {\texttt{{body}}} element, which represents a BOSH layer, along with the element attributes (plus the namespace). {\texttt{{sid}}} attribute represents a {\em{session}} ID, identifying the connection. It should not be mutated during one session. The other one, {\texttt{{rid}}}, stands for an ID of the {\em{request}} and it gets incremented with each request. Ultimately, the child nodes of the {\texttt{{body}}} element represent the XMPP stanzas, which would be two message stanzas in this case. It is obvious that multiple XMPP stanzas can be transmitted via a single BOSH request.

Those {\texttt{{sid}}} and {\texttt{{rid}}} properties are rather important in BOSH. The security is ensured just by that pair of strings in BOSH, because of the stateless nature of HTTP. If an attacker stole {\texttt{{sid}}} and {\texttt{{rid}}}, he could communicate with a server on behalf of the actual user. On the other hand, there is one big advantage. A~connection can be established and handed over from one point to another. For example, a web server can initiate a connection (carry out a handshake) and then only {\texttt{{sid}}} and {\texttt{{rid}}} are passed to a client (a web browser), which can continue communicating. This approach is used in the Talker application so the user credentials (JID and a password) are not sent to a browser at all.

BOSH protocol is an important part of the Talker application implemented as a programming part of this thesis. Despite bearing the disadvantages of an HTTP bidirectional communication, as described before, it is the only reliable technology nowadays. There are several mature client-side libraries using BOSH (such as Strophe.js we used) and it is also easy to install, configure and run a BOSH extension on the server side. An HTTP server usually hands over a BOSH HTTP request to an XMPP server with a relevant module enabled, as described in \docbooktolatexcite{setting-up-bosh}{} and depicted in \hyperlink{fig-xmpp-server-plugins}{Figure {\ref{fig-xmpp-server-plugins}}}. However, the server side XMPP is not the topic of this thesis so it is not further discussed.

% ------------------------   
% Section 
\section{XMPP over WebSockets}
\label{chap-xmpp-ws}\hypertarget{chap-xmpp-ws}{}%

Since there is a possibility to transmit arbitrary data from a web browser application to a server via WebSockets, it could be handy to transfer XMPP stanzas using WS as well. Using WebSockets saves a considerable amount of overhead and fixes several issues that can happen with BOSH (for example unreliability of HTTP). It generally works, yet the programmer should be wary of several pitfalls that WebSockets bring. First, a server side must accept a WebSockets connection. Usually, XMPP servers do provide such functionality through addons or modules.\label{idp5777600}\begingroup\catcode`\#=12\footnote{
Additional module for a Prosody server has been used as well when running the Talker application. The process of the installation includes downloading the module, adding it to the path that Prosody searches for modules. Then, it must be enabled in a configuration file. Moreover, {\texttt{{luajit}}} and {\texttt{{liblua5.1-bitop0}}} packages had to be downloaded for the module to work correctly (assuming Debian/Ubuntu on the server side).
}\endgroup\docbooktolatexmakefootnoteref{idp5777600} Provided that a WebSocket extension to the XMPP server is running on localhost, using WS to connect to the server is as simple as follows:

\begin{Verbatim}[fontsize=\small]
var ws = new WebSocket("ws://localhost:5280/xmpp-websocket/", "xmpp");
// XMPP handshake takes place here, omitting in the example
ws.send(
 "<message to='lasaris@example.com' xmlns='jabber:client'> \
    <body>Hello, lab!</body> \
  </message>"
);
\end{Verbatim}

Probably the most important difference compared to BOSH is that every WebSocket message (i.e. one chunk of incoming or outcoming communication -- can be compared to BOSH request) can contain only one XMPP stanza. \docbooktolatexcite{xmpp-over-websockets}{} It means that a client or a server cannot send more XMPP messages packed together, even if they are available by the time a WS message is sent.

The main drawback of using XMPP over WebSockets is still partial lack of support both in the web browsers (which includes WS support itself and the JavaScript XMPP libraries) and on the XMPP servers. Nevertheless, there is a huge trend of implementing it at all sides.\label{idp5783056}\begingroup\catcode`\#=12\footnote{
You might want to have a look at some of the current discussions concerning client-side (i.e. JavaScript) libraries:

{\textless}\url{https://github.com/metajack/strophejs/issues/68}{\textgreater}

{\textless}\url{https://github.com/metajack/strophejs/pull/95}{\textgreater}

{\textless}\url{http://stackoverflow.com/questions/1850162/}{\textgreater}
}\endgroup\docbooktolatexmakefootnoteref{idp5783056} Both BOSH and WS require additional plugins to be installed on a server since they are not part of XMPP. The plugins basically handle a connection (or a request, in case of BOSH) and hand over a pure XMPP message to the core XMPP server. In case of BOSH, the request can be sent to the plugin directly when the port is specified, or redirected by default HTTP server. The schema of transitions between the users at one side (using either WS, direct BOSH with specified plugin port or BOSH request to default HTTP port) and a server side is depicted in \hyperlink{fig-xmpp-server-plugins}{Figure {\ref{fig-xmpp-server-plugins}}}.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-xmpp-server-plugins}{}%
\begin{center}

{{\includegraphics[]{vp/bosh-ws-xmpp}}\hypertarget{idp5788864}{}%
\label{idp5788864}
}
{{\caption[{Communicating to XMPP server with WS and BOSH plugins}]{{{Communicating to XMPP server with WS and BOSH plugins}}}\label{fig-xmpp-server-plugins}}}
\end{center}
\end{figure}

% ------------------------   
% Section 
\section{Jingle -- XMPP media extension\index{XEP}}
\label{idp5790128}\hypertarget{idp5790128}{}%

Not only can XMPP send the text messages but it also supports transferring various multimedia streams. Audio and video above all, yet it is also possible to send raw binary files. All the functionality related to those {``}advanced{''} transfers is being managed by an XMPP protocol extension (XEP) called Jingle\index{Jingle}. According to the protocol extension, the two parties negotiate a data stream using the standard IQ stanzas (described in \hyperlink{chap-xmpp-stanzas}{Section {\ref{chap-xmpp-stanzas}}}). Then, a stream is established according to the prearranged entries. \docbooktolatexcite{xep-0166}{}

Although Jingle is relatively old and mature XMPP extension, it has not been used in the web browsers for a long time. Web browsers had not supported multimedia transfers due to the troublesome bidirectional communication and a difficult access to multimedia devices (a microphone and a webcam). Ergo, Jingle has not been used in the Talker application either -- the main reason for not using Jingle in the Talker application is the lack of JavaScript libraries supporting it. There is just an unofficial Strophe.js\index{Strophe.js} plugin for Jingle, published by Michael Weibel, not very well maintained and relying on the WebRTC technology\index{WebRTC}.\label{idp5797744}\begingroup\catcode`\#=12\footnote{
See {\textless}\url{http://candy-chat.github.com/candy-webrtc/}{\textgreater} and {\textless}\url{https://github.com/mweibel/strophejs-plugins/tree/jingle}{\textgreater} for the references.
}\endgroup\docbooktolatexmakefootnoteref{idp5797744} Therefore, Jingle is not described further in this thesis, it is mentioned here just as an option for the future.

Nevertheless, C/C++ Jingle libraries seem to be rather mature and ready to be used in the desktop client applications. Above all, there is a library developed by Google called libjingle\index{libjingle}, supporting multi-user audio/video/file transfers. \docbooktolatexcite{libjingle}{} Google seems to believe that Jingle is the right protocol for developing a multimedia client that can be used by everyone. They even sidelined the original Google Talk VOIP protocol and switched to Jingle as their {``}primary signalling protocol for voice calls{''}, in Gmail, iGoogle and Orkut. \docbooktolatexcite{jingle-is-the-future}{}

% ------------------------   
% Section 
\section{Interoperability problems}
\label{chap-interoperability-problems}\hypertarget{chap-interoperability-problems}{}%

Google Talk has been the biggest XMPP provider for a long time. Smaller XMPP networks, including Celebrio, took an advantage of the distributed environment and the interoperability within various XMPP domains. It seems, however, that Google starts to prevent the users registered at other servers from contacting Google users. More precisely, the subscription requests (described in \hyperlink{chap-xmpp-subscriptions}{Section {\ref{chap-xmpp-subscriptions}}}) from other domains are not delivered to Google users. \docbooktolatexcite{google-closing-xmpp}{} It is very unexpected and unpleasant for all involved -- smaller XMPP providers, their users and for the Google users, too. Google confirmed that throwing the subscription requests away is an attempt to reduce the amount of spam delivered to Google users. \docbooktolatexcite{spammy-invites}{}

If Google closes its network for the people from other domains, it will be the second huge social network, along with Facebook, which does provide XMPP to its users but does not allow them to fully collaborate with everyone else. Unlike Facebook\index{Facebook}, Google users can still send the subscription requests and therefore initiate the connection (in the long-term meaning), but this option can be disabled in the future, too.

Fortunately, severals weeks later, Google announced that the alleged spam problems are gone and the XMPP network is opened again. \docbooktolatexcite{spammy-invites-update}{} Hence, the users having their accounts registered at the external XMPP providers can send invites (subscription requests) to Google users without problems.

Yet another turn came just a few days before this thesis is submitted. Google announced the Hangouts\index{Hangouts} service to be transformed into a brand new product, as described in \hyperlink{chap-google-tools}{Section {\ref{chap-google-tools}}}. However, it will not be further possible to communicate to Google users from external XMPP services, similarly as in the time period described in the previous paragraphs. Thereby, it will not be possible (according to the latest Google statements) to interconnect a Hangouts account with other XMPP service providers, such as {\texttt{{jabber.org}}} or {\texttt{{jappix.com}}}. A~possibility to log in to a new Hangouts account from a custom XMPP client, i.e. the client-to-server communication, will be preserved. \docbooktolatexcite{new-hangouts}{} Google justifies this restriction by claiming that most of the messages coming to Google XMPP servers from external XMPP providers is spam. Unfortunately, no data nor statistics on this topic have been released so far.

% -------------------------------------------------------------
% Chapter JavaScript XMPP client 
% ------------------------------------------------------------- 	
\chapter{JavaScript XMPP client}
\label{chap-xmpp-in-javascript}\hypertarget{chap-xmpp-in-javascript}{}%

In this chapter, the two previous topics are connected together. The possibilities of a bidirectional communication, necessary for receiving messages in real-time, were mentioned in \hyperlink{chap-rtc}{Chapter {\ref{chap-rtc}}, {``}Bidirectional communication between a web browser and a server{''}}. In simple terms, such techniques (HTTP long polling, WebSockets, ...) stand for the {``}transport{''} layer of an application, handling a low-level connection and transferring the messages from a server to a client and vice versa. Above this layer, there is a {``}real communication protocol{''} definition, which would be the XMPP in our case. It does not make any sense to divide the protocols according to the OSI Model\index{OSI Model} (ISO/IEC 7498-1) since everything above HTTP (including HTTP itself) takes place at the 7$^\textrm{\tiny th}$ (application) layer. In \hyperlink{fig-isoosi}{Figure {\ref{fig-isoosi}}}, the communication between layers is depicted for the case of an application initializing a Jingle multimedia stream (XEP extension) over XMPP, using the BOSH mechanism for sending and receiving messages via HTTP. All the protocols have been described (or at least mentioned) previously. Although XMLHTTPRequest is an API rather than a protocol, its usage should be shown as well.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-isoosi}{}%
\begin{center}

{{\includegraphics[]{vp/isoosi}}\hypertarget{idp5821328}{}%
\label{idp5821328}
}
{{\caption[{Complexity of the communication protocols at application layer}]{{{Complexity of the communication protocols at application layer}}}\label{fig-isoosi}}}
\end{center}
\end{figure}

It is neither simple nor easy to take care of such a wide range of protocols in the application, handling the communication correctly at all levels. Fortunately, there are several existing libraries serving the lower level protocols. Specifically, most of them would conceal HTTP requests as well as BOSH and simplifying the XMPP layer.

One of the JavaScript libraries, used when implementing the Talker application, called {\em{Strophe.js}}, is described in this chapter.

There are also other libraries for creating an XMPP client in a web browser, for example JSJaC. However, JSJaC is not as popular (and thus verified) as Strophe.js and has not been used in Talker application. It is only mentioned as another option. It would be also possible to handle the whole XMPP/BOSH/HTTP stack manually and parse XML with some other tool.

Throughout this thesis, we assume the application runs in a web browser. After all, the thesis title has a {``}web browser{''} in it. Therefore, mostly JavaScript libraries and tools for building a client application within a web browser are mentioned in this chapter. Yet, it is certainly possible to implement an XMPP client on the server side or as an independent desktop application. At the end of this chapter, some server-side implementations are also mentioned due to the security reasons. See \hyperlink{chap-server-side-xmpp-client}{Section {\ref{chap-server-side-xmpp-client}}} for details.

% ------------------------   
% Section 
\section{Strophe.js -- JavaScript XMPP library\index{Strophe.js}}
\label{idp5826688}\hypertarget{idp5826688}{}%

Strophe.js\label{idp5828464}\begingroup\catcode`\#=12\footnote{
Strophe.js is sometimes referred only as {``}Strophe{''}. However, Strophe is, strictly speaking, a name of the collection of libraries, from which only one is Strophe.js, the JavaScript tool described in this chapter. Nevertheless, within this thesis, both {``}Strophe.js{''} and {``}Strophe{''} refer to the JavaScript part of the library.
}\endgroup\docbooktolatexmakefootnoteref{idp5828464} is a complex but simple to use JavaScript library for creating an XMPP client in a web browser application, initially created and further maintained by Jack Moffitt. Since XMPP is the protocol powering the Talker application, Strophe.js appeared to be a proper tool for creating it. In fact, Strophe handles the whole {``}transport{''} layer for the application, as it was described in the introduction to this chapter.

Strophe.js uses the BOSH protocol (based on HTTP long polling) for sending messages and receiving updates from a server. There is an unofficial project fork using WebSockets but it has not been accepted by the community yet. The main reason is probably the unfinished standard for handling XMPP stanzas in WebSocket stream, currently available as a draft. \docbooktolatexcite{xmpp-over-websockets}{}

In the following sections, the essential topics concerning Strophe.js are mentioned. It mostly comprises Strophe.js basic usage and philosophy, including using plugins for getting additional functionality beyond the library itself.
\subsection{New connection}
\label{idp5833328}\hypertarget{idp5833328}{}%

Since an XMPP client is intended to communicate with various nodes in the Internet, a connection represents the essence of an application. Strophe connects to a BOSH server through which it communicates with the rest of the XMPP world. Its URL is stated as BOSH\_SERVICE variable in the following example. Setting up the connection is simple:

\begin{Verbatim}[fontsize=\small]
var BOSH_SERVICE = 'https://bind.jappix.com/',
    jid  = 'pavel@example.com',
    pass = 'mysecretpassword',
    onConnect = function(status) { /* implementation */ };
var connection = new Strophe.Connection(BOSH_SERVICE);
connection.connect(jid, pass, onConnect);
\end{Verbatim}

Apart from the BOSH service URL, a Jabber ID and a password are passed to the connection method.

The last argument stands for a callback function which is triggered every time the connection status changes. The status is then passed as an argument to the callback function. It must value to one of the {\texttt{{Strophe.Status}}} enum values. For example, when a connection is established, it would be {\texttt{{Strophe.Status.CONNECTED}}}. An example {\texttt{{onConnect}}} callback can look as follows:

\begin{Verbatim}[fontsize=\small]
onConnect = function(status) {
  if (status === Strophe.Status.CONNECTED) {
    connected();
  } else {
    console.log('Connecting status: ' + status);
  }
};
\end{Verbatim}

When the connection is established, a {\texttt{{connected}}} function is invoked. Usually, this is the place the event handlers are attached to the connection object, which is passed as {\texttt{{this}}} parameter in the context of the {\texttt{{onConnect}}} function. Event handlers are described in \hyperlink{chap-strophe-events}{Section {\ref{chap-strophe-events}}}.
\subsection{Attaching to an existing connection}
\label{strophe-attach}\hypertarget{strophe-attach}{}%

There is one problem with the process mentioned above. Generally, passing confidential data to JavaScript hard-coded in the rendered HTML files (i.e. within {\texttt{{\textless{}script/\textgreater{}}}} tag) constitutes a security issue\index{security}. As you may have noticed, the previous example incorporates a password in the JavaScript snippet, which is exactly this kind of problem. Firstly, the page can be stored in plain text as a browser cache. Secondly, the web page is available for anyone within the browser history tool so the password can be easily tracked down. Last but not least, unless TLS is used, the web page with the password traverses the Internet unencrypted. \docbooktolatexcite{attached-to-strophe}{}

Luckily, Strophe.js comes with a possibility to attach to an existing connection. It basically means that the initial BOSH handshake takes place on a server side. A~connection is established and a server-side based XMPP client comes up with a session identifier and a current request number (SID and RID, mentioned in \hyperlink{chap-bosh}{Section {\ref{chap-bosh}}}).\index{SID}\index{RID} Afterwards, RID and SID are sent to the client (either within the initial HTML template or as a separate JSON response). RID and SID are sufficient to identify the BOSH client. However, unlike password, in case of being disclosed to the attacker, only a single session is compromised. \docbooktolatexcite{xmpp-in-javascript}{}

Attaching to an existing connection in a JavaScript application using Strophe.js is rather simple, similar to initializing a new connection: \docbooktolatexcite{xmpp-in-javascript}{} 
\begin{Verbatim}[fontsize=\small]
var connection = new Strophe.Connection(BOSH_SERVICE);
connection.attach(jid, sid, rid, onConnect);
\end{Verbatim}

\subsection{Event handling}
\label{chap-strophe-events}\hypertarget{chap-strophe-events}{}%

Both JavaScript and XMPP are typical fields of using asynchronous processing of incoming events. The idea is simple. Generally, we specify the actions we are interested in and attach the event handlers to each of them. An event handler, a function or a method, is invoked as soon as the specified action occurs. The event handlers, deferred functions, are called callbacks\index{callback}. Not only Strophe but all other asynchronous libraries (event-based or request/response) in JavaScript are based on callbacks, for example popular jQuery AJAX functions.\label{idp5854672}\begingroup\catcode`\#=12\footnote{
http://api.jquery.com/jQuery.ajax/
}\endgroup\docbooktolatexmakefootnoteref{idp5854672}\label{idp5855312}\begingroup\catcode`\#=12\footnote{
Nowadays, the callback approach is getting replaced by {``}promises{''}, wrapping asynchronous operations to later resolved objects. Promises are said to be similar to functional {``}monad{''} structures, known from Haskell.
}\endgroup\docbooktolatexmakefootnoteref{idp5855312}

When the idea of a callback is clear, applying them to Strophe.js event handling is simple, as depicted in the example below. The first parameter is the callback itself (its name or an anonymous function implemented on site). The {``}areas of concern{''} are specified as the remaining five parameters. The example callback here is triggered every time a chat message comes, i.e. a {\texttt{{message}}} stanza with an attribute {\texttt{{type='chat'}}}. The parameters specified as {\texttt{{null}}} mean that any value of that place is processed by the handler. Therefore, the message sender, which can be specified by the next-to-last argument, can be anyone:

\begin{Verbatim}[fontsize=\small]
connection.addHandler(onChatMessage, null, 'message', 'chat', null, null);
\end{Verbatim}

A~callback function receives an incoming stanza object in a Strophe-specific pre-parsed format. Then, the object can be queried (with jQuery or plain JavaScript selectors), such as in the example below:

\begin{Verbatim}[fontsize=\small]
onChatMessage = function(msg) {
  var messageBody = msg.getElementsByTagName('body');
  console.log("Message text: " + messageBody);
  return true;
}
\end{Verbatim}

The last line in the function is a common pattern in Strophe.js the developer must be aware of. Each handler must return {\texttt{{true}}} (or any other value which evaluates to {\texttt{{true}}}) to stay bound to the event. If {\texttt{{false}}} is returned, the handler is unattached and it is not triggered any more. \docbooktolatexcite{xmpp-in-javascript}{} Therefore, {\texttt{{false}}} return values are proper for disposable callbacks, used only once.
\subsection{Stanza builders}
\label{idp5866256}\hypertarget{idp5866256}{}%

The whole XMPP protocol is represented by XML elements called stanzas, transferred between a client and a server. There are various approaches to create an XML document structure in JavaScript. Using jQuery is the most common way to do so. The jQuery object, created by jQuery {\texttt{{\$}}} function, represents an XML structure tree which can be extended using methods like {\texttt{{append}}}, {\texttt{{wrap}}} and {\texttt{{after}}}. \docbooktolatexcite{jquery-api}{}

Strophe.js comes up with a completely independent XML creator, however inspired by jQuery. \docbooktolatexcite{xmpp-in-javascript}{} The functionality is to be found within the {\texttt{{Strophe.Builder}}} object. It allows a library user to create XML elements such as follows: \docbooktolatexcite{strophe-api}{}
\begin{Verbatim}[fontsize=\small]
$iq({to: 'tomas', from: 'pavel', type: 'get', id: '1'})
    .c('query', {xmlns: 'strophe:example'})
    .c('example')
    .toString()
\end{Verbatim}
The previous example code creates an IQ stanza and the following snippet represents a respective result:
\begin{Verbatim}[fontsize=\small]
<iq to='tomas' from='pavel' type='get' id='1'>
  <query xmlns='strophe:example'>
    <example/>
  </query>
</iq>
\end{Verbatim}
Bijection between the two pieces of code is rather obvious. The only catch could be not yet defined {\texttt{{\$iq}}} function. Similarly as jQuery, Strophe.js provides shorthand functions {\texttt{{\$msg}}}, {\texttt{{\$pres}}}, and {\texttt{{\$iq}}} for creating all three kinds of stanzas, along with a {\texttt{{\$build}}} function for making any kind of element. Therefore, creating a presence stanza and sending it using Strophe.js is as simple as follows:

\begin{Verbatim}[fontsize=\small]
this.send($pres().tree());
\end{Verbatim}
\subsection{Logger}
\label{idp5878528}\hypertarget{idp5878528}{}%

Strophe.js does not conceal any information about its operation. It contains several logger methods, divided by a log level, mostly used by the library itself (it however can be used by the user code as well). Logging functionality is inserted in the main Strophe object itself. Calling the logger from the library methods is thus simple, however it can hardly be replaced by another logger (all at once), defined by the user. All logger methods point to the ultimate {\texttt{{log}}} method, which just returns by default. The intention of the library authors is providing this method to be overridden by a custom user code. So is done in the Talker application, as described in \hyperlink{chap-talker}{Chapter {\ref{chap-talker}}, {``}Talker -- IM client in a web browser{''}}.

% ------------------------   
% Section 
\section{Strophe plugins}
\label{chap-strophe-plugins}\hypertarget{chap-strophe-plugins}{}%

XMPP has been designed to be extensible (even by the protocol name) by various XEP extensions. Strophe.js follows the same direction and provides a simple way for the plugins to be added. And fortunately, there is not just the possibility to create a plugin on one's own, there are plenty of existing extensions available publicly at GitHub. In this section, a general way to use the plugins is described as well as a brief overview of several plugins used in the Talker application.

Each Strophe plugin is contained in a separate JavaScript file, included to the application which uses it. A~common name convention for a plugin file is {\texttt{{strophe.myplugin.js}}}, where {\texttt{{myplugin}}} is replaced by the actual plugin name. \docbooktolatexcite{xmpp-in-javascript}{} Whole plugin functionality is packed to a JavaScript object and passed to Strophe as follows:

\begin{Verbatim}[fontsize=\small]
Strophe.addConnectionPlugin('myplugin',
{
  // plugin methods and properties

  init: function(connection) {
    // init body
  },

  exampleMethod: function() { /* ... */ }
});
\end{Verbatim}

Among all plugin object properties and methods, the {\texttt{{init}}} function is explicitly quoted. That is because the {\texttt{{init}}} method is run as a plugin setup automatically by Strophe, after a new connection object has been created. The new connection object is passed to the method as the only parameter. The plugin can save the connection object for later use. \docbooktolatexcite{xmpp-in-javascript}{} When the plugin is initialized, any method (such as {\texttt{{exampleMethod}}} from the example above) can be invoked using the plugin name property of the connection object, as follows:

\begin{Verbatim}[fontsize=\small]
connection.myplugin.exampleMethod();
\end{Verbatim}

In the Talker application, several Strophe plugins are used. Particularly, the application uses plugin called Roster, which provides an easy handling of the user contact list (XMPP Roster).\index{XMPP!roster} The basic use cases comprise retrieving a roster from a server by calling {\texttt{{connection.roster.get(onRoster)}}}, usually as soon as the Strophe connection is established. The parameter represents a callback function invoked when the server responds and the contact list is fetched. Of course, the contact list is no static structure and it gets changed as the contacts log in and out. All incoming changes are captured by the plugin and processed by the handler method, if it has been set up. For example, the following line of code sets up a {\texttt{{presenceListener}}} function as a callback which is triggered any time the contact list is changed. The structure of method parameters is exactly the same as in case of ordinary Strophe handlers.

\begin{Verbatim}[fontsize=\small]
connection.roster.registerCallback(presenceListener, 
        null, 'presence', null, null,  null);
\end{Verbatim}

% ------------------------   
% Section 
\section{Server-side implementations}
\label{chap-server-side-xmpp-client}\hypertarget{chap-server-side-xmpp-client}{}%

The connection attachment, as described in \hyperlink{strophe-attach}{Section {\ref{strophe-attach}}}, is used in the Talker application. Apart from the security advantages and the possibility of boosting performance by pre-creating the connections, there are also some drawbacks in this approach. The most important one is a need of an XMPP client (or at least a connection manager) implemented in the server-side language, or alternatively running Strophe itself in the server-side JavaScript environment.

There are several available solutions. For example, a Python XMPP connection manager called Punjab\label{idp5898608}\begingroup\catcode`\#=12\footnote{
https://github.com/twonds/punjab
}\endgroup\docbooktolatexmakefootnoteref{idp5898608} is well-suited for {``}pre-creating{''} BOSH connections. Speaking of PHP (as it is the language Celebrio is powered by), there is JAXL\label{idp5899888}\begingroup\catcode`\#=12\footnote{
https://github.com/abhinavsingh/JAXL
}\endgroup\docbooktolatexmakefootnoteref{idp5899888} library which has been used in this project. However, it is not very steady tool. I~have found two bugs in this library, not mentioning its poor documentation. One minor bug fix has already been accepted by the library author to the official branch,\label{idp5900944}\begingroup\catcode`\#=12\footnote{
https://github.com/abhinavsingh/JAXL/pull/30
}\endgroup\docbooktolatexmakefootnoteref{idp5900944} the other one is still being opened by the time of finishing this thesis.\label{idp5901808}\begingroup\catcode`\#=12\footnote{
https://github.com/abhinavsingh/JAXL/issues/32
}\endgroup\docbooktolatexmakefootnoteref{idp5901808}Although the latter might not be a real issue, it still prevents from a successful BOSH connection establishment.

% -------------------------------------------------------------
% Chapter Talker -- IM client in a web browser 
% ------------------------------------------------------------- 	
\chapter{Talker -- IM client in a web browser}
\label{chap-talker}\hypertarget{chap-talker}{}%

As people use computers and the Internet increasingly more often, they do not avoid interaction with others. On the contrary, communication and sharing represents an essential part of current web systems. The social networks mostly provide a way to communicate with other people and they are used by millions. The same rules are valid for Celebrio, a smart and simple application imitating the interface of an operating system. Therefore, Talker application has been designed and implemented to serve in Celebrio as a real-time communicator or an instant messenger client.

In this chapter, Talker application is described in depth. There are requirements listed, both functional and non-functional. Further on, the used technologies are mentioned and compared to possible substitutions. Some of the technologies are described in individual dedicated chapters, such as Strophe.js in \hyperlink{chap-xmpp-in-javascript}{Chapter {\ref{chap-xmpp-in-javascript}}, {``}JavaScript XMPP client{''}} so that only the parts specific to Talker are mentioned here. Ultimately, several sections are dedicated to the implementation and testing. Source codes of the application are packed as the thesis supplement. However, they are unlikely to run without Celebrio for which the application was built.

% ------------------------   
% Section 
\section{Analysis}
\label{idp5906528}\hypertarget{idp5906528}{}%

Firstly, this section describes the application analysis, i.e. what the requirements are. It includes both the non-functional requirements (such as the platform the application must run on or the system it has to cooperate with) and the probable usage by customers. When the requirements are clear, it must be decided how to implement the desired functionality. That is where the design takes place. The application design springs from the analysis, further decomposes it and clarifies the way it will be implemented. The design part is crucial because the sooner possible glitches are unveiled and fixed the lower the cost is. The last thing which has to be considered and decided is the {``}stack{''} of proper technologies to be used, with regard to the both non-functional requirements and the design complexity.
\subsection{Value proposition}
\label{idp5908848}\hypertarget{idp5908848}{}%

The first step when creating a successful application (or even a whole ecosystem of applications such as Celebrio) should start by considering the added customer (or more precisely user) value. The value proposition mainly contemplates the possible market, the users and the benefits they would have from using our application, i.e. Talker. \docbooktolatexcite{value-proposition}{} Our target market is well-defined and rather easy to interview: the elderly people. More than a half of the elderly use (or are willing to use) a real-time communication tool, comprising both text chat and video calls. They prefer it to be interoperable so they can speak to the people not using directly the same software tool as they do.

Talker offers the benefit of running within Celebrio, the {``}operating system{''} designed specifically for the elderly. The compatibility is limitless within the XMPP network. Unlike many communication tools, it provides a text chat and a video calling platform bundled together, so the user simply uses it as a {``}dialogue{''} application, no matter which way she feels like communicating at the moment.
\subsection{Use cases}
\label{idp5913184}\hypertarget{idp5913184}{}%

The use case analysis springs from two information sources. The first one is based on an author's own opinion and experience with online communication tools. The other part is patterned on user interviews and the market research, carried out as a part of Celebrio marketing activities. In other words, the potential customers said what their probable use cases would look like. However, there is no quantitative data analysis on this topic.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{talker-uc}{}%
\begin{center}

{{\includegraphics[]{vp/talker-uc}}\hypertarget{idp5916096}{}%
\label{idp5916096}
}
{{\caption[{Talker use case diagram}]{{{Talker use case diagram}}}\label{talker-uc}}}
\end{center}
\end{figure}

As depicted in \hyperlink{talker-uc}{Figure {\ref{talker-uc}}}, the Talker use case analysis is rather simple. There are two actors operating the system, a Celebrio user and a remote XMPP server. The former uses all GUI application components, i.e. she can display a contact list with the presence statuses of the contacts in it, enter the text chat (which includes sending and receiving new messages) and set up a video call. A~contact list, the first application screen, is further described in \hyperlink{chap-contact-list}{Section {\ref{chap-contact-list}}}. When any of the contacts is clicked at, communication view is displayed so the user can read the incoming messages, send a new message or start a video call. Several application screenshots are pictured in \hyperlink{appendix-screenshots}{Appendix {\ref{appendix-screenshots}}}.

There is one more actor depicted in \hyperlink{talker-uc}{Figure {\ref{talker-uc}}}. It is a remote XMPP server, communicating with the application indirectly through an established connection. When a new message appears on a server, it is pushed to the application and handled as an incoming message. Each new message, either received or sent, is appended to the {``}chat history{''}, as it is usual in similar IM clients.
\subsection{Choosing technologies}
\label{sect-choosing-tech}\hypertarget{sect-choosing-tech}{}%

The use cases and a value proposition imply certain technologies and tools that are obvious to be used and also some constraints. At the lowest level, Talker is a part of a web application so it must run in a web browser environment. With respect to the interactivity and real-time behaviour, it must be powered by {\em{JavaScript}}. There are other possibilities, such as Adobe Flash\index{Flash} or browser plugins. However, they do not play well with various environments, as mentioned in \hyperlink{chap-high-level-rtc}{Section {\ref{chap-high-level-rtc}}}.

XMPP has been chosen as the communication protocol for the messages transmission. It is an opened, mature and interoperable technology. Creating a new XMPP service means just plugging in the new part to a world-wide network. XMPP is described in \hyperlink{chap-xmpp}{Chapter {\ref{chap-xmpp}}, {``}Extensible Messaging and Presence Protocol{''}} and the used JavaScript XMPP framework in \hyperlink{chap-xmpp-in-javascript}{Chapter {\ref{chap-xmpp-in-javascript}}, {``}JavaScript XMPP client{''}}. Such nontrivial application, as Talker is, deserves a fine client-side framework. Therefore, the connections, states, contact lists and all messages are not only stored in DOM but also managed by JavaScript itself. In the last years, many MVC\label{idp5927136}\begingroup\catcode`\#=12\footnote{
MVC stands for Model -- View -- Controller, common three-tier architecture. Model is responsible for data layer, View stands for presentation layer. The function of controller varies from one implementation to another, but it is mostly responsible for dispatching the user actions and controlling application flow, for example redirecting.
}\endgroup\docbooktolatexmakefootnoteref{idp5927136} JavaScript frameworks have emerged. When implementing the application, I~have tried Backbone, Angular, Knockout and Ember -- all modern MVC JavaScript frameworks. After a short period of testing, I~chose Ember as the best one. The framework overview, various advantages and also some pitfalls are mentioned in \hyperlink{chap-ember}{Section {\ref{chap-ember}}}.

The last important field to be covered is the video calls platform. On no account did I~consider to implement it from scratch. Anyway, there are several handy tools and frameworks which could have been used. After all, I~decided to use OpenTok, a video calls library described in \hyperlink{chap-opentok}{Section {\ref{chap-opentok}}}, mostly for its wide compatibility. It even supports WebRTC in its newest version, which is considered to be the future of media applications on the web.

% ------------------------   
% Section 
\section{Application architecture}
\label{idp5930960}\hypertarget{idp5930960}{}%

As mentioned in the previous section, Talker is not trivial application which could be served by several inline scripts manipulating the DOM. It has to handle states, keep track of all simultaneous conversations and dispatch all messages to the appropriate contacts. Those reasons led to a semi-modular architecture, depicted in \hyperlink{fig-talker-modules}{Figure {\ref{fig-talker-modules}}}. Modules inside the grey package represent those I~directly implemented, the outside ones are the used libraries and third party modules, however necessary to run the application.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-talker-modules}{}%
\begin{center}

{{\includegraphics[]{vp/components-talker}}\hypertarget{idp5934432}{}%
\label{idp5934432}
}
{{\caption[{An application modules structure}]{{{An application modules structure}}}\label{fig-talker-modules}}}
\end{center}
\end{figure}

The main application logic is placed inside an {\texttt{{App}}} module. It is implemented as an {\texttt{{Ember.Application}}} object and it serves as a namespace for the rest of the application. Using the namespace to wrap the whole application is generally a good practice, so the global namespace (i.e. a {\texttt{{window}}} object) is not polluted. Within the namespace, other Ember-based classes are separated into four parts, according to the MVC structure, i.e. models, views and controllers. The last part is represented by a router, a component responsible for handling the application state.
\subsection{Models}
\label{idp5938368}\hypertarget{idp5938368}{}%

Talker is supposed to handle data: to keep the information about a contact list, update it as the contacts sign in and out; to keep track of the message lists corresponding to individual contacts. All mentioned data manipulation is achieved with {\em{models}}. A~model hierarchy is depicted in \hyperlink{fig-models}{Figure {\ref{fig-models}}}. The main two entities, {\texttt{{Contact}}} and {\texttt{{Message}}}, are rather self-explaining. It should be mentioned that the messages are stored directly as a list property of each contact. Potential contact removal would erase its messages as well. The class\label{idp5941920}\begingroup\catcode`\#=12\footnote{
When speaking about classes and displaying them in the class diagram, one should be aware of the fact there are no real language-based classes in JavaScript. However, Ember provides a convenient way to imitate the class behaviour with {\texttt{{Ember.Object.extend}}} method, further described in the next section.
}\endgroup\docbooktolatexmakefootnoteref{idp5941920} {\texttt{{Person}}} encapsulates the properties common for the contacts and the user operating the application. In other words, the information about the current user, logged in to the application, is stored in an instance of that class.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-models}{}%
\begin{center}

{{\includegraphics[]{vp/cd-app-models}}\hypertarget{idp5946096}{}%
\label{idp5946096}
}
{{\caption[{A structure of the application models}]{{{A structure of the application models}}}\label{fig-models}}}
\end{center}
\end{figure}

\subsection{Views and controllers}
\label{idp5947360}\hypertarget{idp5947360}{}%

All Ember-related issues are described in the section \hyperlink{chap-ember}{Section {\ref{chap-ember}}}, only the structure is mentioned here. As the user traverses the application, various controllers manage the states. The structure of controllers bijectively corresponds to the views hierarchy (i.e. almost every view has its respective controller and vice versa). Thereby, only the controllers are displayed in \hyperlink{fig-controllers}{Figure {\ref{fig-controllers}}}, to show the hierarchy structure. The main view, a contact list, is handled by a {\texttt{{ContactsController}}} instance. When the user enters the conversation, {\texttt{{Conversation Controller}}} takes over the command. {\texttt{{TextController}}} and {\texttt{{VideoController}}} (with their respective views) are present within the conversation. Calling one or another depends on whether the user interacts with the text part (the chat) or the video calls.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-controllers}{}%
\begin{center}

{{\includegraphics[]{vp/cd-app-controllers}}\hypertarget{idp5954032}{}%
\label{idp5954032}
}
{{\caption[{An application views/controllers structure}]{{{An application views/controllers structure}}}\label{fig-controllers}}}
\end{center}
\end{figure}

\subsection{Adapters}
\label{idp5955296}\hypertarget{idp5955296}{}%

There is a considerable amount of application logic not related to the data itself, but comprising the connection establishment, along with managing and triggering the correct handlers when a new data comes from the server. As Jon Cairns fittingly notes in his blog post, models should not contain the unnecessary application logic not directly related to them. \docbooktolatexcite{fat-model-skinny-controller}{} In Talker, such application logic is divided into two {``}adapter{''} classes. {\texttt{{StropheAdapter}}} is responsible for creating, keeping up and reacting to an XMPP connection to a BOSH server. In other words, it mostly handles the text messages. On the contrary, {\texttt{{OpenTokAdapter}}} uses the OpenTok library to keep track of the video calls. The video adapter object is assigned to every contact because it keeps the state information (a session), which is different for each contact. On the other hand, {\texttt{{StropheAdapter}}} is created and initialized just once for the whole application since it does not contain any contact-specific data. The class structure is depicted in \hyperlink{fig-adapters}{Figure {\ref{fig-adapters}}}.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-adapters}{}%
\begin{center}

{{\includegraphics[]{vp/cd-adapters}}\hypertarget{idp5962080}{}%
\label{idp5962080}
}
{{\caption[{Connection of the application and adapters}]{{{Connection of the application and adapters}}}\label{fig-adapters}}}
\end{center}
\end{figure}

% ------------------------   
% Section 
\section{Ember.js -- JavaScript MVC framework}
\label{chap-ember}\hypertarget{chap-ember}{}%

Talker is a purely client-side-based application, implemented in JavaScript and running in a web browser. As mentioned in the technology overview in \hyperlink{sect-choosing-tech}{Section {\ref{sect-choosing-tech}}}, Talker implements the MVC structure on the client side, in the form of Ember MVC objects. In this section, JavaScript MVC is analysed overall at first, then some features specific to Ember, which were used in the implementation, are described.
\subsection{Client-side MVC}
\label{idp5965696}\hypertarget{idp5965696}{}%

First of all, it should be clarified why it is necessary to do MVC in JavaScript. Most of the web technologies running on a server and powering the web applications use some kind of MVC\index{MVC}, across all programming languages. It is Rails for Ruby; Zend, Nette or Symphony for PHP; Django for Python; Spring MVC or even simple servlets with JSPs in Java; ASP.NET MVC for C\#/.NET, etc. It appears that three-tier architecture\index{three-tier architecture} helps the developers to organize the code. In addition, the frameworks can do a considerable amount of job automatically.

In the last couple of years, the approach to a web application development has changed a bit. As the performance of clients increases, the interactivity and a quick response have become the most desired benchmark. And here comes JavaScript, which can manage a whole application at the client side, only synchronizing a data with a server using AJAX requests. It seems this trend of a {\em{thick client}} (sometimes also referred as a {\em{fat client}}) will be increasingly stronger in the next years. A~server is going to be transformed only to a proxy in front of a database system. \docbooktolatexcite{yehuda-talk}{}\docbooktolatexcite{new-dev-era}{}

It is obvious that many tasks, for which a server was responsible previously, have moved to a client -- to JavaScript. Above all, a JavaScript application handles the user actions (such as clicking a button or even typing to an input), renders HTML snippets (i.e. templates) and stores the {``}temporary{''} data, i.e. the data the application currently works with. Storing the data has become a bit tricky, because the JavaScript application works as a first level cache, which processes all changes but synchronizes with the server only occasionally. A~simple example: let there be an input for a user name, bound to a JavaScript model object representing a user. Whenever a new letter appears in the input, JavaScript updates its corresponding model object (still on the client side). No sooner has a whole user name been entered (either submitted or after a certain delay) when JavaScript synchronizes it with the server. A~schema of the whole process is depicted in \hyperlink{fig-js-mvc-input}{Figure {\ref{fig-js-mvc-input}}}.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-js-mvc-input}{}%
\begin{center}

{{\includegraphics[]{vp/js-mvc-input}}\hypertarget{idp5975504}{}%
\label{idp5975504}
}
{{\caption[{Example client-handled input, bound to JavaScript model}]{{{Example client-handled input, bound to JavaScript model}}}\label{fig-js-mvc-input}}}
\end{center}
\end{figure}

The main advantage of such approach is definitely the swiftness. The input changes (numbered 1, 2 and 3) are processed immediately at the client. If a browser ran in an offline mode, submitting would store the data to the local storage eventually. Another very important benefit, especially for an application developer, is the separation of concerns among individual tiers. The result is much better organized and thus better maintainable than a monolithic blend of code, containing all application aspects at one place.

In modern client-side JavaScript MVC frameworks, JavaScript is also responsible for rendering HTML. This topic is set aside to a separate section in \hyperlink{sect-html-rendering}{Section {\ref{sect-html-rendering}}}.
\subsection{Comparison to other frameworks}
\label{idp5978800}\hypertarget{idp5978800}{}%

Ember.js is not the only available JavaScript MVC framework. In fact, there are plenty of similar frameworks, each of which provides a slightly different set of tools and asserting a slightly different philosophy. I~have chosen Ember for Talker due to several reasons. The facts in this section may be a little subjective as they are mostly just opinions of mine, as author of this thesis and the Talker application. There is actually not very much comparison but rather the features specific for Ember are described and explained.

First of all, Ember provides automatic bindings. There are automatic bindings between the object properties, so that all computed properties are automatically updated when the {``}raw{''} properties, which they are based on, change their values. \docbooktolatexcite{ember-in-action}{} The following snippet of code from the {\texttt{{Message}}} object represents such situation: the {\texttt{{fromName}}} attribute represents a contact name, which is based on the contact JID, stored in the {\texttt{{from}}} attribute:

\begin{Verbatim}[fontsize=\small]
App.Message = Ember.Object.extend({
    from : null,
    fromName : function() {
        /* implementation */
    }.property('from')
});
\end{Verbatim}

The binding is really valuable when a value of the {\texttt{{fromName}}} property has already been rendered in a template. There is no {\texttt{{render}}} function (as it is in Backbone framework, for instance) to render the template; templates are rendered automatically and updated automatically as well, as the underlying data changes.

There is a considerable amount of additional work which Ember takes care of. The framework follows the {``}convention over configuration{''} rule to the maximum extent, above all other MVC frameworks. For instance, when one keeps up to the official naming conventions, the framework creates the objects which are necessary and have not yet been defined, such as a missing controller.

Ember.js uses a templating engine Handlebars, which provides a very clean and convenient way to create a presentation layer of the application. In my opinion, using a dedicated templating engine makes the code much more cleaner than using HTML attributes, as for example Knockout.js does. Templating is further described in \hyperlink{sect-html-rendering}{Section {\ref{sect-html-rendering}}}.

To sum it up, Ember.js is a modern and powerful tool doing a considerable amount of job that a programmer does not have to take care about. On the other hand, the learning curve of Ember is told to be one of the steepest and it is rather difficult to make the {\em{second}} step, after reading the basic tutorials and examples. Fortunately, there is an active community working on screencasts\label{idp5990208}\begingroup\catcode`\#=12\footnote{
{\textless}\url{http://emberwatch.com/}{\textgreater}
}\endgroup\docbooktolatexmakefootnoteref{idp5990208}, documentation and actively answering questions on Twitter and StackOverflow.
\subsection{Controllers}
\label{sect-ember-controllers}\hypertarget{sect-ember-controllers}{}%

Application controllers are responsible for storing the current state and mediating the communication between the views and models. \docbooktolatexcite{ember-howto}{} In Ember (and thus in Talker as well), the controllers also represent collections of the model objects.

The first function, processing user actions from the view, is represented by the method {\texttt{{processMessage}}}, in {\texttt{{TextController}}}. The following snippet is a shortened part taken from the Talker source code:

\begin{Verbatim}[fontsize=\small]
App.TextController = Ember.ObjectController.extend({

    processMessage : function(messageText) {

        var message = App.Message.create({ ... });

        message.send();
        this.get('content.messages').pushObject(message);
    }

});
\end{Verbatim}

The method {\texttt{{processMessage}}} is called from the view object, when a message input is submitted. The view just grabs the data from the input and sends it to the controller, which creates a new {\texttt{{Message}}} object, sends the message and finally updates the list of messages for the current contact, accessible via {\texttt{{this.get('content')}}}. Adding {\texttt{{.messages}}} to the {``}selector{''} points the getter directly to the array of messages.\label{idp5999952}\begingroup\catcode`\#=12\footnote{
Actually, the method contains a lot more code such as an argument check and return values. They have been omitted in this example for clarity and shortness.
}\endgroup\docbooktolatexmakefootnoteref{idp5999952}

Another example of a controller from Talker is not an instance of {\texttt{{ObjectController}}}, as in the previous example, but {\texttt{{ArrayController}}}. It represents a collection of contacts, displayed in the main application view:

\begin{Verbatim}[fontsize=\small]
App.contactsController = Ember.ArrayController.create({

    content:[],

    pair : function () {
        var content = this.get('content');
        var result = [];
        for (ii = 0; ii < content.length; ii += 2) {
            result.pushObject({
                "first" : content[ii],
                "second" : content[ii + 1] ? content[ii + 1] : null
            });
        }
        return result;
    }.property('content.@each')
});
\end{Verbatim}

The contacts are stored in the {\texttt{{content}}} attribute, which is an Ember convention for naming an actual data set within an {\texttt{{ArrayController}}}. Since it is necessary to render the contacts as pairs in the two-row-view (depicted in screenshot \hyperlink{fig-screenshot-1}{Figure {\ref{fig-screenshot-1}}}), there is the {\texttt{{pair}}} method returning the content reformatted as an array of pairs. Notice that the function is a property of {\texttt{{content.@each}}}, which means that any update, insertion or deletion of the content array forces the pairs to be recalculated as well.
\subsection{Rendering HTML}
\label{sect-html-rendering}\hypertarget{sect-html-rendering}{}%

A~thick JavaScript client is responsible not only for manipulating the data but also for rendering it to the HTML page. Ember is shipped with Handlebars\index{Handlebars} -- a lightweight templating engine. The application is decomposed to separate views; in case of Talker, it may be a contact list view or the conversation, which consists of another two parts -- a text chat view and a video view. The structure basically corresponds to the controller tree in \hyperlink{fig-controllers}{Figure {\ref{fig-controllers}}}. Additionally, the text chat contains a theoretically unlimited number of views, each of which for a single message -- either sent or received.

There are two important parts of a view: the view object itself and its template. To describe the philosophy of a presentation layer, {\texttt{{VideoView}}} is further examined here, as an example:

\begin{Verbatim}[fontsize=\small]
App.VideoView = Ember.View.extend({
    templateName: 'video',

    buttonLabel : function() {
        return this.get('controller.content.isActive') ? m.stop : m.start;
    }.property("controller.content.isActive")
});
\end{Verbatim}

There are two properties in the view object: {\texttt{{templateName}}} and {\texttt{{buttonLabel}}}. The former just determines the name of a template connected to this view. The latter is a common method returning one of {\texttt{{stop}}} or {\texttt{{start}}} messages, according to the value of the property {\texttt{{isActive}}}, located in the {\texttt{{controller.content}}} object, pointing to the contact the user is currently talking to. The other important part is the template itself, inserted directly in the HTML page:\label{idp6018656}\begingroup\catcode`\#=12\footnote{
Handlebars templates must be compiled by Ember to a JavaScript code to be ready to be used. It is possible to let Ember compile the templates in the browser or precompile the templates on a server. However, there is a very poor support for doing so in PHP. Therefore, templates are rendered in the HTML page and compiled in a browser while application is being developed. For a production, it is recommended to precompile them using the dedicated Node.js module: {\textless}\url{http://handlebarsjs.com/precompilation.html}{\textgreater}.
}\endgroup\docbooktolatexmakefootnoteref{idp6018656}

\begin{Verbatim}[fontsize=\small]
<script type="text/x-handlebars" data-template-name="video">

    <div class="content_margin" >
        <div id="video"><!-- video of me comes here --></div>
        <div id="stream"><!-- video of the contact comes here --></div>
        <div id="message">{{stateMessage}}</div>
    </div>

    <div class="button_wrapper_video">
        <button {{action toggleCall target="controller"}} type="submit">
            {{view.buttonLabel}}
        </button>
    </div>

</script>
\end{Verbatim}

The template is inserted in a {\texttt{{script}}} element, declaring itself as a Handlebars template. The only attribute {\texttt{{data-template-name}}} identifies the snippet and connects it to the view object, which specified the same value in the {\texttt{{templateName}}} attribute, as shown above. The template can contain any HTML, along with the variables and expressions, both enclosed in double braces, sometimes referred as {``}moustaches{''}. In the example of the video template, there is a {\texttt{{stateMessage}}} variable queried, which is looked up in the object bound to the template. The object is provided by a router (described in \hyperlink{sect-routing}{Section {\ref{sect-routing}}}). In this case, the context object would be the current contact the user is talking to.

The second Handlebars expression in the template is an action. Actions are usually bound to the active elements, such as buttons. When the button is clicked, the action is triggered. Ember finds the controller responsible for the current state, which would be an instance of {\texttt{{VideoController}}} in this case, and calls the method {\texttt{{toggleCall}}}, specified in the template expression. Actions can be placed both in the controllers and the views, according to each of whose nature.

Handlebars templates can transform almost any data stored in JavaScript to an HTML code so the rendered template corresponds exactly to the current application state. It is also possible to add an HTML {\texttt{{class}}} attribute, according to the values of the object properties. In the following snippet, there is a message template, rendered individually for each message in the conversation. The class is assigned to the wrapping {\texttt{{div}}} element, according to {\texttt{{isFromMe}}} property. If it evaluates to true, {\texttt{{from\_me}}} class attribute is added, {\texttt{{to\_me}}} otherwise. The {\texttt{{message}}} class is added independently of the properties and it is always present so the block can be styled as the message with custom CSS.

\begin{Verbatim}[fontsize=\small]
<script type="text/x-handlebars" data-template-name="message">
    <div {{bindAttr class="isFromMe:from_me:to_me :message"}}>
        <span class="from">{{fromName}}:</span>
        <span class="text">{{text}}</span>
    </div>
</script>
\end{Verbatim}

The last two things to be mentioned about templates are the topics of iterating and nesting. Have a look at the following example from the main contact list view (altered a bit):

\begin{Verbatim}[fontsize=\small]
<script type="text/x-handlebars" data-template-name="contact-list">
    {{#each App.contactsController.pair}}
        <div class="pair_wrapper">
            {{view App.ContactView contentBinding="first"}}
            {{view App.ContactView contentBinding="second" }}
        </div>
    {{/each}}   
</script>
\end{Verbatim}

When the template is rendered, Ember iterates over the collection of contacts, accessed by the {\texttt{{pair}}} method (it was mentioned in \hyperlink{sect-ember-controllers}{Section {\ref{sect-ember-controllers}}}). Then, the framework takes each contact from the pair and instantiates the {\texttt{{ContactView}}} for it, passing it as a current object for the view and rendering the template exactly in the place the view expression is stated. Therefore, the list of contacts is rendered, grouped by two inside the {\texttt{{pair\_wrapper}}} blocks.
\subsection{Routing}
\label{sect-routing}\hypertarget{sect-routing}{}%

Although HTTP is a stateless protocol, it is common habit to build complex stateful applications on the web. The states are simulated by various web pages and the transitions are carried out by clicking the links. All changes are simultaneously displayed in the URL bar.

The problem is that JavaScript application cannot switch from one web page to another, leaving one and continue at the other. JavaScript would lose its context and whole MVC structure would be purposeless. Therefore, most JavaScript applications using MVC frameworks run at a single web page, no matter how many states they contain. In Ember.js, there is a special object called {\em{Router}}\index{router}, responsible for transitions between the states, dispatching the events and rendering correct templates.\label{idp6042800}\begingroup\catcode`\#=12\footnote{
The Ember router API changed a lot since the application was implemented (it is less than a year, but still). Further in this section, the old version of API is described since it is the version used in the Talker application. Updating Talker to the newest version of Ember.js, with the new router, is one of the possible future tasks.
}\endgroup\docbooktolatexmakefootnoteref{idp6042800}

The router contains several states, ordered in a tree structure, according to the flow of possible user actions. The routes can be nested. The first task of the router is mapping the application states to URLs. Every time the transition takes place, the router changes the context (it basically renders a different template) and it changes the URL as well. Since JavaScript can change only a URL fragment, the router does exactly so. And vice versa, when the user types a specific URL in the URL bar, the application lets the router choose the matching state and set the context in a similar way.

\begin{Verbatim}[fontsize=\small]
App.Router = Ember.Router.extend({

    root: Ember.Route.extend({

        goToContactList : Ember.State.transitionTo('contacts'),
        goToConversation : Ember.State.transitionTo('conversation.index'),

        index : Ember.Route.extend({
            route:'/',
            redirectsTo:"contacts"
        }),

        contacts : Ember.Route.extend({
            route:'/contacts'
        }),

        conversation : Ember.Route.extend({
            route:'/conversation/:contact_id'
            index : Ember.Route.extend({
                route:'/'
            })
        })
    })
});
\end{Verbatim}

Handling the application links is the second responsibility of the router. In the example above, there are two link destinations, named by {\texttt{{goTo*}}} labels. When any element is marked with {\texttt{{\{\{action goTo*\}\}}}}, a Handlebars tag, it is transformed into a link leading to the corresponding router state. And the router handles the event by simply transitioning it to one of the existing states.

Let us have a look at one of the routes in a detail. As mentioned before, the router is responsible for creating a unique URL for every application state. That usually means serializing the application state to URL when the transition is carried out via the link. In the other case, when the URL is typed directly into the URL bar, the router has to deserialize the URL and establish the proper application state.

\begin{Verbatim}[fontsize=\small]
conversation : Ember.Route.extend({

    route : '/conversation/:contact_id',

    connectOutlets : function (router, contact) {
        // binds current contact to the conversationController 
        // so the text/video view can access it
        router.get('applicationController')
              .connectOutlet('conversation', contact);
    },
    deserialize : function (router, params) {
        return App.contactsController.find(function(item) {
            return item.id == params.contact_id;
        });
    },
    serialize : function (router, context) {
        return context ? { contact_id : context.get('id') } : {};
    }
})
\end{Verbatim}

There are two methods providing such functionality, {\texttt{{serialize}}} and {\texttt{{deserialize}}}. The former picks the unique identifier for the current context (a contact object) and returns it as {\texttt{{contact\_id}}}. This parameter is used in the route {\texttt{{'/conversation/:contact\_id'}}} as a dynamic segment, so that actual route would be {\texttt{{'/conversation/42'}}} for example. \docbooktolatexcite{ember-router}{} Deserializing works in the exactly opposite way. Ember prepares the URL segment for the router so it is passed as an object containing the map of dynamic segments, which would be {\texttt{{\{ contact\_id : '42' \}}}} in our (example) case. The only job {\texttt{{deserialize}}} must do is to find the appropriate object (a contact with ID 42) and to return it as the current context object.

The last remarkable aspect of the router is choosing the appropriate templates and connecting them together. Basically, the {\texttt{{connectOutlets}}} method tells the main application controller to {``}include{''} the controller responsible for the current state, which would be a {\texttt{{ConversationController}}} instance in the example above. This is important when the templates are rendered. First, a main application template is rendered. Then, Ember looks into the template for the {\texttt{{\{\{outlet\}\}}}} tag and it inserts the conversation template exactly to the place it is found. The last thing, the appropriate contact object is passed as the context for the conversation controller (and thus the template as well). Everything described in this paragraph is deduced from the one-line implementation of {\texttt{{connectOutlets}}} method in the example above.

% ------------------------   
% Section 
\section{Initializing the connection}
\label{idp6061312}\hypertarget{idp6061312}{}%

When the user clicks at the Talker icon in the Celebrio main menu, a request is sent to the server which generates an HTML page (containing directly HTML as well as the Handlebars templates) and sends it along with all necessary assets, such as JavaScript files and CSS style sheets. When the page is loaded, Talker starts running. First of all, the connection to a remote BOSH server must be established so that the application can communicate with the rest of the world. There are two options to do it: creating a brand new connection or using the existing one, i.e. attaching to the connection as it is described in \hyperlink{strophe-attach}{Section {\ref{strophe-attach}}}.

As JavaScript files are loaded, the {\texttt{{App}}} object is defined by Ember firstly -- a whole MVC structure described in \hyperlink{chap-ember}{Section {\ref{chap-ember}}} is initialized. Then, a new {\texttt{{StropheAdapter}}} object is created and it attempts to establish the connection with a BOSH server immediately. The Strophe adapter supports both creating a new connection and letting the server to create one. The initialization code basically checks whether the password has been provided, i.e. passed to the client code. If yes, a BOSH authentication takes place, as depicted in \hyperlink{fig-conn-establish}{Figure {\ref{fig-conn-establish}}}. When the password has not been provided, the JavaScript client sends an authentication request to the server, which should establish the connection and return JID, SID and RID so the client can attach to the connection and use it for the further communication. The workflow is depicted in \hyperlink{fig-conn-attach}{Figure {\ref{fig-conn-attach}}}. In both cases, an authentication handshake follows the SASL authentication protocol defined by XEP-0206. \docbooktolatexcite{xep-0206}{}

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-conn-establish}{}%
\begin{center}

{{\includegraphics[]{vp/conn-establish}}\hypertarget{idp6069248}{}%
\label{idp6069248}
}
{{\caption[{Establishing a new BOSH connection from JavaScript}]{{{Establishing a new BOSH connection from JavaScript}}}\label{fig-conn-establish}}}
\end{center}
\end{figure}

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-conn-attach}{}%
\begin{center}

{{\includegraphics[]{vp/conn-attach}}\hypertarget{idp6071856}{}%
\label{idp6071856}
}
{{\caption[{Establishing a new BOSH connection using a server side XMPP client}]{{{Establishing a new BOSH connection using a server side XMPP client}}}\label{fig-conn-attach}}}
\end{center}
\end{figure}

It is recommended not to send a password to the client, for obvious security reasons. Therefore, Talker is set to use a server-side connection establishment by default. On the other hand, PHP implementations of XMPP clients are not that matured and certain problems have appeared, as mentioned in \hyperlink{chap-server-side-xmpp-client}{Section {\ref{chap-server-side-xmpp-client}}}.

% ------------------------   
% Section 
\section{Processing events}
\label{idp6074336}\hypertarget{idp6074336}{}%

Talker works as a typical asynchronous application. The application mostly consists of various {\em{callbacks}}\index{callback} (i.e. event listeners), attached to different events and awaiting to be triggered within the JavaScript event loop. \docbooktolatexcite{async-javascript}{} It is a common pattern in JavaScript applications, nowadays, \docbooktolatexcite{js-definitive-guide}{} along with the {\em{promises}}\index{promises} pattern, which wraps the event listener function to a later resolved object, which can be further processed even before the event occurs. \docbooktolatexcite{domenic-promises}{}

Talker does expect the events to come either from the user (traversing the application, sending a message, ...) or from the network (a response from a BOSH server, an incoming message, ...). Basically, almost everything in Talker is intended to be either {\em{declarative}}\index{declarative programming} (Ember object patterns) or {\em{event-based}} (Strophe events).

The first kind of events are those incoming from the network. As it was mentioned in \hyperlink{chap-strophe-events}{Section {\ref{chap-strophe-events}}}, Strophe is set up with the event handlers attached to various event types. There is not even one synchronous call between the application and the server, so that every response is handled by a custom callback asynchronously. All callbacks are defined as the methods of a {\texttt{{StropheAdapter.prototype}}} object, so that they are shared by all {\texttt{{StropheAdapter}}} instances. \docbooktolatexcite{js-enlightnment}{}

Incoming chat messages are handled by a {\texttt{{chatMessage}}} method. The message is passed to the method from the Strophe library in a form of an {\texttt{{Element}}} object. The method parses the message, constructs the Ember model {\texttt{{Message}}} object and tries to assign the message to a contact (the recipient). When the recipient is known (ergo she is present in the user's contact list), a new message is appended to an existing list of messages. Ember automatically updates the view so the message appears in the list immediately.

\begin{Verbatim}[fontsize=\small]
var message = App.Message.create({
    to : msg.getAttribute('to'),
    from : Strophe.getBareJidFromJid(msg.getAttribute('from')),
    type : msg.getAttribute('type')
});

var contact = App.contactsController.find(function(item) {
    return item.jid == message.from;
});

contact.get('messages').pushObject(message);
\end{Verbatim}

The user actions are handled mostly by Ember itself. For example, sending a new message is managed by the controller (described in \hyperlink{sect-ember-controllers}{Section {\ref{sect-ember-controllers}}}), which only calls an adapter function, which actually sends the prepared message object. It is one of the design drawbacks of the application, that there is a two-way awareness between the adapter and the controllers (sometimes a controller calls the adapter, sometimes the adapter actively calls the controller). Such design was chosen for its simplicity and it appeared to be sufficient for the application of Talker's size.
\subsection{Notifications\index{notifications}}
\label{idp6089856}\hypertarget{idp6089856}{}%

Talker is only a part of a bigger system -- Celebrio. The user has to find out when a new message arrives. Therefore, a simple mechanism of notifications has been developed and used across the system, not only in Talker. When a new chat message arrives, the application triggers a built-in mechanism of notifications and the notification message is propagated to the main Celebrio frame, utilizing the {\texttt{{postMessage}}} API.\label{idp6092720}\begingroup\catcode`\#=12\footnote{
{\textless}\url{https://developer.mozilla.org/en-US/docs/DOM/window.postMessage}{\textgreater}
}\endgroup\docbooktolatexmakefootnoteref{idp6092720} Since the notifications are not specific to Talker and they were not developed as a part of the application, they are not further described here.

% ------------------------   
% Section 
\section{Logger}
\label{idp6094576}\hypertarget{idp6094576}{}%

Although JavaScript is a very popular language, at least in web applications, there is no common way to log\index{logging} events or custom messages. There are two possible reasons: Firstly, JavaScript runs in a web browser and frequent AJAX requests would be necessary to log everything what happens. Secondly, a web browser is kind of a {``}hostile{''} environment, so the system developer cannot rely on the message truthfulness at all. Nevertheless, it is useful to have some information logged, at least while developing the application, locally to the browser console.\label{idp6097504}\begingroup\catcode`\#=12\footnote{
All current browsers have the {\texttt{{console.log}}} method implemented, which outputs a message from the JavaScript code to the browser console, accessible to anyone using the browser. The main advantage is the fact that the console is hidden from the ordinary users, yet it can be easily accessed by anyone debugging the application or reporting a bug. See the API for details: {\textless}\url{https://developer.mozilla.org/en/docs/DOM/console.log}{\textgreater}.
}\endgroup\docbooktolatexmakefootnoteref{idp6097504}

The main problem with the frequently used {\texttt{{console.log}}} method is the impossibility of hiding a certain kind of messages. In Talker, there are several different kinds of logs: those related to messages, the video, subscriptions, notifications etc. It is impossible to have the output uncluttered without constant commenting and uncommenting the {\texttt{{console.log}}} calls.

In order to solve this trouble, a logging library Log4js\index{Log4js} has been used in the application. It allows to create various loggers (with various appenders). Each logger has its own log level set, so that it outputs only the messages tagged by that level, or higher. Actually, the logger usage is very similar to a well-known log4j\index{log4j}, including formating layouts. There is an AJAX appender available in Log4js so it is possible to send the messages to the server to be stored permanently. This might be also useful to log the error messages not reproducible in the development environment.
\subsection{Setup}
\label{idp6105280}\hypertarget{idp6105280}{}%

The logger (with a console appender) is set up as follows:

\begin{Verbatim}[fontsize=\small]
Log4js.getLogger("message")
      .setLevel(Log4js.Level.INFO)
      .setAppenders([new Log4js.BrowserConsoleAppender()]);
\end{Verbatim}

Originally, the library does not allow chaining methods so a local variable must be created to set up the logger (or the {\texttt{{getLogger}}} method must be called multiple times). I~believe method chaining is a sensible pattern so I~reimplemented several methods in the library to get it supported. Unfortunately, the project is not hosted on GitHub so it is rather difficult to offer the changes back to the community.

Once the logger is initialized, it is stored in the Log4js internal list of loggers. Later on, each logger can be retrieved from that list by calling the same {\texttt{{getLogger}}} method as during the initialization.
\subsection{Logging}
\label{idp6109968}\hypertarget{idp6109968}{}%

Logging a message is also rather easy; it might look as the following example (cut out of {\texttt{{onConnect}}} method in Talker):

\begin{Verbatim}[fontsize=\small]
App.log.logger.info('Strophe is connected as ' + App.me.jid);
App.log.logger.debug(this);
\end{Verbatim}

Two notes should be mentioned about the code. Firstly, all loggers which have been set up are accessible not only directly from Log4js object, but also via the {\texttt{{App.log}}} object. It is a wrapper so the used logging library (Log4js in our case) can be changed (and it was changed several times during the development). As long as the logger objects implement common logging methods (such as {\texttt{{info}}} and {\texttt{{debug}}}), the application will work without the need to change the logging itself.

The second note is about logging various complex objects such as {\texttt{{this}}}, pointing to {\texttt{{Strophe.connection}}} in the example call. Log4js does not provide any layout which would not transform the value to string -- [object Object] in our case. This is not very useful. The developer usually knows there is an object and she just wants the possibility to inspect it. Therefore, I~enhanced the library again in order to log complex objects. First of all, the logger outputs a text message saying a complex value is about to be logged. Then, the complex value is logged individually, without being cast to string. Therefore, it is possible to access it interactively in the console, to fold and unfold nested properties and to carry out other inspections. Logging the object from the example above thus looks as follows (arrows inside the object symbolize that the property can be further inspected):

\begin{Verbatim}[fontsize=\small]
INFO - Strophe is connected as pavel.smolka@jappix.com
DEBUG - [object Object]
Strophe.Connection {
 -> adapter: StropheAdapter
 -> addHandlers: Array[0]
 ...
}
\end{Verbatim}

% ------------------------   
% Section 
\section{Contact list}
\label{chap-contact-list}\hypertarget{chap-contact-list}{}%

The list of contacts is an essential part of every instant messaging application. The same applies to Talker, with a tiny modification compared to classical IM clients. Talker has been designed and implemented as a part of Celebrio -- a comprehensive {``}web operating system{''}. The contact list is not managed by Talker itself, it servers to other applications as well. On the other hand, the user can connect an existing third party XMPP account to Celebrio, with its own contact list (a roster). It is crucial to deal with the contacts duplication and to perform appropriate matching of one to the other.
\subsection{Fetching Celebrio contact list}
\label{idp6122256}\hypertarget{idp6122256}{}%

As mentioned in the previous paragraph, the contact list base comes from the server-side database. Celebrio asks the user for adding her contacts in the People application, other part of the system. All contacts are stored in a relational database and they available throughout the system, in all applications. One of the properties of a contact entity is its JID. For the needs of Talker, the contacts are filtered on the server so that only those which have a JID filled are returned as the user's contact list.

Since Talker is a JavaScript application, the contacts are passed to JavaScript in a JSON format. To avoid an extra request (and thus a delay), contact list is rendered directly by PHP to the {\texttt{{\textless{}script/\textgreater{}}}} element in the server-side processed template, during the initial request. Then, when the Ember application is initialized, the array of plain JavaScript objects is transformed to the content of {\texttt{{ArrayController}}}, specifically {\texttt{{App.contactsController}}}. After that, the application can easily manage rendering the contact list within a Handlebars template and keeping it up-to-date.

The Ember class {\texttt{{Contact}}} is one of the most voluminous objects in the application. Each {\texttt{{Contact}}} object contains both the {``}static{''} properties from a server (such as the contact's name or its avatar picture) and the dynamic information about the current state in the application. The latter category includes the information whether the contact is online or not, its presence status (DND, Away, ...) and also all messages related to the contact.

In whole Celebrio system, there is a rule that the contacts the user has not added to her contact list (in the People application) do not affect the user in any way. In fact, all messages, updates or invites from unknown contacts are processed by the application, but they are thrown away and not displayed to the user. There is a possibility to easily extend the application to be able to communicate with contacts that have not been added yet. However, it would break the system philosophy. Making such decision is not up to the thesis author.
\subsection{Matching entries from XMPP roster}
\label{idp6130384}\hypertarget{idp6130384}{}%

A~contact list retrieved from the Celebrio back-end, as it was described in the previous section, is only an underlying material for building the actual contact list. The other part is the XMPP roster\index{XMPP!roster} (an XMPP contact list), stored at the XMPP server. The roster can possibly contain contacts different from those originating from an internal Celebrio contact list, because the roster can be accessed from other XMPP clients as well.

When the application is connected, fetching a roster from an XMPP server is one of the first steps. One of Strophe.js plugins (plugins were generally described in \hyperlink{chap-strophe-plugins}{Section {\ref{chap-strophe-plugins}}}), called characteristically Roster, provides a convenient API for such task -- a callback function is passed to the {\texttt{{roster.get}}} method and executed when the roster is fetched.

The callback does basically two things, as depicted in \hyperlink{fig-roster-fetch}{Figure {\ref{fig-roster-fetch}}}. The retrieved contacts (those from the XMPP roster) are matched to existing contacts, retrieved previously from the Celebrio server. For each XMPP contact retrieved in the roster, the appropriate record in the {\texttt{{contactsController}}} array is found and matched. Contacts present only in the roster are just logged, the application does not work with them.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-roster-fetch}{}%
\begin{center}

{{\includegraphics[]{vp/roster-fetch}}\hypertarget{idp6138528}{}%
\label{idp6138528}
}
{{\caption[{Matching XMPP roster and Celebrio contact list}]{{{Matching XMPP roster and Celebrio contact list}}}\label{fig-roster-fetch}}}
\end{center}
\end{figure}

The second part (the left side of the picture) of matching contacts works from the opposite direction. The application processes all contacts that have been retrieved from the server and which are not present in the XMPP roster. Then, it sends a subscription request to each such contact, which consists of several steps, but it simply stands for adding a contact to the user's XMPP roster.
\subsection{Presence and online statuses}
\label{idp6140624}\hypertarget{idp6140624}{}%

One of the biggest advantages of real-time communication tools is the fact that one can actually see whether her contacts are currently available (i.e. online, logged in) or not. In terms of XMPP and Talker, we speak about {\em{presence}}\index{presence}. Strophe does not provide a convenient way to work with presence, but Roster plugin does.\label{idp6143152}\begingroup\catcode`\#=12\footnote{
It is the same Roster plugin which handles a roster retrieval and processing, mentioned in the previous section.
}\endgroup\docbooktolatexmakefootnoteref{idp6143152}

The presence is processed in a way usual to Strophe: the developer provides a callback related to a certain topic, which is triggered when anything related to that topic happens. The process of binding the callback is described in \hyperlink{chap-strophe-plugins}{Section {\ref{chap-strophe-plugins}}}. When the callback is bound, Strophe watches over presence changes sent in a form of presence stanzas from a server and hands them over to the assigned callback -- {\texttt{{onPresenceChange}}} method -- where the presence change is processed.

The callback function receives two parameters. The first one contains the list of all contacts, the second parameter represents the information only about the contact whose presence has changed. This is a bit tricky because the callback is triggered even if only the presence of the currently logged in user changes -- in this case the second parameter (i.e. {\texttt{{changed}}}) is undefined.

The presence is processed in two ways. Firstly, there is basic telling online from offline status. The other part is an optional online status specifying the availability (away, DND, ...), contained in the {\texttt{{\textless{}show/\textgreater{}}}} element of an XMPP message. \docbooktolatexcite{rfc-3921}{} The online status is processed as well and the current value is stored for each contact. Unfortunately, the graphic design for showing statuses has not been proposed yet so it is not displayed within the application, yet ready to be.

There is one more glitch about online statuses. XMPP makes it possible for the user to be logged in simultaneously from several devices. In such case, each session (called a resource in terms of XMPP) should state its priority. By changing the priority appropriately, it is possible to keep the client running at home and yet receive the messages at work by being logged there in with a higher priority. In case the contact is logged in from several places (i.e. several distinct pieces of presence information are fetched from the server), Talker finds the resource with a highest priority and processes its online status.

Another possible approach would be sorting online statuses from the most desirable (i.e. online would be the first, then away, ...) and looking for the {``}best{''} one, regardless of the priority. It could actually more correspond to the real state of matters because some clients (such as Google Talk client) set always the highest priority. However, I~decided to keep the rules XMPP protocol sets.
\subsection{Subscriptions}
\label{idp6152352}\hypertarget{idp6152352}{}%

Subscribing in XMPP basically addresses adding the contacts to the contact list and asking them to do the same. On the account of the application simplicity, Talker deals with subscriptions automatically. When a new contact (i.e. a new contact added in Celebrio) is found, the subscription request is sent when Talker starts and loads the contact list. In the opposite direction, when a subscription request is received, the application tries to find the appropriate contact and subscribe too. If no such contact is found, information is logged and nothing happens.

This approach has one big advantage: the user does not have to respond to subscription requests and she does not need to send own requests either. Yet, there is also one disadvantage, basically the same thing from the opposite point of view. The user cannot fully control her contact list -- for example to refuse a subscription request from the contact in the roster. We decided for this trade off to make the application as simple as possible.

% ------------------------   
% Section 
\section{Video calls}
\label{chap-video-calling}\hypertarget{chap-video-calling}{}%

Providing a simple interface for video calls is one of the goals of Talker application. To achieve it, OpenTok library has been used. OpenTok is a high-level library from TokBox company, allowing the developer to embed video calls support to an arbitrary web application. In this section, a basic usage of OpenTok library is described as well as the specifics for Talker implementation. OpenTok consists of a JavaScript part and a server-side SDK, necessary to initialize a session.
\subsection{Initializing OpenTok session}
\label{idp6156976}\hypertarget{idp6156976}{}%

Before actually working with the OpenTok JavaScript library, the application must create a session for a new call that is about to be established. Therefore, the JavaScript web application queries a server (with an OpenTok SDK running) to generate one. The server-side SDK connects to the official OpenTok server\label{idp6158240}\begingroup\catcode`\#=12\footnote{
{\textless}\url{http://api.opentok.com/hl}{\textgreater}
}\endgroup\docbooktolatexmakefootnoteref{idp6158240} and retrieves the session. The reason why the request cannot be sent directly from JavaScript is a security\index{security} -- the server-side SDK proves its identity with a unique API secret, issued along with an API key directly by TokBox and assigned to every OpenTok application. The process of retrieving a session ID is depicted in \hyperlink{fig-opentok-sid}{Figure {\ref{fig-opentok-sid}}}.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-opentok-sid}{}%
\begin{center}

{{\includegraphics[]{vp/opentok-sid}}\hypertarget{idp6162768}{}%
\label{idp6162768}
}
{{\caption[{The process of initializing OpenTok session}]{{{The process of initializing OpenTok session}}}\label{fig-opentok-sid}}}
\end{center}
\end{figure}

Along with the session, a unique token is generated by the server-side SDK. It simply constitutes a hash of the session ID, timestamp, a client role (either publisher or subscriber) and optional user data. Within Talker, the last mentioned field is used for distinguishing free users from the premium ones, i.e. handing over the additional information to the session. To sum it up, the session ID identifies the session (i.e. one call among various number of people, typically two) and a token serves as a specific user identification.
\subsection{Using OpenTok JavaScript library}
\label{idp6165024}\hypertarget{idp6165024}{}%

After including the OpenTok JavaScript file into the application, the library is accessible via global {\texttt{{TB}}} object. When the session ID and a token are created for the application instance, the actual call can be established. The session object is created and the application connects to the new session, identifying self with the previously issued token:

\begin{Verbatim}[fontsize=\small]
var API_KEY = '1234567';
var session = TB.initSession(sessionId);
session.connect(API_KEY, token);
\end{Verbatim}

Even though the previous code would establish the connection, no matter what happens with the connection, the application can not respond to it. That is the reason why event handlers must be bound to the session so the application can respond, for example to someone connecting to the same session and sending a stream. Binding an event listener looks as follows:

\begin{Verbatim}[fontsize=\small]
session.addEventListener("sessionConnected", function (event) {
    subscribeToStreams(event.streams);
    var publisher = TB.initPublisher(API_KEY, 'publishing');
        session.publish(publisher);
    });
};
\end{Verbatim}

In this way, every time something happens within the session, the provided callback is triggered.
\subsection{Interconnection of callers}
\label{idp6170128}\hypertarget{idp6170128}{}%

Within Talker, the previously described methods are set aside along with the code related to video calls into a separate object -- OpenTokAdapter. The adapter is instantiated for each contact in the application since, theoretically, several video calls can take place independently. Once a video call is established and an OpenTok session is created, the information about the session is sent to the other party so that she can join the call.

We decided to use an ordinary XMPP chat message to inform the other side about the call event, because the user of Talker can either communicate with someone else using Talker as well or the other party can be connected via any other XMPP client. Therefore, the message informing about a video call contains a short label {\texttt{{Celebrio-CALL}}}, followed by a link. The link contains the information about the session and when clicked (in case the other party uses an ordinary IM client, such as Pidgin), a new Celebrio window is opened and the user answers the call. This separate window has (almost) nothing to do with Celebrio and it could be implemented as an independent application as well. It is just a substitution of Talker for the contacts not communicating via Celebrio.

When the application receives an incoming call request (in a form of the link described above), it parses the request link and hence obtains a session ID. The next step is asking the server to generate another unique token, which Talker uses for establishing the call (i.e. connecting to the session, subscribing to the other party stream and publishing its own).
\subsection{Call states}
\label{idp6174496}\hypertarget{idp6174496}{}%

Once a call is initiated, it can be either answered or timed out. There are 60 seconds within the other side must respond to the call. If not answered, the video call is hung up. All possible states along with the transition actions are depicted in \hyperlink{fig-call-states}{Figure {\ref{fig-call-states}}}.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-call-states}{}%
\begin{center}

{{\includegraphics[]{vp/video-calls}}\hypertarget{idp6177680}{}%
\label{idp6177680}
}
{{\caption[{Video call states}]{{{Video call states}}}\label{fig-call-states}}}
\end{center}
\end{figure}

\subsection{Embedding the video element}
\label{idp6178944}\hypertarget{idp6178944}{}%

If the video call is successfully established, two video elements must be embedded to the page. One for the user of the application to be able to see herself, the other one (the bigger one) for displaying the other call participant. OpenTok provides a convenient way to create a video element. There is an action listener which triggers the following code when the session is connected (i.e. when the application connects to the session identified by given session ID), creating a video element of the caller (it is referred as the video of {``}me{''} in the application):

\begin{Verbatim}[fontsize=\small]
$("#video").append("<div id='publishing'></div>")
var publisher = TB.initPublisher(API_KEY, 'publishing', {
    width: 100,
    height: 80
});
\end{Verbatim}

The previous piece of code creates a new HTML element ({\texttt{{\#publishing}}}), in which OpenTok embeds the video. Depending on the used library version, either a Flash object or an HTML5 video element is created, with the specified width and height. The reason why the application creates a wrapper element each time a call is established is caused by the library removing both video element {\em{and}} its wrapper, when the call is hung up (or dismissed after the timeout).

Creating and an automatic disposal of a video element of the other call participant is similar, only it is triggered when a new stream is created within the session.

% ------------------------   
% Section 
\section{Testing}
\label{idp6184768}\hypertarget{idp6184768}{}%

Every application is somehow tested during the development. The most popular way of doing so is traversing the application manually, especially in case of web applications. It is definitely the easiest but also not repeatable and thus difficult to scale in large projects. Therefore, automatic tests are often used. There are three kinds of tests concerning web applications. The most widespread are server-side code tests, mostly unit tests. Testing server-side code brings the benefit of a predictable and easily modifiable runtime environment. However, Talker is a client-side application and therefore server-side unit testing is not an option. The other two types of tests, both related to Talker, are JavaScript code (unit) tests and user interface tests with Selenium, both described below.

JavaScript unit testing\index{unit test} is a relatively new technique, definitely younger than classic JUnit tests in Java or PHPUnit in PHP. Earlier, a JavaScript application consisted of several action listeners bound to HTML elements on a web page. However, hardly did the real application logic move to JavaScript when the application code grew bigger. Therefore, it must be tested automatically.

There are several available solutions for unit testing in JavaScript. Some solutions cover a whole testing {``}stack{''}, such as Jasmine or QUnit. On the other hand, there are tools which separate the problem of testing (setting up the environment and running tests) from assertion, which is responsible for injecting the functions which help with checking whether the tested method behaves correctly and returns correct values. I~believe the separation of concerns is a good pattern overall so I~have used the tools from the second group: Mocha\index{Mocha} and Intern\index{Intern} -- testing frameworks, both using Chai\index{Chai} as the assertion library.

JavaScript is specific by not having a strictly defined runtime environment. Usually, a client-side JavaScript runs in a web browser interpreter. However, there are also many tools running with Node.js, the JavaScript server-side platform and runtime environment. Since Talker is web-based application, it is crucial to have it tested in the web browser environment. Most of the solutions described below perform the automatic tests in the web browser environment, only plain Mocha tests are run with Node.js.

As a part of this thesis, Talker code has been tested with the Intern framework, Mocha unit testing library and JsTestDriver framework. In addition, the system tests have been implemented using Selenium framework, to check whether the application works as a whole.
\subsection{Chai assertion library}
\label{idp6195360}\hypertarget{idp6195360}{}%

Before the unit testing frameworks can be described, another part of testing must be mentioned. It is the assertion, i.e. checking whether the code resulted to the expected values. Both Intern and Mocha, testing frameworks described later on (and both used for testing Talker), use the assertion library Chai. It provides a convenient and easily readable way to check various conditions.

There are two assertion styles which can be used with Chai: a behavior-driven development/descriptions (BDD style) and a test-driven ones (TDD). They differ only by syntax, their expression power is equal. TDD style looks similarly to JUnit or PHPUnit: \docbooktolatexcite{chai-api}{}

\begin{Verbatim}[fontsize=\small]
assert.include([ 1, 2, 3 ], 3);
assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
\end{Verbatim}

On the other hand, BDD provides an easy-to-read word chaining, resulting to a sentence. The following example of BDD equals the previous one (TDD), only the used style differs: \docbooktolatexcite{chai-api}{}

\begin{Verbatim}[fontsize=\small]
expect([1,2,3]).to.include(3);
expect({ tea: { green: 'matcha' }})
    .to.have.deep.property('green.tea', 'matcha');
\end{Verbatim}
\subsection{Unit testing with Intern framework}
\label{idp6200272}\hypertarget{idp6200272}{}%

Intern is a tool for creating, running and managing JavaScript unit tests, all with a minimal need to set up other third party tools and environments. Intern can be either installed as a npm\label{idp6201392}\begingroup\catcode`\#=12\footnote{
Node.js package
}\endgroup\docbooktolatexmakefootnoteref{idp6201392} package, from the central repository,\label{idp6202160}\begingroup\catcode`\#=12\footnote{
{\textless}\url{https://npmjs.org/package/intern}{\textgreater}
}\endgroup\docbooktolatexmakefootnoteref{idp6202160} or built manually (which was the only way to install it until recently). \docbooktolatexcite{intern-blog}{} After the installation, a configuration file must be set up to tell the framework where the tests are and how the testing environment should look like.

Similarly as with Chai, the tests can be implemented in two syntax ways: TDD and BDD. The following examples are snippets from the real tests implemented for Talker, executed with Intern, using BDD style. The overall test structure uses Dojo (a library Intern depends on, providing the {\texttt{{define}}} method) and it looks as follows:

\begin{Verbatim}[fontsize=\small]
define([
  /* load dependencies */
], function (bdd, expect) {
  with (bdd) {

    /* test suite */
    describe('StropheAdapter', function () {
  
      /* before each test */
      beforeEach(function() {
        adapter = new StropheAdapter();
        send = adapter.connection.send;
      });

      /* inner test suite = set of tests */
      describe('#constructor', function () {

        /* test itself, with description */
        it('should do something...', function () {
          /* perform test, make assertions */
        });
      });
    });
  }
});
\end{Verbatim}

First, there are dependencies defined, so the framework loads them before the test suite is executed. Almost all JavaScript files included in the application are defined here to emulate the environment of the application as precisely as possible. The next statement tells that the BDD style is going to be used. Later on, actual test suites with tests are listed. Each suite can mention {\texttt{{before}}}, {\texttt{{beforeEach}}}, {\texttt{{after}}} and {\texttt{{afterEach}}} functions to be run, similarly as other testing frameworks allow. A~test itself consists of a description label and a test body, defined as an anonymous function. The label should describe the test aim and hence identify it. Inside the test body function, any code can be executed as well as assertions can be carried out.

JavaScript differs from common programming languages in the way the asynchronous code is executed. JavaScript does not provide multithreading by default. \docbooktolatexcite{js-definitive-guide}{} Hence, the pattern of passing a callback to the asynchronous operation is used instead. Unfortunately, it is a nontrivial task to test asynchronous code in JavaScript. Intern provides a convenient way to do so, using the {\em{promises}}\index{promises} pattern. The following example tests that {\texttt{{start}}} method connects the application to an XMPP server in 10 seconds, using Chai assertion to check it.

\begin{Verbatim}[fontsize=\small]
it('should connect and call onConnection callback', function () {
    var dfd = this.async(10000);
    adapter.start(dfd.rejectOnError(function (status) {
        if (!(status === Strophe.Status.ATTACHED 
                || status === Strophe.Status.CONNECTED)) {
            return;
        }

        expect(adapter.connection.connected).to.be.true;
        // explicitly resolve the test since 
        // it was successful to this point
        dfd.resolve();
    }));
});
\end{Verbatim}

The callback is handed over to the {\texttt{{start}}} method to be triggered every time the connection status changes. This means it is also triggered if Strophe only performs the authentication or even if the connection fails! Therefore, the promise is resolved (so the test succeeds) only if the correct status is passed as an argument.

It has to be admitted that the previous test is not a real unit test, mocking all surrounding objects the function interacts with. Considering that the goal of testing is making sure the implemented methods work as expected, having it implemented like this is the easiest and most straightforward way to achieve the goal. Mocking the libraries and network requests would require substantial architecture changes in the application, leading to an inappropriate complexity and problems for anyone when working with the application {``}out of the box{''}.
\subsection{Mocha unit tests}
\label{idp6217568}\hypertarget{idp6217568}{}%

Mocha\index{Mocha} is another framework for creating unit tests in JavaScript. The structure of tests is similar to Intern, as well as support for the BDD style with {\texttt{{describe}}} and {\texttt{{it}}} keywords. What makes the difference is the way Mocha tests are executed and the dependencies are loaded. Mocha is more lightweight than Intern, not including any configuration files nor environment administration.

The easiest way to run Mocha is from command line: {\texttt{{mocha test-file.js}}}. However, to be able to use Chai to do assertions, each test file must declare it with Node {\texttt{{require}}} function. The unit test implemented with Mocha then looks as the following example -- similarly to the Intern test:

\begin{Verbatim}[fontsize=\small]
var expect = require('chai').expect;

describe('StropheAdapter', function(){
    describe('#constructor', function(){
        it('should do something...', function () {
          /* perform test, make assertions */
        });
    })
});
\end{Verbatim}
\subsection{JsTestDriver\index{JsTestDriver} framework}
\label{idp6224288}\hypertarget{idp6224288}{}%

Running Mocha tests in a console with Node brings one huge disadvantage. There is no easy option to load custom JavaScript files which are necessary to perform the test, unless they are packed as npm packages. Therefore, I~used another tool called JsTestDriver to wrap Mocha tests, load dependencies before executing them and also run them in the browser environment.

JsTestDriver (JSTD) is a Java library allowing the developers to run the tests in a certain environment, according to a specified configuration file. Although JSTD has not originally been intended to be used with Mocha, there is an available adapter which bridges this imperfection.\label{idp6227328}\begingroup\catcode`\#=12\footnote{
{\textless}\url{https://github.com/wikidi/mocha-jstd-adapter}{\textgreater}
}\endgroup\docbooktolatexmakefootnoteref{idp6227328} Furthermore, JSTD can be easily run from PHPStorm or WebStorm IDEs (with a plugin in the IDE, designed specifically for JSTD).

There is a configuration file for JSTD test suite, specifying the scripts to be loaded and test files to be executed, similarly as Intern does. The structure is self-explaining:

\begin{Verbatim}[fontsize=\small]
load:
  - "lib/mocha.js"
  - "lib/chai.js"
  - "../path/to/../strophe_adapter.js"
test:
  - "test-file.js"
\end{Verbatim}

Mocha and Chai have to be loaded explicitly. Moreover, Mocha and Chai must be set up manually in each test file:

\begin{Verbatim}[fontsize=\small]
mocha.setup('bdd');
expect = chai.expect;
\end{Verbatim}

Although JSTD looks like a worthwhile tool, I~had serious problems with keeping it running. A~nondeterministic behavior, when the same test (a simple test without any side effects, network dependencies and so on) sometimes passes and sometimes results in an infinite loop never ending the process, makes JSTD almost impossible to be used.
\subsection{Selenium tests\index{Selenium}}
\label{idp6232160}\hypertarget{idp6232160}{}%

Testing the functionality of individual methods with unit tests or packages with integration tests is usually insufficient. Even if all functions and methods worked correctly, it is not guaranteed that the application behaves fine as a whole. Therefore, {\em{system testing}} comes in handy, here in the form of {\em{testing user interface}} actions with the Selenium framework.

Selenium is the user interface testing framework for web applications. It traverses the application from the user's point of view, performing the same actions as user usually does, directly in a web browser. Therefore, a Selenium test suite is more or less just a set of instructions -- user actions, that are performed in a certain succession (in a web browser environment), written in a custom programming language. PHP has been chosen for Talker Selenium tests, since whole Celebrio back-end is written in PHP.

The Selenium framework itself is a Java tool, running on background. Java basically starts a server, which serves as a proxy and starts a web browser instance. In this web browser instance, Selenium tests are run automatically. Selenium could be compared to an arbitrary macro tool, recording and replaying user actions.

There are two versions of Selenium. The older version, Selenium 1, sometimes also called Selenium RC, basically {``}injected{''} the tests to a web browser in the form of JavaScript functions and then ran them using JavaScript as well. On the contrary, Selenium 2, which uses a WebDriver API, drives the browser directly using its built-in support for automation. \docbooktolatexcite{selenium-webdriver}{} Since the version 2 is more lightweight and provides several additional features, it has been used as a testing framework for the UI tests in Talker.

The generic tests functionality, common to a whole system, used not only in Talker, is implemented in the {\texttt{{SeleniumBase}}} class. The specific web browser the tests will run in is chosen there, along with several additional actions mutual to all test suites, not only Talker. The other important thing to be handled in the base class is logging in a user. Each Selenium test runs separately (there is a usual requirement for test independency) so the user has to be logged in before the test enters the application itself. Logging the user is implemented in the same way as the tests are, so that Selenium opens a web page with the login screen, it fills in the user credentials and the login button is pressed.

When the user is logged in, the main specifics of the application can be tested. The test suite checks whether the important elements are present on a page. Then, it performs basic operations such as entering the conversation view and sending a message. The tests are implemented within the {\texttt{{TalkerTest}}} class. An example of a testing method looks as follows:

\begin{Verbatim}[fontsize=\small]
public function testConversationRoute() {
    $this->signIn();
    $this->url("app/talker");
    $contact = $this->byClassName("menu_item_people");
    $contact->click();
    $this->assertRegExp('/#\\/conversation\\/\\d+/i', $this->url());
}
\end{Verbatim}

At the start, the example test method logs the user in and enters the Talker application. In fact, the steps copy the standard user actions. When the application is loaded, a specific element (representing an item in the contact list) is selected and clicked. In case the element was missing, the test would fail immediately. Finally, the PHPUnit testing and assertion library checks whether the URL has been correctly set to a new one, identifying a conversation view.

To keep the tests as much independent as possible, incoming actions (such as an incoming message or an answered video call) are not incorporated in the test suite. Still, the main aim of the Selenium test suite is met. Whenever the application code is changed, the test suite ensures that nothing has broken and that the important parts have not changed.

% -------------------------------------------------------------
% Chapter Conclusion 
% ------------------------------------------------------------- 	
\chapter{Conclusion}
\label{idp6245584}\hypertarget{idp6245584}{}%

The thesis embraces the topic of real-time communication in a web browser. Several approaches to RTC in a web browser were described, including HTTP polling and WebSockets, in the first, theoretical, part. Several frameworks were mentioned. From the simple ones such as Server-sent events, providing just a thin layer over the HTTP, to the complex solutions (e.g. WebRTC or even OpenTok), serving for video calling right in a web browser.

% ------------------------   
% Section 
\section{How the results are used}
\label{idp6247088}\hypertarget{idp6247088}{}%

It is obvious from the wide range of frameworks, libraries and complete solutions that a web browser turns from a web document reader into a platform that can host almost any kind of application, including real-time ones. Therefore, such an application -- Talker -- has been created. It is a real-time communication application serving as an IM client for Celebrio, a web-based system for the elderly. Talker implements both text chat, using XMPP due to its wide usage and interoperability, and video calls, built with OpenTok framework (using Flash or HTML5 WebRTC).

Talker has been designed, implemented, tested and integrated into Celebrio. It is part of the production version now and actually one of the main reasons users are willing to pay for the system. Hence, the thesis goal has not only been reached but in some parts even extended. Talker is available in the system\label{idp6249344}\begingroup\catcode`\#=12\footnote{
Production version of the system is running at {\textless}\url{http://system.celebriosoftware.com}{\textgreater}.
}\endgroup\docbooktolatexmakefootnoteref{idp6249344} so anyone can try it. Nevertheless, several changes have been made recently but they have not been deployed in the system yet. Thus, the latest source code is attached to the thesis. It is not intended to run alone, without the system.

% ------------------------   
% Section 
\section{Future possibilities}
\label{idp6251264}\hypertarget{idp6251264}{}%

There is still a long way to go until the application is perfect. It can be (and certainly will be) updated in many aspects since all used frameworks still evolve, as well as Celebrio does.

Version 1.0.0 of Ember.js is about to be released any day now. The new version will certainly contain many improvements, both in performance and code style. Ember router has been completely reworked and additional support for loading data from a server with Ember Data framework is available. All of these are definitely worth updating.

Strophe.js is more stable and not evolving so fast. However, it might be interesting to use WebSockets instead of sending HTTP long polling requests, which are about to be added to the library soon. Unofficial implementations already exist and the library author is working on a XMPP over WebSockets specification. \docbooktolatexcite{xmpp-over-websockets}{} Jingle is about to be added to Strophe as well, but maybe in a longer time period.

Finally, even the application itself may be further enhanced. The core concept has been proven and the main features have been implemented, yet there are several fancy additions that can be introduced. Above all, the already implemented chat states (away, DND, ...) are not shown in the user interface yet. This is job which only depends on the system graphical designer. Additionally, the chat history can be added so the user can see the messages sent and received during the previous sessions.

Because the application has been developed as part of proprietary software system Celebrio, it has not been opensourced and it is not likely to be. However, the application core could be generalized and provided to the community. In that case, adding the XMPP chat and video calling to any web application could become just a matter of including {``}Talker component{''}. To do so, several steps would have to occur. Firstly, the user interface would have to be separated from the application logic. Probably only an API would be left for the user to implement his own UI and bind the actions from the application to the certain elements on a page. In addition, it would be necessary to make the contact list independent of Celebrio, probably by using only the XMPP roster.

To sum it up, Talker is a working application, ready to be further enhanced and improved in the future. I~hope it will. I~also hope it will serve its users to meet their needs and enjoy the real-time communication in a web browser.

% ------------------------------------------- 
%
%  Bibliography - chapter
%
% ------------------------------------------- 
\begin{thebibliography}{123}\hypertarget{idp6258256}{}

% ............. biblioentry 
\bibitem{android-flash-support}\docbooktolatexbibaux{idp6487168}{android-flash-support}
\hypertarget{idp6487168}
Wauters, G.: \emph{Adobe Flash for Android: Gone with barely a whimper}, Digital Trends, 8/17/2012 [retrieved 4/5/2013], from {\textless}\url{http://www.digitaltrends.com/mobile/adobe-flash-for-android-gone-with-barely-a-whimper/}{\textgreater}. 

% ............. biblioentry 
\bibitem{aol-trademarks}\docbooktolatexbibaux{idp6343696}{aol-trademarks}
\hypertarget{idp6343696}
AOL Inc.: \emph{AOL Trademark List}, 3/15/2011 [retrieved 2/20/2013], from {\textless}\url{http://legal.aol.com/trademarks/}{\textgreater}. 

% ............. biblioentry 
\bibitem{apache-core-features}\docbooktolatexbibaux{idp6383872}{apache-core-features}
\hypertarget{idp6383872}
The Apache Software Foundation: \emph{Apache Core Features}, 2013 [retrieved 2/23/2013], from {\textless}\url{http://httpd.apache.org/docs/2.2/mod/core.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{async-javascript}\docbooktolatexbibaux{idp6287008}{async-javascript}
\hypertarget{idp6287008}
Burnham, T.: \emph{Async JavaScript}, The Pragmatic Programmers, 2012, 978-1-93778-527-7, 104 (3). 

% ............. biblioentry 
\bibitem{attached-to-strophe}\docbooktolatexbibaux{idp6568272}{attached-to-strophe}
\hypertarget{idp6568272}
Moffitt, J.: \emph{Getting Attached To Strophe}, 8/3/2008 [retrieved 4/15/2013], from {\textless}\url{http://metajack.im/2008/10/03/getting-attached-to-strophe/}{\textgreater}. 

% ............. biblioentry 
\bibitem{bayeux}\docbooktolatexbibaux{idp6508656}{bayeux}
\hypertarget{idp6508656}
Russell, A. and Wilkins, G. and Davis, D. and Nesbitt, M.: \emph{The Bayeux Specification}, 2007 [retrieved 4/5/2013], The Dojo Foundation, from {\textless}\url{http://svn.cometd.org/trunk/bayeux/bayeux.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{brian-stats-tweet}\docbooktolatexbibaux{idp6357968}{brian-stats-tweet}
\hypertarget{idp6357968}
Staatss, B. (Brianstaats): \emph{{``}If you have to customize 1/5 of a reusable component, its likely better to write it from scratch @trek at \#embercamp{''}}, 2/15/2013 [retrieved 2/23/2013], Tweet. 

% ............. biblioentry 
\bibitem{chai-api}\docbooktolatexbibaux{idp6594544}{chai-api}
\hypertarget{idp6594544}
Luer, J.: \emph{Chai API}, 2013 [retrieved 5/4/2013], from {\textless}\url{http://chaijs.com/api/}{\textgreater}. 

% ............. biblioentry 
\bibitem{definitive-guide-to-html5}\docbooktolatexbibaux{idp6273184}{definitive-guide-to-html5}
\hypertarget{idp6273184}
Freeman, A.: \emph{The Definitive Guide to HTML5}, Apress, 2011, 978-1-4302-3960-4, 1080 (880). 

% ............. biblioentry 
\bibitem{definitive-guide-to-ws}\docbooktolatexbibaux{idp6265888}{definitive-guide-to-ws}
\hypertarget{idp6265888}
Wang, V. and Salim, F. and Moskovits, P.: \emph{The Definitive Guide to HTML5 WebSocket}, Apress, 2012, 978-1430247401, 210 (140, 156, ). 

% ............. biblioentry 
\bibitem{domenic-promises}\docbooktolatexbibaux{idp6632128}{domenic-promises}
\hypertarget{idp6632128}
Denicola, D.: \emph{Callbacks, Promises, and Coroutines}, 2013 [retrieved 5/20/2013], Slideshare, from {\textless}\url{http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript}{\textgreater}. 

% ............. biblioentry 
\bibitem{elderly-questionnaires}\docbooktolatexbibaux{idp6338592}{elderly-questionnaires}
\hypertarget{idp6338592}
Smolka, P. and Novák, M.: \emph{Elderly people and the computers}, 2/11/2013 [retrieved 2/19/2013], from {\textless}\url{http://infogr.am/Seniori-a-pocitace}{\textgreater}. 

% ............. biblioentry 
\bibitem{ember-howto}\docbooktolatexbibaux{idp6314816}{ember-howto}
\hypertarget{idp6314816}
Bodmer, M.: \emph{Ember.js Application Development How-to}, Packt Publishing, 2013, 978-1-78216-338-1, 40 (16). 

% ............. biblioentry 
\bibitem{ember-in-action}\docbooktolatexbibaux{idp6309824}{ember-in-action}
\hypertarget{idp6309824}
Skeie, J.: \emph{Ember.js in Action}, Manning Publications, 2013, 978-1617291456, 325 (21). 

% ............. biblioentry 
\bibitem{ember-router}\docbooktolatexbibaux{idp6628400}{ember-router}
\hypertarget{idp6628400}
Tilde, Inc.: \emph{Specifying a route's model}, 2013 [retrieved 5/21/2013], from {\textless}\url{http://emberjs.com/guides/routing/specifying-a-routes-model/}{\textgreater}. 

% ............. biblioentry 
\bibitem{facebook-usage}\docbooktolatexbibaux{idp6330400}{facebook-usage}
\hypertarget{idp6330400}
Olanoff, D.: \emph{Facebook Announces Monthly Active Users Were At 1.01 Billion As
      Of September 30th}, TechCrunch, 10/23/2012 [retrieved 2/19/2013], from {\textless}\url{http://techcrunch.com/2012/10/23/facebook-announces}{\textgreater}. 

% ............. biblioentry 
\bibitem{fat-model-skinny-controller}\docbooktolatexbibaux{idp6572384}{fat-model-skinny-controller}
\hypertarget{idp6572384}
Cairns, J.: \emph{{``}Fat model, skinny controller{''} is a load of
      rubbish}, 4/11/2013 [retrieved 4/21/2013], from {\textless}\url{http://joncairns.com/2013/04/fat-model-skinny-controller-is-a-load-of-rubbish/}{\textgreater}. 

% ............. biblioentry 
\bibitem{fb-chat}\docbooktolatexbibaux{idp6354400}{fb-chat}
\hypertarget{idp6354400}
Facebook Developers: \emph{Facebook Chat API}, 2/12/2013 [retrieved 2/20/2013], from http://xmpp.org/about-xmpp/history/ {\textless}\url{http://legal.aol.com/trademarks/}{\textgreater}. 

% ............. biblioentry 
\bibitem{fb-erlang}\docbooktolatexbibaux{idp6361312}{fb-erlang}
\hypertarget{idp6361312}
Letuchy, E.: \emph{Facebook Chat}, 5/14/2008 [retrieved 2/23/2013], from {\textless}\url{https://www.facebook.com/note.php?note_id=14218138919}{\textgreater}. 

% ............. biblioentry 
\bibitem{flash-bundled-with-chrome}\docbooktolatexbibaux{idp6482736}{flash-bundled-with-chrome}
\hypertarget{idp6482736}
Wauters, R.: \emph{Flash Player To Come Bundled With Google Chrome, New Browser
      Plugin API Coming}, TechCrunch, 3/30/2010 [retrieved 4/5/2013], from {\textless}\url{http://techcrunch.com/2010/03/30/flash-player}{\textgreater}. 

% ............. biblioentry 
\bibitem{google-closing-xmpp}\docbooktolatexbibaux{idp6457648}{google-closing-xmpp}
\hypertarget{idp6457648}
Sullivan, J.: \emph{Google backslides on federated instant messaging, on
      purpose?}, 3/15/2013 [retrieved 3/31/2013], from {\textless}\url{https://www.fsf.org/blogs/sysadmin/google-backslides-on-federated-instant-messaging-on-purpose}{\textgreater}. 

% ............. biblioentry 
\bibitem{gtalk}\docbooktolatexbibaux{idp6350832}{gtalk}
\hypertarget{idp6350832}
Google Developers: \emph{Google Talk Developer Documentation}, 3/23/2012 [retrieved 2/20/2013], from {\textless}\url{https://developers.google.com/talk/talk_developers_home}{\textgreater}. 

% ............. biblioentry 
\bibitem{ice}\docbooktolatexbibaux{idp6529728}{ice}
\hypertarget{idp6529728}
Rosenberg, J. and Keranen, A. and Lowekamp, B. and Roach, A.: \emph{TCP Candidates with Interactive Connectivity Establishment
      (ICE)}, 5/18/2012 [retrieved 4/6/2013], from {\textless}\url{http://tools.ietf.org/html/draft-ietf-mmusic-ice-tcp-16}{\textgreater}. 

% ............. biblioentry 
\bibitem{ie-statistics}\docbooktolatexbibaux{idp6426240}{ie-statistics}
\hypertarget{idp6426240}
Terabyte Media: \emph{Web Browser Usage Statistics}, 12/2012 [retrieved 3/3/2013], from {\textless}\url{http://www.statowl.com/web_browser_usage_by_version.php?limit\%5B\%5D=ie}{\textgreater}. 

% ............. biblioentry 
\bibitem{intern-blog}\docbooktolatexbibaux{idp6590432}{intern-blog}
\hypertarget{idp6590432}
Bouchon, P.: \emph{Meet your newest Intern}, 5/1/2013 [retrieved 5/4/2013], from {\textless}\url{http://www.sitepen.com/blog/2013/05/01/intern-javascript-testing/}{\textgreater}. 

% ............. biblioentry 
\bibitem{internet-usage}\docbooktolatexbibaux{idp6326448}{internet-usage}
\hypertarget{idp6326448}
Miniwatts Marketing Group: \emph{Internet Users in the World - 2012 Q2}, Internet World Stats, 2/17/2013 [retrieved 2/19/2013], from {\textless}\url{http://www.internetworldstats.com/stats.htm}{\textgreater}. 

% ............. biblioentry 
\bibitem{iphone-flash-support}\docbooktolatexbibaux{idp6491696}{iphone-flash-support}
\hypertarget{idp6491696}
Apple Support Team: \emph{Does the iPhone support Flash?}, 2007 [retrieved 4/5/2013], from {\textless}\url{http://www.iphonefaq.org/archives/9730}{\textgreater}. 

% ............. biblioentry 
\bibitem{jingle-is-the-future}\docbooktolatexbibaux{idp6478912}{jingle-is-the-future}
\hypertarget{idp6478912}
Cridland, D.: \emph{Google: {``}The Future is Jingle{''}}, 6/23/2011 [retrieved 3/31/2013], from {\textless}\url{http://xmpp.org/2011/06/the-future-is-jingle/}{\textgreater}. 

% ............. biblioentry 
\bibitem{jquery-api}\docbooktolatexbibaux{idp6560592}{jquery-api}
\hypertarget{idp6560592}
The jQuery Foundation: \emph{jQuery API Documentation}, 2013 [retrieved 4/10/2013], from {\textless}\url{http://api.jquery.com/append/}{\textgreater}. 

% ............. biblioentry 
\bibitem{js-definitive-guide}\docbooktolatexbibaux{idp6277792}{js-definitive-guide}
\hypertarget{idp6277792}
Flanagan, D.: \emph{JavaScript: The Definitive Guide}, O'Reilly Media, 2011, 978-0-596-80552-4, 1100 (320, 322, 333). 

% ............. biblioentry 
\bibitem{js-enlightnment}\docbooktolatexbibaux{idp6282400}{js-enlightnment}
\hypertarget{idp6282400}
Lindley, C.: \emph{JavaScript Enlightenment}, O'Reilly Media, 2013, 978-1449342883, 166 (49). 

% ............. biblioentry 
\bibitem{libjingle}\docbooktolatexbibaux{idp6475728}{libjingle}
\hypertarget{idp6475728}
Google Developers: \emph{About libjingle}, 3/23/2012 [retrieved 3/31/2013], from {\textless}\url{https://developers.google.com/talk/libjingle/}{\textgreater}. 

% ............. biblioentry 
\bibitem{mozilla-ws}\docbooktolatexbibaux{idp6411424}{mozilla-ws}
\hypertarget{idp6411424}
Mozilla Developers: \emph{WebSockets}, 2/4/2013 [retrieved 2/25/2013], from {\textless}\url{https://developer.mozilla.org/en-US/docs/WebSockets}{\textgreater}. 

% ............. biblioentry 
\bibitem{new-dev-era}\docbooktolatexbibaux{idp6581504}{new-dev-era}
\hypertarget{idp6581504}
Ziadé, T.: \emph{A~new development era (essay)}, 1/25/2013 [retrieved 4/26/2013], from {\textless}\url{http://blog.ziade.org/2013/01/25/a-new-development-era-essay/}{\textgreater}. 

% ............. biblioentry 
\bibitem{new-hangouts}\docbooktolatexbibaux{idp6623344}{new-hangouts}
\hypertarget{idp6623344}
Gallagher, S.: \emph{Hands on with Hangouts, Google's new text and video chat
      architecture}, 5/17/2013 [retrieved 5/20/2013], Ars Technica, from {\textless}\url{http://arstechnica.com/information-technology/2013/05/hands-on-with-h/}{\textgreater}. 

% ............. biblioentry 
\bibitem{opentok-pricing}\docbooktolatexbibaux{idp6602608}{opentok-pricing}
\hypertarget{idp6602608}
TokBox Inc.: \emph{OpenTok pricing}, 2013 [retrieved 5/6/2013], from {\textless}\url{http://www.tokbox.com/pricing}{\textgreater}. 

% ............. biblioentry 
\bibitem{opentok-server-side-lib}\docbooktolatexbibaux{idp6606176}{opentok-server-side-lib}
\hypertarget{idp6606176}
TokBox Inc.: \emph{OpenTok server-side libraries reference}, 2013 [retrieved 5/6/2013], from {\textless}\url{http://www.tokbox.com/opentok/docs/server/server_side_libraries.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{pro-html5-programming}\docbooktolatexbibaux{idp6298224}{pro-html5-programming}
\hypertarget{idp6298224}
Lubbers, P. and Salim, F. and Albers, B.: \emph{Pro HTML5 Programming}, Apress, 2011, 978-1-4302-3864-5, 352 (165, ...). 

% ............. biblioentry 
\bibitem{realtime-web-apps}\docbooktolatexbibaux{idp6292000}{realtime-web-apps}
\hypertarget{idp6292000}
Lengstorf, J. and Leggetter, P.: \emph{Realtime Web Apps}, Apress, 2013, 978-1430246206, 400. 

% ............. biblioentry 
\bibitem{rfc-3921}\docbooktolatexbibaux{idp6585616}{rfc-3921}
\hypertarget{idp6585616}
Saint-Andre, P.: \emph{Extensible Messaging and Presence Protocol (XMPP): Instant
      Messaging and Presence}, 2004 [retrieved 5/4/2013], Jabber Software Foundation, from {\textless}\url{http://xmpp.org/rfcs/rfc3921.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{rfc-bidirectional-http}\docbooktolatexbibaux{idp6387056}{rfc-bidirectional-http}
\hypertarget{idp6387056}
Loreto, S. and Saint-Andre, P. and Salsano, S. and Wilkins, G.: \emph{Known Issues and Best Practices for the Use of Long Polling and
      Streaming in Bidirectional HTTP}, 4/2011 [retrieved 2/23/2013], from {\textless}\url{http://www.ietf.org/rfc/rfc6202.txt}{\textgreater}. 

% ............. biblioentry 
\bibitem{rfc-http}\docbooktolatexbibaux{idp6372240}{rfc-http}
\hypertarget{idp6372240}
Fielding, R. and Gettis, J. and Mogul, J. and Frystyk, H. and Masinter, L. and Leach, P. and Berners-Lee, T.: \emph{Hypertext Transfer Protocol -- HTTP/1.1}, 6/1999 [retrieved 2/23/2013], from {\textless}\url{http://www.w3.org/Protocols/rfc2616/rfc2616.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{rfc-ws}\docbooktolatexbibaux{idp6394960}{rfc-ws}
\hypertarget{idp6394960}
Fette, I. and Melnikov, A.: \emph{The WebSocket Protocol}, 12/2011 [retrieved 2/24/2013], Internet Engineering Task Force (IETF), from {\textless}\url{http://tools.ietf.org/html/rfc6455}{\textgreater}. 

% ............. biblioentry 
\bibitem{ria}\docbooktolatexbibaux{idp6334832}{ria}
\hypertarget{idp6334832}
Ward, J.: \emph{What is a Rich Internet Application?}, 10/17/2007 [retrieved 2/19/2013], from {\textless}\url{http://www.jamesward.com/2007/10/17/what-is-a-rich-internet-application/}{\textgreater}. 

% ............. biblioentry 
\bibitem{selenium-webdriver}\docbooktolatexbibaux{idp6619776}{selenium-webdriver}
\hypertarget{idp6619776}
Selenium Project Authors: \emph{Selenium WebDriver}, 5/17/2013 [retrieved 5/19/2013], from {\textless}\url{http://docs.seleniumhq.org/docs/03_webdriver.jsp}{\textgreater}. 

% ............. biblioentry 
\bibitem{setting-up-bosh}\docbooktolatexbibaux{idp6450736}{setting-up-bosh}
\hypertarget{idp6450736}
Prosody: \emph{Setting up a BOSH server}, [retrieved 3/10/2013], from {\textless}\url{http://prosody.im/doc/setting_up_bosh}{\textgreater}. 

% ............. biblioentry 
\bibitem{signalr}\docbooktolatexbibaux{idp6494880}{signalr}
\hypertarget{idp6494880}
Edwards, D.: \emph{SignalR FAQ}, GitHub, 9/7/2012 [retrieved 4/5/2013], from {\textless}\url{https://github.com/SignalR/SignalR/wiki/Faq}{\textgreater}. 

% ............. biblioentry 
\bibitem{skype-license}\docbooktolatexbibaux{idp6364880}{skype-license}
\hypertarget{idp6364880}
Smith, A.: \emph{Does SkypeKit work on Android?}, 8/7/2012 [retrieved 2/23/2013], from {\textless}\url{http://devforum.skype.com/t5/SkypeKit-FAQs/Does-SkypeKit-work-on-Android/m-p/16490/thread-id/78}{\textgreater}. 

% ............. biblioentry 
\bibitem{skype-uri}\docbooktolatexbibaux{idp6369056}{skype-uri}
\hypertarget{idp6369056}
Microsoft: \emph{Skype URIs}, 2013 [retrieved 2/23/2013], from {\textless}\url{http://dev.skype.com/skype-uri}{\textgreater}. 

% ............. biblioentry 
\bibitem{spammy-invites}\docbooktolatexbibaux{idp6461520}{spammy-invites}
\hypertarget{idp6461520}
Gustafsson, P.: \emph{Spammy invites}, 2/13/2013 [retrieved 3/31/2013], from {\textless}\url{http://mail.jabber.org/pipermail/operators/2013-February/001571.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{spammy-invites-update}\docbooktolatexbibaux{idp6598496}{spammy-invites-update}
\hypertarget{idp6598496}
Gustafsson, P.: \emph{Update on spammy invites}, 5/4/2013 [retrieved 5/6/2013], from {\textless}\url{http://mail.jabber.org/pipermail/operators/2013-April/001672.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{ssdp-udp}\docbooktolatexbibaux{idp6609904}{ssdp-udp}
\hypertarget{idp6609904}
Presser, A. and Farrell, L. and Kemp, D. and Lupton, W. and Tsuruyama, S. and Albright, S.: \emph{UPnP Device Architecture}, 10/15/2008 [retrieved 5/6/2013], from {\textless}\url{http://www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.1.pdf}{\textgreater}. 

% ............. biblioentry 
\bibitem{sse-api}\docbooktolatexbibaux{idp6499216}{sse-api}
\hypertarget{idp6499216}
Hickson, I.: \emph{Server-Sent Events}, 3/29/2013 [retrieved 4/5/2013], W3C, from {\textless}\url{http://dev.w3.org/html5/eventsource/}{\textgreater}. 

% ............. biblioentry 
\bibitem{sse-multiline}\docbooktolatexbibaux{idp6503936}{sse-multiline}
\hypertarget{idp6503936}
Sharp, R.: \emph{Server-Sent Events}, 1/24/2012 [retrieved 4/5/2013], HTML5Doctor, from {\textless}\url{http://html5doctor.com/server-sent-events/}{\textgreater}. 

% ............. biblioentry 
\bibitem{strophe-api}\docbooktolatexbibaux{idp6564160}{strophe-api}
\hypertarget{idp6564160}
Moffitt, J.: \emph{Strophe.js API Documentation}, 2013 [retrieved 4/10/2013], from {\textless}\url{http://strophe.im/strophejs/doc/1.0.2/files2/strophe-js.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{value-proposition}\docbooktolatexbibaux{idp6319424}{value-proposition}
\hypertarget{idp6319424}
Barnes, C. and Blake, H. and Pinder, D.: \emph{Creating and Delivering Your Value Proposition: Managing Customer
      Experience for Profit}, Kogan Page Publishers, 2009, 978-0749458591, 232. 

% ............. biblioentry 
\bibitem{webrtc-ericsson}\docbooktolatexbibaux{idp6542512}{webrtc-ericsson}
\hypertarget{idp6542512}
Alund, S.: \emph{Bowser -- The World's First WebRTC-Enabled Mobile Browser}, 10/19/2012 [retrieved 4/6/2013], from {\textless}\url{https://labs.ericsson.com/blog/bowser-the-world-s-first-webrtc-enabled-mobile-browser}{\textgreater}. 

% ............. biblioentry 
\bibitem{webrtc-interop}\docbooktolatexbibaux{idp6537216}{webrtc-interop}
\hypertarget{idp6537216}
Reavy, M. and Lachapelle, S.: \emph{Hello Firefox, this is Chrome calling!}, 2/4/2013 [retrieved 4/6/2013], from {\textless}\url{http://blog.chromium.org/2013/02/hello-firefox-this-is-chrome-calling.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{webrtc-ms}\docbooktolatexbibaux{idp6546800}{webrtc-ms}
\hypertarget{idp6546800}
Aboba, B. and Thomson, M.: \emph{Customizable, Ubiquitous Real Time Communication over the Web
      (CU-RTC-Web)}, 8/9/2012 [retrieved 4/6/2013], Microsoft, from {\textless}\url{http://html5labs.interoperabilitybridges.com/cu-rtc-web/cu-rtc-web.htm}{\textgreater}. 

% ............. biblioentry 
\bibitem{webrtc-rfc}\docbooktolatexbibaux{idp6521168}{webrtc-rfc}
\hypertarget{idp6521168}
Bergkvist, A. and Burnett, D. and Jennings, C. and Narayanan, A.: \emph{WebRTC 1.0: Real-time Communication Between Browsers}, 3/22/2013 [retrieved 4/6/2013], W3C, from {\textless}\url{http://dev.w3.org/2011/webrtc/editor/webrtc.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{webrtc-signaling}\docbooktolatexbibaux{idp6516832}{webrtc-signaling}
\hypertarget{idp6516832}
Dutton, S.: \emph{Getting Started with WebRTC}, 7/23/2012 [retrieved 4/6/2013], HTML5 Rocks, from {\textless}\url{http://www.html5rocks.com/en/tutorials/webrtc/basics/}{\textgreater}. 

% ............. biblioentry 
\bibitem{webrtc-skype}\docbooktolatexbibaux{idp6552928}{webrtc-skype}
\hypertarget{idp6552928}
Roettgers, J.: \emph{Scoop: Microsoft bets on WebRTC for Skype's browser
      future}, 6/26/2012 [retrieved 4/6/2013], from {\textless}\url{http://gigaom.com/2012/06/26/skype-webrtc-web-client/}{\textgreater}. 

% ............. biblioentry 
\bibitem{webrtc4all}\docbooktolatexbibaux{idp6557024}{webrtc4all}
\hypertarget{idp6557024}
Doubango Telecom: \emph{webrtc4all}, 2012 [retrieved 4/6/2013], from {\textless}\url{https://code.google.com/p/webrtc4all/}{\textgreater}. 

% ............. biblioentry 
\bibitem{ws-api}\docbooktolatexbibaux{idp6406704}{ws-api}
\hypertarget{idp6406704}
Hickson, I.: \emph{The WebSocket API}, 2/9/2013 [retrieved 2/24/2013], W3C, from {\textless}\url{http://dev.w3.org/html5/websockets/}{\textgreater}. 

% ............. biblioentry 
\bibitem{ws-caniuse}\docbooktolatexbibaux{idp6423056}{ws-caniuse}
\hypertarget{idp6423056}
StatCounter GlobalStats: \emph{Can I~use Web Sockets?}, 2/2013 [retrieved 3/3/2013], from {\textless}\url{http://caniuse.com/websockets}{\textgreater}. 

% ............. biblioentry 
\bibitem{ws-html5rocks}\docbooktolatexbibaux{idp6414608}{ws-html5rocks}
\hypertarget{idp6414608}
Ubl, M. and Kitamura, E.: \emph{Introducing WebSockets: Bringing Sockets to the Web}, 2/13/2012 [retrieved 2/25/2013], from {\textless}\url{http://www.html5rocks.com/en/tutorials/websockets/basics/}{\textgreater}. 

% ............. biblioentry 
\bibitem{ws-iana}\docbooktolatexbibaux{idp6419872}{ws-iana}
\hypertarget{idp6419872}
IANA: \emph{WebSocket Protocol Registries}, 11/13/2012 [retrieved 2/25/2013], from {\textless}\url{http://www.iana.org/assignments/websocket/websocket.xml}{\textgreater}. 

% ............. biblioentry 
\bibitem{ws-proxy}\docbooktolatexbibaux{idp6401600}{ws-proxy}
\hypertarget{idp6401600}
Lubbers, P.: \emph{How HTML5 Web Sockets Interact With Proxy Servers}, 3/16/2011 [retrieved 2/24/2013], InfoQ, from {\textless}\url{http://tools.ietf.org/html/rfc6455}{\textgreater}. 

% ............. biblioentry 
\bibitem{xep-0025}\docbooktolatexbibaux{idp6437840}{xep-0025}
\hypertarget{idp6437840}
Hildebrand, J. and Kaes, C. and Waite, D.: \emph{XEP-0025: Jabber HTTP Polling}, XMPP Standards Foundation, 2009 [retrieved 3/10/2013], from {\textless}\url{http://xmpp.org/extensions/xep-0025.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{xep-0124}\docbooktolatexbibaux{idp6429584}{xep-0124}
\hypertarget{idp6429584}
Paterson, I. and Saint-Andre, P. and Smith, D. and Moffit, J.: \emph{XEP-0124: Bidirectional-streams Over Synchronous HTTP
      (BOSH)}, XMPP Standards Foundation, 2010 [retrieved 3/10/2013], from {\textless}\url{http://xmpp.org/extensions/xep-0124.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{xep-0166}\docbooktolatexbibaux{idp6465248}{xep-0166}
\hypertarget{idp6465248}
Ludwig, S. and Beda, J. and Saint-Andre, P. and McQueen, R. and Egan, S. and Hildebrand, J.: \emph{XEP-0166: Jingle}, XMPP Standards Foundation, 2009 [retrieved 3/31/2013], from {\textless}\url{http://xmpp.org/extensions/xep-0166.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{xep-0206}\docbooktolatexbibaux{idp6444864}{xep-0206}
\hypertarget{idp6444864}
Paterson, I. and Saint-Andre, P.: \emph{XEP-0206: XMPP Over BOSH}, XMPP Standards Foundation, 2010 [retrieved 3/10/2013], from {\textless}\url{http://xmpp.org/extensions/xep-0206.html}{\textgreater}. 

% ............. biblioentry 
\bibitem{xmpp-history}\docbooktolatexbibaux{idp6347264}{xmpp-history}
\hypertarget{idp6347264}
The XMPP Standards Foundation: \emph{History of XMPP}, 1/27/2010 [retrieved 2/20/2013], from http://xmpp.org/about-xmpp/history/ {\textless}\url{http://legal.aol.com/trademarks/}{\textgreater}. 

% ............. biblioentry 
\bibitem{xmpp-in-javascript}\docbooktolatexbibaux{idp6305136}{xmpp-in-javascript}
\hypertarget{idp6305136}
Moffitt, J.: \emph{Professional XMPP Programming with JavaScript and jQuery}, John Wiley \& Sons, 2010, 978-0470540718, 432 (58, 380, 402). 

% ............. biblioentry 
\bibitem{xmpp-over-websockets}\docbooktolatexbibaux{idp6453920}{xmpp-over-websockets}
\hypertarget{idp6453920}
Moffit, J.: \emph{An XMPP Sub-protocol for WebSocket}, 2/25/2013 [retrieved 3/10/2013], from {\textless}\url{http://datatracker.ietf.org/doc/draft-moffitt-xmpp-over-websocket/}{\textgreater}. 

% ............. biblioentry 
\bibitem{xmpp-the-definitive-guide}\docbooktolatexbibaux{idp6258512}{xmpp-the-definitive-guide}
\hypertarget{idp6258512}
Saint-Andre, P. and Smith, K. and Tronçon, R.: \emph{XMPP: The Definitive Guide}, Sebastopol: O'Reilly, 2009, 978-0-596-52126-4, 310 (7, 13, 14, 16, ). 

% ............. biblioentry 
\bibitem{yehuda-talk}\docbooktolatexbibaux{idp6576784}{yehuda-talk}
\hypertarget{idp6576784}
Katz, Y.: \emph{Building Web Applications with Ember.js}, 4/13/2013 [retrieved 4/26/2013], YouTube, from {\textless}\url{http://www.youtube.com/watch?v=u6RFyVN9sNg}{\textgreater}. 

\end{thebibliography}
\addcontentsline{toc}{chapter}{Bibliography}
\setlength\saveparskip\parskip
\setlength\saveparindent\parindent
\begin{dbtolatexindex}{idp6637264}{}
\setlength\tempparskip\parskip \setlength\tempparindent\parindent
\parskip\saveparskip \parindent\saveparindent
\noindent \indexspace
\parskip\tempparskip
\parindent\tempparindent
\makeatletter\@input@{\jobname.ind}\makeatother
\addcontentsline{toc}{chapter}{Index}
\end{dbtolatexindex}
\listoffigures
\listoftables
\MainMatter

\newcommand{\dbappendix}[1]{\chapter{#1}}%
% ------------------------------------------------------------- 
% Appendices start here
% -------------------------------------------------------------
\appendix

% -------------------------------------------------------------
% appendix:  Screenshots of the application 
% ------------------------------------------------------------- 	
\dbappendix{Screenshots of the application}
\label{appendix-screenshots}\hypertarget{appendix-screenshots}{}%

There are two screenshots of the Talker application in this appendix. The first one depicts the application main view, displaying the list of contacts. As you can see, online contacts are decorated by a green border. The second picture shows the conversation between the application user (administrator account, called Celebrity, has been used) and one of the online users.

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{fig-screenshot-1}{}%
\begin{center}

{{\includegraphics[width=420pt]{img/screenshot-contact-list}}\hypertarget{idp6640832}{}%
\label{idp6640832}
}
{{\caption[{Talker main view, displaying the list of contacts}]{{{Talker main view, displaying the list of contacts}}}\label{fig-screenshot-1}}}
\end{center}
\end{figure}

% figure ------------------------------------------------------
\begin{figure}[hbt]
\hypertarget{idp6642208}{}%
\begin{center}

{{\includegraphics[width=420pt]{img/screenshot-conversation}}\hypertarget{idp6643344}{}%
\label{idp6643344}
}
{{\caption[{Screenshot of the conversation view}]{{{Screenshot of the conversation view}}}\label{idp6642208}}}
\end{center}
\end{figure}

\end{document}

